%%% shu-doc.tex --- Shu project documentation
%%
%% Copyright (C) 2018 Stewart L. Palmer
%%
%% Author: Stewart L. Pslmer <stewart@stewartpalmer.com>
%%
%% This file is NOT part of GNU Emacs.
%%
%% This is free software: you can redistribute it and/or modify it
%% under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.
%%
%% This software is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY% without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%% General Public License for more details.
%%
%% There is a copy of the Gnu General Public license in the file
%% LICENSE in this repository.  You should also have received a copy
%% of the GNU General Public License along with GNU Emacs.  If not,
%% see <http://www.gnu.org/licenses/>.
%%





\section{Overview}


This manual contains detailed information on all of the function, macro,
variable, and constant definitions in this repository.

Version 1.0 was merged with the master branch on 31 December 2018.

Version 1.1 was merged with the master branch on 5 January 2019.

Version 1.2 was merged with the master branch on 6 January 2019.

Version 1.3 was merged with the master branch on 12 January 2019.

Version 1.4 was merged with the master branch on 2 February 2019.

Version 1.5 was merged with the master branch on 18 August 2019.

Version 1.6 was merged with the master branch on 16 November 2019.

Version 1.6.108 was merged with the master branch on 24 December 2021

This is Version 1.6.143 of the Shu elisp repository.

What this document lacks lacks are detailed scenarios and work flows.  The
reader might well say that this is an interesting collection of parts, and
then go on to ask how to use it.  How does one use all of these things in a
coherent manner?

I hope to address that in the near future.

One thing I will mention is that the function \emph{shu-capture-all-latex} created
the entire LaTex users manual (shu-manual.tex) and the function
\emph{shu-capture-all-md} created the entire markdown version of the users manual
(shu-manual.md).


\eject
\section{shu-base}


Collection of miscellaneous functions  and constants used by other
packages in this repository.  Most of the elisp files in this repository
depend on this file.


\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-to-alist }}
\usebox{\funcname}\emph{added-item} \emph{new-item} \emph{alist}
\index{shu-add-to-alist} \hfill [Macro]
\hspace*{\wd\funcname}\emph{testfn}

\begin{doc-string}
Add an item to an alist.  The car of \emph{new-item} is a key to be added to the
alist \emph{alist}.  If the key does not already exist in \emph{alist}, \emph{new-item} is added to
\emph{alist}.  \emph{added-item} is either the item that was added or the item that was
previously there.  If (eq \emph{added-item} NEW-ITEM), then \emph{new-item} was added to the
list.  If (not (eq \emph{added-item} NEW-ITEM)), then the key already existed in the
list and \emph{added-item} is the item that was already on the list with a matching
key.  equal is the function used to determine equality unless \emph{testfn} is
supplied, in which case \emph{testfn} is used.

This version of this macro is for emacs 26.1 and later.  emacs 26.1 was released
on May 28, 2018.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-to-alist }}
\usebox{\funcname}\emph{added-item} \emph{new-item} \emph{alist}
\index{shu-add-to-alist} \hfill [Macro]

\begin{doc-string}
Add an item to an alist.  The car of \emph{new-item} is a key to be added to
the alist \emph{alist}.  If the key does not already exist in \emph{alist}, \emph{new-item} is added
to \emph{alist}.  \emph{added-item} is either the item that was added or the item that was
previously there.  If (eq \emph{added-item} NEW-ITEM), then \emph{new-item} was added to the
list.  If (not (eq \emph{added-item} NEW-ITEM)), then the key already existed in the
list and \emph{added-item} is the item that was already on the list with a matching
key.  equal is the function used to determine equality.

This version of this macro is for versions of emacs older than 26.1, which was
released on May 28, 2018
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-to-alist-list }}
\usebox{\funcname}\emph{key} \emph{value} \emph{alist}
\index{shu-add-to-alist-list} \hfill [Function]

\begin{doc-string}
\emph{alist} is an alist in which each element has a car that is the key and a cdr
that is a list of values associated with that key.  If the given \emph{key} does not
already exist in \emph{alist}, it is added to \emph{alist} with a list of length one
containing \emph{value}.  If the \emph{key} exists in \emph{alist}, \emph{value} is pushed onto the list of
values associated with \emph{key}.  The return value is the modified \emph{alist}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-all-commits }}
\usebox{\funcname}
\index{shu-all-commits} \hfill [Constant]

\begin{doc-string}
A list of all commits by version starting with version 1.2
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-all-whitespace-chars }}
\usebox{\funcname}
\index{shu-all-whitespace-chars} \hfill [Constant]

\begin{doc-string}
List of all whitespace characters.
Since the syntax table considers newline to be (among other things) a
comment terminator, the usual \\s- won't work for whitespace that includes
newlines.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-all-whitespace-regexp }}
\usebox{\funcname}
\index{shu-all-whitespace-regexp} \hfill [Constant]

\begin{doc-string}
Regular expression to search for whitespace.  Since the syntax table considers
newline to be (among other things) a comment terminator, the usual \\s- won't work
for whitespace that includes newlines.  Note that this regular expression is a
character alternative enclosed in left and right brackets.  skip-chars-forward does
not expect character alternatives to be enclosed in square brackets and will include
the left and right brackets in the class of characters to be skipped.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-all-whitespace-regexp-scf }}
\usebox{\funcname}
\index{shu-all-whitespace-regexp-scf} \hfill [Constant]

\begin{doc-string}
This is the regular expression contained in shu-all-whitespace-regexp but with
the enclosing left and right square brackets removed.  skip-chars-forward does
not expect character alternatives to be enclosed in square brackets and thus
will include the brackets as characters to be skipped.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-append-to-file }}
\usebox{\funcname}\emph{file} \emph{line}
\index{shu-append-to-file} \hfill [Function]

\begin{doc-string}
Append \emph{line} to \emph{file}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bool-to-string }}
\usebox{\funcname}\emph{arg}
\index{shu-bool-to-string} \hfill [Function]

\begin{doc-string}
Convert a boolean value to its string representation and return the string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-comment-start-pattern }}
\usebox{\funcname}
\index{shu-comment-start-pattern} \hfill [Constant]

\begin{doc-string}
The regular expression that defines the delimiter used to start
a comment.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-conditional-load-library-files }}
\usebox{\funcname}\emph{path-to-libs}
\index{shu-conditional-load-library-files} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Conditionally Load all of the library files listed in in the list \emph{libs} using
the path \emph{path-to-libs}.  A file in the list is loaded only if FILE-READABLE-P
returns true for that file.  Return true if all readable files were loaded.
Return false if any readable file failed to load.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-author }}
\usebox{\funcname}
\index{shu-cpp-author} \hfill [Custom]

\begin{doc-string}
The string to place in the doxygen author tag.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-comment-end }}
\usebox{\funcname}
\index{shu-cpp-comment-end} \hfill [Custom]

\begin{doc-string}
Standard end point (right hand margin) for C style comments.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-comment-start }}
\usebox{\funcname}
\index{shu-cpp-comment-start} \hfill [Custom]

\begin{doc-string}
Column in which a standard comment starts.  Any comment that starts to the left of
this point is assumed to be a block comment.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-default-allocator-name }}
\usebox{\funcname}
\index{shu-cpp-default-allocator-name} \hfill [Custom]

\begin{doc-string}
The name of the class member variable that holds the pointer to the allocator
used by the class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-default-allocator-type }}
\usebox{\funcname}
\index{shu-cpp-default-allocator-type} \hfill [Custom]

\begin{doc-string}
The class name of the standard abstract allocator.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-default-global-namespace }}
\usebox{\funcname}
\index{shu-cpp-default-global-namespace} \hfill [Custom]

\begin{doc-string}
The string that defines the default global C++ namepace, if any.
If this has a value, then C++ classes are declared with a two level
namespace with the global namespace encompassing the local one
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-default-member }}
\usebox{\funcname}
\index{shu-cpp-default-member} \hfill [Custom]

\begin{doc-string}
The prefix used to indicate that a variable in a class is a member variable of
that class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-default-namespace }}
\usebox{\funcname}
\index{shu-cpp-default-namespace} \hfill [Custom]

\begin{doc-string}
The string that defines the default C++ namepace, if any.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-edit-sentinel }}
\usebox{\funcname}
\index{shu-cpp-edit-sentinel} \hfill [Custom]

\begin{doc-string}
The sentinel that appears in a comment in the beginning of a file to indicate
to a text editor that this file contains C++ code.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-file-directory-name }}
\usebox{\funcname}
\index{shu-cpp-file-directory-name} \hfill [Constant]

\begin{doc-string}
A regular expression to match the name of a C or C++ file in the file system
including directory names.  This is the same regular expression as
\emph{shu-cpp-file-name-list} with a ``/'' included.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-file-name }}
\usebox{\funcname}
\index{shu-cpp-file-name} \hfill [Constant]

\begin{doc-string}
A regular expression to match the name of a C or C++ file in the file system.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-file-name-list }}
\usebox{\funcname}
\index{shu-cpp-file-name-list} \hfill [Constant]

\begin{doc-string}
List of all characters that can be present in a C++ file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-include-user-brackets }}
\usebox{\funcname}
\index{shu-cpp-include-user-brackets} \hfill [Custom]

\begin{doc-string}
Set non-nil if user written include files are to be delimited by
angle brackets instead of quotes.
In many C and C++ environments, system include files such as stdio.h are delimited
by angle brackets, for example:

\small{\begin{verbatim}
      #include <stdio.h>
\end{verbatim}}

while user written include files are delimited by quotes, for example:

\small{\begin{verbatim}
      #include ``myclass.h''
\end{verbatim}}

If this variable is non-nil, then user written include files are delimited
by angle brackets and an include of ``myclass.h'' would be written as

\small{\begin{verbatim}
      #include <myclass.h>
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-indent-length }}
\usebox{\funcname}
\index{shu-cpp-indent-length} \hfill [Custom]

\begin{doc-string}
Size of the standard indent for names within class declarations, etc.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-keyword }}
\usebox{\funcname}
\index{shu-cpp-keyword} \hfill [Constant]

\begin{doc-string}
A regular expression to match a key word in a C++ program.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-keyword-list }}
\usebox{\funcname}
\index{shu-cpp-keyword-list} \hfill [Constant]

\begin{doc-string}
List of all characters that can be present in a C++ key word.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-line-end }}
\usebox{\funcname}
\index{shu-cpp-line-end} \hfill [Custom]

\begin{doc-string}
Standard end point (right hand margin) for a line of code.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-modern }}
\usebox{\funcname}
\index{shu-cpp-modern} \hfill [Custom]

\begin{doc-string}
Set to true if using the features of C++ 11/14 such as auto and explicitly
deleted copy / move constructors.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-name }}
\usebox{\funcname}
\index{shu-cpp-name} \hfill [Constant]

\begin{doc-string}
A regular expression to match a variable name in a C or C++ program.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-name-list }}
\usebox{\funcname}
\index{shu-cpp-name-list} \hfill [Constant]

\begin{doc-string}
List of all characters that can be present in a C++ variable name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-std-namespace }}
\usebox{\funcname}
\index{shu-cpp-std-namespace} \hfill [Custom]

\begin{doc-string}
The name of the namespace for the C++ standard library.  Some users of the
BDE open source Bloomberg libraries may prefer ``bsl'' instead.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-use-bde-library }}
\usebox{\funcname}
\index{shu-cpp-use-bde-library} \hfill [Custom]

\begin{doc-string}
Set non-nil if the BDE library is to be used for generated C++ code.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-current-line }}
\usebox{\funcname}
\index{shu-current-line} \hfill [Function]

\begin{doc-string}
Return the line number of the current line relative to the start of the buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-current-year }}
\usebox{\funcname}
\index{shu-current-year} \hfill [Function]

\begin{doc-string}
Return an integer that represents the four digit current year.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-date }}
\usebox{\funcname}
\index{shu-date} \hfill [Constant]

\begin{doc-string}
Date of the most recent merge with the master branch.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-delete-last-char-if }}
\usebox{\funcname}\emph{input} \emph{test-char}
\index{shu-delete-last-char-if} \hfill [Function]

\begin{doc-string}
Return the string \emph{input} with the last character removed if the last character
is equal to the string \emph{test-char}.  If the last character is not equal to the
string \emph{test-char}, return the input string unmodified.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-downcase-first-letter }}
\usebox{\funcname}\emph{string}
\index{shu-downcase-first-letter} \hfill [Function]

\begin{doc-string}
Return the given string with the first character of the string converted
to lower case
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-end-of-dq-string }}
\usebox{\funcname}
\index{shu-end-of-dq-string} \hfill [Function]

\begin{doc-string}
Return the point that represents the end of the current quoted string in the
buffer.  The quote character is the double quote character (``).  Escaped quotes
are skipped.  If the current string is not terminated by a double quote
character, nil is returned.  If the current string is terminated by a double
quote character, the position following the quote is returned and point is set
to that position.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-end-of-string }}
\usebox{\funcname}\emph{string-term}
\index{shu-end-of-string} \hfill [Function]

\begin{doc-string}
Return the point that terminates the current quoted string in the buffer.
The single argument \emph{string-term} is a string containing the character that
started the string (single or double quote).  Return nil if the current
string is not terminated in the buffer.

This function actually returns the position after the terminating quote and
also moves point to that position.  This cannot be changed because other
functions depend on this frankly strange behavior.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-fixed-format-num }}
\usebox{\funcname}\emph{num} \emph{width}
\index{shu-fixed-format-num} \hfill [Function]

\begin{doc-string}
Return a printable representation of \emph{num} in a string right justified
and pad filled to length \emph{width}.  The number is formatted as comma separated
as defined by shu-group-number.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-format-num }}
\usebox{\funcname}\emph{num} \emph{width} \textbf{\&optional} \emph{pad-char}
\index{shu-format-num} \hfill [Function]

\begin{doc-string}
Return a printable representation of \emph{num} in a string right justified and pad
filled to length \emph{width}.  The number is padded with blanks unless an optional
\emph{pad-char} is supplied, which is then used instead of blanks.

\emph{pad-char} must be a character, not a string.  If you want the string
representation of the number to be right justified and zero filled, specify a
pad character of ?0.  Do not use a pad character of ``0''
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-directory-prefix }}
\usebox{\funcname}
\index{shu-get-directory-prefix} \hfill [Function]

\begin{doc-string}
Get a directory based prefix, which is the last name in the current path.  If the current
directory is ``foo/blah/humbug'', the value returned from this function is ``humbug''
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-global-buffer-name }}
\usebox{\funcname}
\index{shu-global-buffer-name} \hfill [Constant]

\begin{doc-string}
The name of the buffer into which shu-global-operation places its output.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-goto-line }}
\usebox{\funcname}\emph{line-number}
\index{shu-goto-line} \hfill [Function]

\begin{doc-string}
Move point to line \emph{line-number}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-group-number }}
\usebox{\funcname}\emph{num} \textbf{\&optional} \emph{size} \emph{char}
\index{shu-group-number} \hfill [Function]

\begin{doc-string}
Format \emph{num} as string grouped to \emph{size} with \emph{char}.  Default \emph{size} if 3.  Default \emph{char}
is ','.  e.g., 1234567 is formatted as 1,234,567.  Argument to be formatted may be
either a string or a number.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-dev-url }}
\usebox{\funcname}
\index{shu-internal-dev-url} \hfill [Custom]

\begin{doc-string}
A string that identifies the internal development URL of an organization
(if any).
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-group-name }}
\usebox{\funcname}
\index{shu-internal-group-name} \hfill [Custom]

\begin{doc-string}
A string that identifies the group name of which an individual is a member
(if any).
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-invert-alist-list }}
\usebox{\funcname}\emph{alist} \textbf{\&optional} \emph{compare-fn}
\index{shu-invert-alist-list} \hfill [Function]

\begin{doc-string}
\emph{alist} is an alist in which the car of each item is the key and the cdr of
each item is a list of things associated with the key.  This function inverts
the alist.  The car of each item in the new list is a member of one of the value
lists in \emph{alist}.  The cdr of each item in the new list is a list of all of those
keys that map to the value that is now the key in the new list.

If \emph{compare-fn} is non-nil, then the lists in the car of each item in the new list
are sorted using \emph{compare-fn}.

As an example, the following input:

\small{\begin{verbatim}
     A -> (X Y Z)
     B -> (Q X Z)
     C -> (P X)
\end{verbatim}}

results in the following output being returned:

\small{\begin{verbatim}
     P -> (C)
     Q -> (B)
     X -> (A B C)
     Y -> (A)
     Z -> (A B)
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-invert-alist-to-hash }}
\usebox{\funcname}\emph{alist}
\index{shu-invert-alist-to-hash} \hfill [Function]

\begin{doc-string}
\emph{alist} is an alist in which the cdr of each item in the list and the car of
each item is an associated list of values.  The function constructs two items to
return.

The first is a hash table that is an inversion of the alist.  If the input \emph{alist}
contains:

\small{\begin{verbatim}
       A ->(G W)
       B ->(X Y)
\end{verbatim}}

then the returned hash table would be:

\small{\begin{verbatim}
       G->A
       M->A
       X->B
       Y->B
\end{verbatim}}

But if the values contain duplicates, it is impossible to construct the complete
hash table.  If \emph{alist} contains

\small{\begin{verbatim}
       A ->(X G W)
       B ->(X Y)
\end{verbatim}}

then the returned hash table would have to contain

\small{\begin{verbatim}
       G->A
       M->A
       X->A
       X->B
       Y->B
\end{verbatim}}

but you cannot have duplicate keys in a hash table.  In this latter case, this
function constructs an alist that contains the duplicated keys.  The key of the
alist is the value of what would be a duplicate key in the hash table.  The
value of the alist is a list of all of the values to which the key maps.

In the case illustrated above, the returned hash table would contain

\small{\begin{verbatim}
       G->A
       M->A
       X->A
       Y->B
\end{verbatim}}

and the returned alist would be

\small{\begin{verbatim}
      X->(A B)
\end{verbatim}}

The return value of this function is a cons cell whose car is the hash table and
whose cdr is the alist.  If the cdr of the return value is nil, then the entire
hash table could not be constructed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-kill-new }}
\usebox{\funcname}\emph{string}
\index{shu-kill-new} \hfill [Function]

\begin{doc-string}
Effectively do a kill-new with \emph{string} but use kill-ring-save from
a temporary buffer.  This seems to to a better job of putting \emph{string}
in a place from which other programs running on Linux and Windows can
do a paste.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-last-commit }}
\usebox{\funcname}
\index{shu-last-commit} \hfill [Constant]

\begin{doc-string}
The git SHA-1 of the most recent commit.  This cannot be the SHA-1 hash of
the last commit because that is not known until after the commit happens.  Just
before the merge with master, a commit is done.  Its SHA-1 hash is copied into
this constant.  Then one more commit is done to push this change out.  If you
want to find this version in git, look for the commit after the one defined
here.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-library-files }}
\usebox{\funcname}
\index{shu-library-files} \hfill [Constant]

\begin{doc-string}
A list of all of the library files that comprise the Shu elisp package in the
order in which they should be loaded.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-line-and-column-at }}
\usebox{\funcname}\emph{arg}
\index{shu-line-and-column-at} \hfill [Function]

\begin{doc-string}
Return the line number and column number of the point passed in as an argument.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-line-number-at-pos }}
\usebox{\funcname}\textbf{\&optional} \emph{pos} \emph{absolute}
\index{shu-line-number-at-pos} \hfill [Function]

\begin{doc-string}
line-number-at-pos in simple.el takes two arguments as of emacs 26.  This
allows the two argument version to run on older versions of emacs.  If
\emph{absolute} is specified, widen the buffer, then call the one argument version
of line-number-at-pos, which is supported in emacs 24 and 25, and perhaps
others.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-load-library-files }}
\usebox{\funcname}\emph{path-to-libs}
\index{shu-load-library-files} \hfill [Function]

\begin{doc-string}
Load all of the library files listed in \emph{shu-library-files} using the path
\emph{path-to-libs}.  Return true if all of the files were successfully loaded.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-longest-car-length }}
\usebox{\funcname}\emph{cons-cells}
\index{shu-longest-car-length} \hfill [Function]

\begin{doc-string}
\emph{cons-cells} is a list of cons cells.  The CAR of each cons cell is a string.
Return the length of the longest string in all of the CARs of the cons cells.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-longest-name-length }}
\usebox{\funcname}\emph{names}
\index{shu-longest-name-length} \hfill [Function]

\begin{doc-string}
Given a list of \emph{names}, return the length of the longest name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-file-header-line }}
\usebox{\funcname}\emph{file-name}
\index{shu-make-file-header-line} \hfill [Function]

\begin{doc-string}
Return a string that holds the standard first line comment in a C++ file,
which is of the form:

\small{\begin{verbatim}
      ``// file_name                                      -\emph{*-C++-*-}''
\end{verbatim}}

The returned line is of length \emph{shu-cpp-comment-end}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-minimum-leading-space }}
\usebox{\funcname}\emph{arg} \textbf{\&optional}
\index{shu-minimum-leading-space} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Find the amount of white space in front of point on the same line and return
either that count or \emph{arg}, whichever is smaller.  Used by functions that wish to
safely delete \emph{arg} characters of white space from the current position without
deleting any characters that are not white space.  An optional second argument,
\emph{white-space}, is a string that defines what is meant by white space.  The default
definition is \emph{shu-all-whitespace-regexp}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-non-cpp-name }}
\usebox{\funcname}
\index{shu-non-cpp-name} \hfill [Constant]

\begin{doc-string}
A regular expression to match a character not valid in a variable name
in a C or C++ program.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-not-all-whitespace-regexp }}
\usebox{\funcname}
\index{shu-not-all-whitespace-regexp} \hfill [Constant]

\begin{doc-string}
Regular expression to search for non-whitespace.  Since the syntax table considers
newline to be (among other things) a comment terminator, the usual \\s- won't work
for whitespace that includes newlines.  Note that this regular expression is a
character alternative enclosed in left and right brackets.  skip-chars-forward does
not expect character alternatives to be enclosed in square brackets and will include
the left and right brackets in the class of characters to be skipped.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-point-at-sexp }}
\usebox{\funcname}\emph{sos}
\index{shu-point-at-sexp} \hfill [Function]

\begin{doc-string}
Return the point of the sexp that matches the point at \emph{sos}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-point-in-string }}
\usebox{\funcname}\textbf{\&optional} \emph{pos}
\index{shu-point-in-string} \hfill [Function]

\begin{doc-string}
Return the start position of the string text if point is sitting between a pair
of non-escaped quotes (double quotes).  The left-hand quote (opening quote) must be
on the same line as point.  The string must be on a single line.  If point is sitting
on a quote, then it is not inside a string.  In order to be inside a string, point
must lie between two non-escaped quotes.  The optional argument \emph{pos}, if specified,
is used in place of the position of point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-random-letter }}
\usebox{\funcname}
\index{shu-random-letter} \hfill [Function]

\begin{doc-string}
Return a randomly selected lower case letter as a single character (not as
a string).
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-random-range }}
\usebox{\funcname}\emph{x} \emph{y}
\index{shu-random-range} \hfill [Function]

\begin{doc-string}
Return a random number that lies within the closed interval [\emph{x}, Y].  If \emph{y} $<$ \emph{x}, then the
closed interval is [\emph{y}, X].  If \emph{y} is equal to \emph{x}, then the returned value is \emph{x}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-remove-trailing-all-whitespace }}
\usebox{\funcname}\emph{input-string}
\index{shu-remove-trailing-all-whitespace} \hfill [Function]

\begin{doc-string}
Return a copy of \emph{input-string} with all trailing whitespace removed.  All control
characters are considered whitespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-replace-string }}
\usebox{\funcname}\emph{original} \emph{replacement} \textbf{\&optional}
\index{shu-replace-string} \hfill [Function]
\hspace*{\wd\funcname}\emph{literal}

\begin{doc-string}
Go to the top of the current buffer and use SEARCH-FORWARD to find all
instances of \emph{original}, replacing each instance with \emph{replacement}.  The optional
arguments \emph{fixedcase} and \emph{literal} are passed through to the REPLACE-MATCH
function.  Return the count of the number of instances that were replaced,
if any.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-split-new-lines }}
\usebox{\funcname}\emph{data} \textbf{\&optional} \emph{separator}
\index{shu-split-new-lines} \hfill [Function]

\begin{doc-string}
Split a string into a list of strings.  If the optional \emph{separator} is present,
it is used as a regular expression that represents the line separator and it is
not retained in each split line.  If \emph{separator} is not present, the separator is
the newline character.  The separator expressions are removed from the
input string and a list of separated strings is returned.

If the input line is an empty string, a list containing one empty string is
returned.  If the line contains a trailing new line character, that trailing new
line character is discarded without generating a new, empty line in the output.

In the following examples \emph{separator} has been set to a comma.

For example, the input string ``Hello,There,'' will return exactly the same
output list as the input string ``Hello,There''.

As another example, the input string ``Hi,How are you?,'' returns a list of
two strings, which are ``Hi'' and ``How are you?''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-starts-with }}
\usebox{\funcname}\emph{regexp}
\index{shu-starts-with} \hfill [Function]

\begin{doc-string}
If the first non-whitespace on the current line matches \emph{regexp}, return the position
of the beginning of the matched \emph{regexp}.  If the first non-whitespace does not match
\emph{regexp}, return nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-string-starts-ends }}
\usebox{\funcname}\emph{string} \emph{start-string}
\index{shu-string-starts-ends} \hfill [Command]
\hspace*{\wd\funcname}\emph{end-string}

\begin{doc-string}
Return true if the given \emph{string} starts with \emph{start-string} and ends with
\emph{end-string}.  If \emph{end-string} is omitted, \emph{start-string} is used instead.
An empty \emph{start-string} matches anything.  An empty \emph{end-string} matches anything.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-swap }}
\usebox{\funcname}\emph{x} \emph{y}
\index{shu-swap} \hfill [Macro]

\begin{doc-string}
Swap the contents of \emph{x} and \emph{y}.  \emph{x} gets the value of \emph{y}.  \emph{y} gets the value of \emph{x}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-the-column-at }}
\usebox{\funcname}\emph{arg}
\index{shu-the-column-at} \hfill [Function]

\begin{doc-string}
Return the column number of the point passed in as an argument.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-the-line-at }}
\usebox{\funcname}\emph{arg}
\index{shu-the-line-at} \hfill [Function]

\begin{doc-string}
Return the line number of the point passed in as an argument.  The line number is
relative to the start of the buffer, whether or not narrowing is in effect.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-trace-buffer }}
\usebox{\funcname}
\index{shu-trace-buffer} \hfill [Constant]

\begin{doc-string}
The name of the buffer into which some functions write debug trace
information.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-trim }}
\usebox{\funcname}\emph{string}
\index{shu-trim} \hfill [Function]

\begin{doc-string}
Trim leading and trailing whitespace from \emph{string}.  Return the modified
string.  String remains unmodified if it had no leading or trailing whitespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-trim-file }}
\usebox{\funcname}
\index{shu-trim-file} \hfill [Custom]

\begin{doc-string}
If true, whitespace is trimmed from the end of lines and blank lines at the
end of a file are deleted when a file is saved.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-trim-file-hook }}
\usebox{\funcname}
\index{shu-trim-file-hook} \hfill [Function]

\begin{doc-string}
Run as a before-save-hook to trim trailing whitespace from the end of lines and
to trim blank lines from the end of a file if \emph{shu-trim-file} is true.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-trim-leading }}
\usebox{\funcname}\emph{string}
\index{shu-trim-leading} \hfill [Function]

\begin{doc-string}
Trim leading whitespace from \emph{string}.  Return the modified string.  String
remains unmodified if it had no leading whitespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-trim-trailing }}
\usebox{\funcname}\emph{string}
\index{shu-trim-trailing} \hfill [Function]

\begin{doc-string}
Trim trailing whitespace from \emph{string}.  Return the modified string.  String
remains unmodified if it had no trailing whitespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-unit-test-buffer }}
\usebox{\funcname}
\index{shu-unit-test-buffer} \hfill [Constant]

\begin{doc-string}
The name of the buffer into which unit tests place their output and
debug trace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-upcase-first-letter }}
\usebox{\funcname}\emph{string}
\index{shu-upcase-first-letter} \hfill [Function]

\begin{doc-string}
Return the given string with the first character of the string converted
to upper case
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-version }}
\usebox{\funcname}
\index{shu-version} \hfill [Constant]

\begin{doc-string}
The version number of the Shu elisp package.
\end{doc-string}

\eject
\section{shu-batch-mode}


A startup script and other functions for running the Shu elisp package
in batch mode.  Some of the functions in this package have been
enabled to run as stand alone shell scripts.  This allows these
functions to be used by non-emacs users and in automated build
work flows.

The function shu-batch-init loads all of the Shu elisp libraries.
Other functions in this file invoke various functions in the Shu
elisp libraries and are set up such that they can be invoked from
the --eval comment line option of emacs running in batch.


\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-batch-add-alexandria }}
\usebox{\funcname}
\index{shu-batch-add-alexandria} \hfill [Function]

\begin{doc-string}
Call the \emph{shu-add-alexandria} function in batch mode.  One required argument is
the value for the custom variable \emph{shu-internal-dev-url}.

Invoke as:

\small{\begin{verbatim}
     emacs --batch -l ~/emacs/shu-batch-mode.elc -f shu-batch-add-alexandria <dev-url>
\end{verbatim}}

where ``$<$dev-url$>$`` is the organization's internal web site that hosts its code
and tools.  See the description of the custom variable \emph{shu-internal-dev-url}.
for more information.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-batch-copy-trace }}
\usebox{\funcname}
\index{shu-batch-copy-trace} \hfill [Function]

\begin{doc-string}
Copy the contents of the \emph{shu-trace-buffer} to stdout in batch mode.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-batch-fail }}
\usebox{\funcname}
\index{shu-batch-fail} \hfill [Command]

\begin{doc-string}
A test function to terminate emacs via ERROR.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-batch-hello }}
\usebox{\funcname}
\index{shu-batch-hello} \hfill [Command]

\begin{doc-string}
A test function for batch mode.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-batch-init }}
\usebox{\funcname}
\index{shu-batch-init} \hfill [Function]

\begin{doc-string}
Load all of the .elc files from the Shu elisp package.  This is used to allow
Shu elisp functions to be used in batch mode.  This function searches for the
functions in the path specified by the environment variable
``SHU\_EMACS\_LOAD\_PATH''.  If that environment variable does not exist, then it
searches in the local ``~/emacs'' directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-batch-rmv-using }}
\usebox{\funcname}
\index{shu-batch-rmv-using} \hfill [Function]

\begin{doc-string}
Call rmv-using in batch mode.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-batch-test-args }}
\usebox{\funcname}
\index{shu-batch-test-args} \hfill [Function]

\begin{doc-string}
A script to use in batch mode to demonstrate how to fetch command line arguments.

When run from a batch script as the function that is the target of the ``-f'' option.
For example

\small{\begin{verbatim}
    emacs --batch -l shu-batch-mode.elc -f shu-batch-test-args hello world how are you
\end{verbatim}}

produces the following output:
\small{\begin{verbatim}
    There are 5 arguments
    arg: 0: ``hello''
    arg: 1: ``world''
    arg: 2: ``how''
    arg: 3: ``are''
    arg: 4: ``you''
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-comdb2-code }}
\usebox{\funcname}
\index{shu-generate-comdb2-code} \hfill [Function]

\begin{doc-string}
Generate the C++ code for a comdb2 row class
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-component }}
\usebox{\funcname}
\index{shu-generate-component} \hfill [Function]

\begin{doc-string}
Fetch the arguments from environment variables and then call
\emph{shu-internal-gen-bde-component} to generate a set of three BDE component
files.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-local-class-list }}
\usebox{\funcname}
\index{shu-local-class-list} \hfill [Constant]

\begin{doc-string}
List of standard namespaces and their associated classes
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-generate-component }}
\usebox{\funcname}
\index{shu-new-generate-component} \hfill [Function]

\begin{doc-string}
Fetch the arguments from environment variables and then call
\emph{shu-internal-gen-bde-component} to generate a set of three BDE component
files with optional template parameters.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-old-generate-component }}
\usebox{\funcname}
\index{shu-old-generate-component} \hfill [Function]

\begin{doc-string}
Fetch the arguments from environment variables and then call
\emph{shu-internal-gen-bde-component} to generate a set of three BDE component
files.
\end{doc-string}

\eject
\section{shu-bde-cpp}


A collection of useful functions for generating C++ skeleton code files
and classes for code written in Bloomberg, L.P. BDE style.


\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gen-bb-component }}
\usebox{\funcname}\emph{class-name}
\index{gen-bb-component} \hfill [Command]\\%
 (Function: shu-gen-bb-component)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bb-cpp-set-alias }}
\usebox{\funcname}
\index{shu-bb-cpp-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-bb-cpp.
These are generally the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gen-bb-component }}
\usebox{\funcname}\emph{class-name}
\index{shu-gen-bb-component} \hfill [Command]\\%
 (Alias: gen-bb-component)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-bb-cfile }}
\usebox{\funcname}\emph{author} \emph{namespace} \emph{class-name}
\index{shu-generate-bb-cfile} \hfill [Function]

\begin{doc-string}
Generate a skeleton cpp file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-bb-hfile }}
\usebox{\funcname}\emph{author} \emph{namespace} \emph{class-name}
\index{shu-generate-bb-hfile} \hfill [Function]

\begin{doc-string}
Generate a skeleton header file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-bb-tfile }}
\usebox{\funcname}\emph{author} \emph{namespace} \emph{class-name}
\index{shu-generate-bb-tfile} \hfill [Command]

\begin{doc-string}
Generate a skeleton t.cpp file
\end{doc-string}

\eject
\section{shu-bde}


A collection of useful functions for generating C++ skeleton code files
and classes for code written in Bloomberg, L.P. BDE style.


\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{bde-add-guard }}
\usebox{\funcname}
\index{bde-add-guard} \hfill [Command]\\%
 (Function: shu-bde-add-guard)

\begin{doc-string}
Add the BDE include guards around an existing \#include directive.  If the line
before the \#include directive contains a valid guard, then we do not add a guard
and position point to the line following the \#include.  This makes it possible to
run bde-all-guard on a file that contains some guarded \#includes and some unguarded
\#includes.  Only the unguarded ones will have the guard added.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{bde-all-guard }}
\usebox{\funcname}
\index{bde-all-guard} \hfill [Command]\\%
 (Function: shu-bde-all-guard)

\begin{doc-string}
Add the BDE include guards around all of the \#include directives in a file
or narrowed region.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{bde-decl }}
\usebox{\funcname}\emph{class-name}
\index{bde-decl} \hfill [Command]\\%
 (Function: shu-bde-decl)

\begin{doc-string}
Generate a skeleton BDE class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{bde-gen }}
\usebox{\funcname}\emph{class-name}
\index{bde-gen} \hfill [Command]\\%
 (Function: shu-bde-gen)

\begin{doc-string}
Generate a skeleton BDE class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{bde-include }}
\usebox{\funcname}\emph{fn}
\index{bde-include} \hfill [Command]\\%
 (Function: shu-bde-include)

\begin{doc-string}
Insert at the current line, the BDE include guard sequence of
\#ifndef INCLUDED\_GUARD
\#include $<$guard.h$>$
\#endif
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{bde-sdecl }}
\usebox{\funcname}\emph{class-name}
\index{bde-sdecl} \hfill [Command]\\%
 (Function: shu-bde-sdecl)

\begin{doc-string}
Generate a skeleton BDE struct definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{bde-sgen }}
\usebox{\funcname}\emph{class-name}
\index{bde-sgen} \hfill [Command]\\%
 (Function: shu-bde-sgen)

\begin{doc-string}
Generate a skeleton BDE struct code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gen-bde-component }}
\usebox{\funcname}\emph{class-name}
\index{gen-bde-component} \hfill [Command]\\%
 (Function: shu-gen-bde-component)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gen-bde-template }}
\usebox{\funcname}\emph{class-name} \emph{template-string}
\index{gen-bde-template} \hfill [Command]\\%
 (Function: shu-gen-bde-template)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gen-new-bde-component }}
\usebox{\funcname}\emph{class-name}
\index{gen-new-bde-component} \hfill [Command]\\%
 (Function: shu-new-gen-bde-component)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-add-guard }}
\usebox{\funcname}
\index{shu-bde-add-guard} \hfill [Command]\\%
 (Alias: bde-add-guard)

\begin{doc-string}
Add the BDE include guards around an existing \#include directive.  If the line
before the \#include directive contains a valid guard, then we do not add a guard
and position point to the line following the \#include.  This makes it possible to
run bde-all-guard on a file that contains some guarded \#includes and some unguarded
\#includes.  Only the unguarded ones will have the guard added.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-all-guard }}
\usebox{\funcname}
\index{shu-bde-all-guard} \hfill [Command]\\%
 (Alias: bde-all-guard)

\begin{doc-string}
Add the BDE include guards around all of the \#include directives in a file
or narrowed region.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-decl }}
\usebox{\funcname}\emph{class-name}
\index{shu-bde-decl} \hfill [Command]\\%
 (Alias: bde-decl)

\begin{doc-string}
Generate a skeleton BDE class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-gen }}
\usebox{\funcname}\emph{class-name}
\index{shu-bde-gen} \hfill [Command]\\%
 (Alias: bde-gen)

\begin{doc-string}
Generate a skeleton BDE class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-gen-cfile-copyright-hook }}
\usebox{\funcname}
\index{shu-bde-gen-cfile-copyright-hook} \hfill [Custom]

\begin{doc-string}
Generate the text that is the copyright notice placed in a code file,
if any.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-gen-file-identifier-hook }}
\usebox{\funcname}
\index{shu-bde-gen-file-identifier-hook} \hfill [Custom]

\begin{doc-string}
Generate the text that constitutes a source file identifier, if any.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-gen-h-includes-hook }}
\usebox{\funcname}
\index{shu-bde-gen-h-includes-hook} \hfill [Custom]

\begin{doc-string}
Generate the code for the standard includes in a header file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-gen-hfile-copyright-hook }}
\usebox{\funcname}
\index{shu-bde-gen-hfile-copyright-hook} \hfill [Custom]

\begin{doc-string}
Generate the text that is the copyright notice placed in a header file,
if any.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-gen-tfile-copyright-hook }}
\usebox{\funcname}
\index{shu-bde-gen-tfile-copyright-hook} \hfill [Custom]

\begin{doc-string}
Generate the text that is the copyright notice placed in a unit test
file, if any.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-include }}
\usebox{\funcname}\emph{fn}
\index{shu-bde-include} \hfill [Command]\\%
 (Alias: bde-include)

\begin{doc-string}
Insert at the current line, the BDE include guard sequence of
\#ifndef INCLUDED\_GUARD
\#include $<$guard.h$>$
\#endif
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-include-guard }}
\usebox{\funcname}\textbf{\&optional} \emph{fn}
\index{shu-bde-include-guard} \hfill [Function]

\begin{doc-string}
Return the name of the macro variable to be used in a BDE style include guard.
Name of the current buffer file name is used if no file name is passed in as the
only optional argument.  This is the name of the macro variable that is used in the
include guard.  If the name of the file is foo\_something.h, then this function
returns INCLUDED\_FOO\_SOMETHING.  See also shu-bde-include-guard-fn
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-include-guard-fn }}
\usebox{\funcname}\textbf{\&optional} \emph{fn}
\index{shu-bde-include-guard-fn} \hfill [Function]

\begin{doc-string}
Return the file name name of the macro variable to be used in a BDE style include
guard.  Name of the current buffer file name is used if no file name is passed in as
the only optional argument.  This is only the file name part of the include guard.
If the name of the file is foo\_something.h, then this function returns
FOO\_SOMETHING.  The full name of the macro variable would be
INCLUDED\_FOO\_SOMETHING.  See also shu-bde-include-guard
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-insert-guard }}
\usebox{\funcname}\emph{fn} \emph{at-top}
\index{shu-bde-insert-guard} \hfill [Function]

\begin{doc-string}
Insert a \#ifndef / \#endif guard around an \#include directive.  \emph{fn} is the name of
the included file.  \emph{at-top} is true if the \#include directive is located on the first
line of the file so there is no line above it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-sdecl }}
\usebox{\funcname}\emph{class-name}
\index{shu-bde-sdecl} \hfill [Command]\\%
 (Alias: bde-sdecl)

\begin{doc-string}
Generate a skeleton BDE struct definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-set-alias }}
\usebox{\funcname}
\index{shu-bde-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-bde.
These are generally the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bde-sgen }}
\usebox{\funcname}\emph{class-name}
\index{shu-bde-sgen} \hfill [Command]\\%
 (Alias: bde-sgen)

\begin{doc-string}
Generate a skeleton BDE struct code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-acgen-template }}
\usebox{\funcname}\emph{class-name} \emph{template-list}
\index{shu-cpp-acgen-template} \hfill [Command]

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-ccdecl-template }}
\usebox{\funcname}\emph{class-name} \emph{template-list}
\index{shu-cpp-ccdecl-template} \hfill [Command]

\begin{doc-string}
Generate a skeleton class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-cdecl-template }}
\usebox{\funcname}\emph{class-name} \emph{template-list}
\index{shu-cpp-cdecl-template} \hfill [Command]

\begin{doc-string}
Generate a skeleton class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-decl-cpp-stream-template }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-decl-cpp-stream-template} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Generate the code for the streaming operator (operator$<$$<$()).  \emph{class-name} is the
name of the containing C++ class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-decl-h-stream-template }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-decl-h-stream-template} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Generate the declaration for the streaming operator (operator$<$$<$()).
\emph{class-name} is the name of the containing C++ class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-gen-h-class-intro-template }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-gen-h-class-intro-template} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Generate the preamble to a class declaration in a header file.  This is all
of the code that precedes the \\ DATA comment.  Return the position at which
the class comment was placed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-hcgen-template }}
\usebox{\funcname}\emph{class-name} \emph{template-list}
\index{shu-cpp-hcgen-template} \hfill [Command]
\hspace*{\wd\funcname}

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-impl-cpp-constructor }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-impl-cpp-constructor} \hfill [Function]
\hspace*{\wd\funcname}\emph{use-allocator}

\begin{doc-string}
Insert the skeleton constructor implementation.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-impl-cpp-print-self }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-impl-cpp-print-self} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Generate the skeleton code for the printSelf() function.
\emph{class-name} is the name of the containing C++ class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-inner-cdecl-template }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-inner-cdecl-template} \hfill [Function]
\hspace*{\wd\funcname}\emph{copy-allowed}
\hspace*{\wd\funcname}

\begin{doc-string}
Generate a skeleton class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-insert-template-decl }}
\usebox{\funcname}\emph{template-list}
\index{shu-cpp-insert-template-decl} \hfill [Function]

\begin{doc-string}
If \emph{template-list} holds a list of template parameter names, insert into the
buffer the declaration

\small{\begin{verbatim}
        template<typename A, typename B>
        inline
\end{verbatim}}

If \emph{template-list}  is nil, do nothing.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-decl-template }}
\usebox{\funcname}\emph{template-list}
\index{shu-cpp-make-decl-template} \hfill [Function]

\begin{doc-string}
Create the declaration

\small{\begin{verbatim}
        template<typename A, typename B>
\end{verbatim}}

from the list of template parameter names
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-qualified-class-name }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-make-qualified-class-name} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
The input is a \emph{class-name} and \emph{template-list}.  The output is a class name
followed by the comma separated list of template parameter names.  If the
template parameter names are T and S and the class name is MumbleBar, the
returned value is MumbleBar$<$T, S$>$.  If \emph{template-list} is nil or empty,
the original class name is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-template-list }}
\usebox{\funcname}\emph{template-list}
\index{shu-cpp-make-template-list} \hfill [Function]

\begin{doc-string}
Create the declaration

\small{\begin{verbatim}
        <A, B>
\end{verbatim}}

from the list of template parameter names.
An empty string is returned if \emph{template-list} is nil or empty.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-split-template-parameter-list }}
\usebox{\funcname}\emph{tp-string}
\index{shu-cpp-split-template-parameter-list} \hfill [Function]

\begin{doc-string}
\emph{tp-string} is a comma separated list of template parameter names.  This
function splits the string into a list of names and returns that list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gen-bde-component }}
\usebox{\funcname}\emph{class-name}
\index{shu-gen-bde-component} \hfill [Command]\\%
 (Alias: gen-bde-component)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gen-bde-create-prompt }}
\usebox{\funcname}
\index{shu-gen-bde-create-prompt} \hfill [Function]

\begin{doc-string}
This function creates the prompt for the interactive special form of the
function \emph{shu-gen-bde-component}.  The prompt includes the namespace in which the
new class will be created or the string ``NO NAMESPACE'' if there is no default
namespace set.  If the name of the current directory does not match the default
namespace, the prompt also includes the directory name to remind the user that
the current directory name does not match the namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gen-bde-create-prompt-template }}
\usebox{\funcname}
\index{shu-gen-bde-create-prompt-template} \hfill [Function]

\begin{doc-string}
This function fetches the prompt string from \emph{shu-gen-bde-make-prompt-string}
issues the query, and then issues a query for the comma separated list of
template parameter names.  It returns a list with two items on it:

\small{\begin{verbatim}
    1. The name of the new component

    2. The list of template parameter names
\end{verbatim}}

If the comma separated list of template parameter names is empty, the list of
template parameter names (Item 2 above) is nil
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gen-bde-make-prompt-string }}
\usebox{\funcname}
\index{shu-gen-bde-make-prompt-string} \hfill [Function]

\begin{doc-string}
This function creates the prompt for the interactive special form of the
function \emph{shu-gen-bde-component}.  The prompt includes the namespace in which the
new class will be created or the string ``NO NAMESPACE'' if there is no default
namespace set.  If the name of the current directory does not match the default
namespace, the prompt also includes the directory name to remind the user that
the current directory name does not match the namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gen-bde-template }}
\usebox{\funcname}\emph{class-name} \emph{template-string}
\index{shu-gen-bde-template} \hfill [Command]\\%
 (Alias: gen-bde-template)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-bde-cfile }}
\usebox{\funcname}\emph{author} \emph{namespace} \emph{class-name}
\index{shu-generate-bde-cfile} \hfill [Function]

\begin{doc-string}
Generate a skeleton cpp file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-bde-cfile-template }}
\usebox{\funcname}\emph{author} \emph{namespace}
\index{shu-generate-bde-cfile-template} \hfill [Function]
\hspace*{\wd\funcname}\emph{template-list}

\begin{doc-string}
Generate a skeleton cpp file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-bde-hfile }}
\usebox{\funcname}\emph{author} \emph{namespace} \emph{class-name}
\index{shu-generate-bde-hfile} \hfill [Function]

\begin{doc-string}
Generate a skeleton header file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-bde-hfile-template }}
\usebox{\funcname}\emph{author} \emph{namespace}
\index{shu-generate-bde-hfile-template} \hfill [Function]
\hspace*{\wd\funcname}\emph{template-list}

\begin{doc-string}
Generate a skeleton header file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-bde-tfile }}
\usebox{\funcname}\emph{author} \emph{namespace} \emph{class-name}
\index{shu-generate-bde-tfile} \hfill [Command]

\begin{doc-string}
Generate a skeleton t.cpp file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-git-add }}
\usebox{\funcname}\emph{filename} \emph{gitbuf}
\index{shu-generate-git-add} \hfill [Function]

\begin{doc-string}
Do a ``git add'' of \emph{filename} and show the result of the operation in
the buffer \emph{gitbuf}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-gen-bde-component }}
\usebox{\funcname}\emph{class-name} \emph{author}
\index{shu-internal-gen-bde-component} \hfill [Function]
\hspace*{\wd\funcname}\emph{file-prefix}

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-gen-bde-template }}
\usebox{\funcname}\emph{class-name}
\index{shu-internal-gen-bde-template} \hfill [Function]
\hspace*{\wd\funcname}\emph{author} \emph{namespace}
\hspace*{\wd\funcname}

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-gen-bde-component }}
\usebox{\funcname}\emph{class-name}
\index{shu-new-gen-bde-component} \hfill [Command]\\%
 (Alias: gen-new-bde-component)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\eject
\section{shu-capture-doc}


Collection of functions used to capture function and variable definitions
along with their associated doc strings in elisp code.  It can then write
this information into a buffer in either markdown or LaTex format for
subsequent publication.

This mechanism was used to create most of the documentation for the elisp
functions in this repository.


\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-after }}
\usebox{\funcname}
\index{shu-capture-a-type-after} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the string that is placed after a verbatim
code snippet.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-arg }}
\usebox{\funcname}
\index{shu-capture-a-type-arg} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the function that converts an argument name
to markup.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-before }}
\usebox{\funcname}
\index{shu-capture-a-type-before} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the string that is placed before a verbatim
code snippet.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-buf }}
\usebox{\funcname}
\index{shu-capture-a-type-buf} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the function that converts a buffer name or
other name that begins and ends with asterisks to markup.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-close-quote }}
\usebox{\funcname}
\index{shu-capture-a-type-close-quote} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the string that is a close quote.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-doc-string }}
\usebox{\funcname}
\index{shu-capture-a-type-doc-string} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the function that converts a key word, such
as ``\&optional'' or ``\&rest'' to markup.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-enclose-doc }}
\usebox{\funcname}
\index{shu-capture-a-type-enclose-doc} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the function that converts a key word, such
as ``\&optional'' or ``\&rest'' to markup.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-func }}
\usebox{\funcname}
\index{shu-capture-a-type-func} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the function that formats a function signature'
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-hdr }}
\usebox{\funcname}
\index{shu-capture-a-type-hdr} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the function that emits section headers
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-keywd }}
\usebox{\funcname}
\index{shu-capture-a-type-keywd} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the function that converts a key word, such
as ``\&optional'' or ``\&rest'' to markup.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-a-type-open-quote }}
\usebox{\funcname}
\index{shu-capture-a-type-open-quote} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the string that is an open quote.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-alias-list }}
\usebox{\funcname}
\index{shu-capture-alias-list} \hfill [Variable]

\begin{doc-string}
The alist that holds all of the alias names.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-aliases }}
\usebox{\funcname}
\index{shu-capture-aliases} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-all-latex }}
\usebox{\funcname}
\index{shu-capture-all-latex} \hfill [Command]

\begin{doc-string}
Visit all of the files in \emph{shu-capture-file-list}, invoking \emph{shu-capture-latex} on
each file to capture its documentation and turn it into LaTex source.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-all-md }}
\usebox{\funcname}
\index{shu-capture-all-md} \hfill [Command]

\begin{doc-string}
Visit all of the files in \emph{shu-capture-file-list}, invoking \emph{shu-capture-md} on each
file to capture its documentation and turn it into markdown source.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-arg-to-latex }}
\usebox{\funcname}\emph{arg-name}
\index{shu-capture-arg-to-latex} \hfill [Function]

\begin{doc-string}
Convert a function argument in a doc-string or argument list to LaTex.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-arg-to-md }}
\usebox{\funcname}\emph{arg-name}
\index{shu-capture-arg-to-md} \hfill [Function]

\begin{doc-string}
Convert a function argument in a doc-string or argument list to markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-attr-alias }}
\usebox{\funcname}
\index{shu-capture-attr-alias} \hfill [Constant]

\begin{doc-string}
Bit that indicates that a function is identified by its alias name
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-attr-const }}
\usebox{\funcname}
\index{shu-capture-attr-const} \hfill [Constant]

\begin{doc-string}
Bit that indicates that a definition is a defconst
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-attr-custom }}
\usebox{\funcname}
\index{shu-capture-attr-custom} \hfill [Variable]

\begin{doc-string}
Bit that indicates that a definition is a defcustom
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-attr-inter }}
\usebox{\funcname}
\index{shu-capture-attr-inter} \hfill [Constant]

\begin{doc-string}
Bit that indicates that a function is interactive
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-attr-macro }}
\usebox{\funcname}
\index{shu-capture-attr-macro} \hfill [Constant]

\begin{doc-string}
Bit that indicates that a function is a macro
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-attr-var }}
\usebox{\funcname}
\index{shu-capture-attr-var} \hfill [Variable]

\begin{doc-string}
Bit that indicates that a definition is a defvar
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-buf-to-latex }}
\usebox{\funcname}\emph{buf-name}
\index{shu-capture-buf-to-latex} \hfill [Function]

\begin{doc-string}
Convert a buffer name or other name that starts and ends with asterisks
 in a doc-string to markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-buf-to-md }}
\usebox{\funcname}\emph{buf-name}
\index{shu-capture-buf-to-md} \hfill [Function]

\begin{doc-string}
Convert a buffer name or other name that starts and ends with asterisks
 in a doc-string to markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-buffer-name }}
\usebox{\funcname}
\index{shu-capture-buffer-name} \hfill [Constant]

\begin{doc-string}
Name of the buffer into which the converted documentation is written
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-code-in-doc }}
\usebox{\funcname}\emph{before-code} \emph{after-code}
\index{shu-capture-code-in-doc} \hfill [Function]
\hspace*{\wd\funcname}\emph{section-converter}

\begin{doc-string}
The current buffer is assumed to hold a doc string that is being converted to
either markdown or LaTex.  We divide the text into two categories.  The first
category is plain text that should be scanned for characters to escape, such as
pound signs if we are converting to LaTex.  The second category is text that
should not be scanned for characters to escape, either because it is to be
treated as a verbatim code snippet or because it is a pseudo markdown section
heading that will be converted either to a markdown section heading or to a LaTex
section heading.

When we come to the end of plain text (either because we have found a code
snippet or because we have found a pseudo markdown section heading), we call the
\emph{text-converter} function on the bounds of the plain text whose end we have just
found.

A pseudo markdown section heading is identified as follows.  It must start in
column 1.  It must start with two to four pound signs.  It must have some text.
It must end at the end of the line with the same number of pound signs with which
it started.

A code snippet to be shown in verbatim mode is any one whose first column occurs
on or after \emph{shu-capture-doc-code-indent}.

When the \emph{text-converter} function is called.  It may expand the size of the text
area if it adds characters to the text.  It is the responsibility of the
\emph{text-converter} function to return the new text end point to this function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-code-in-md }}
\usebox{\funcname}
\index{shu-capture-code-in-md} \hfill [Function]

\begin{doc-string}
The current buffer is assumed to hold a doc string that is being converted to
markdown.  Any line that is indented to column \emph{shu-capture-doc-code-indent} or
greater is assumed to be a code snippet and will be surrounded by `````'' to make
it a code snippet in markdown.  Return the number of code snippets marked.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-commentary }}
\usebox{\funcname}
\index{shu-capture-commentary} \hfill [Function]

\begin{doc-string}
Search through an elisp file for a package name and a commentary section.
Return a cons cell whose car is the package name and whose cdr is the prose
found in the commentary section.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-convert-args-to-markup }}
\usebox{\funcname}\emph{signature}
\index{shu-capture-convert-args-to-markup} \hfill [Function]
\hspace*{\wd\funcname}\emph{keywd-converter}

\begin{doc-string}
\emph{signature} contains the function signature (both function name and arguments).
\emph{arg-converter} is the function used to convert an argument to markup.  \emph{keywd-converter}
is the function used to convert an argument list keyword, such as ``\&optional'' or ``\&rest''
to markup.

This function returns a cons cell pointing to two lists.  The first list contains the length
of each argument name prior to conversion to markup.  This is because the amount of space
on a line is largely determined by the length of the unconverted argument.  ``arg'' will
take much less space on a line than will the same word with markup added.  The second list
contains each of the argument names converted to the appropriate markup.

Given the following function signature:

\small{\begin{verbatim}
     do-something (with these things \&optional and \&rest others)
\end{verbatim}}

the length list will contain (4, 5, 6, 9, 3, 5, 6).  The converted arguments list for
markdown will contain (``\emph\{*with*\}'', ``\emph\{*these*\}'', ``\emph\{*things*\}'', ``\emph\{**\}\&optional\emph\{**\}'', ``\emph\{*and*\}'',
``\emph\{**\}\&rest\emph\{**\}'', ``\emph\{*others*\}'').

If the function signature contains no arguments, then nil is returned instead of the
above described cons cell.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-convert-doc-string }}
\usebox{\funcname}\emph{signature}
\index{shu-capture-convert-doc-string} \hfill [Function]
\hspace*{\wd\funcname}\emph{converters}

\begin{doc-string}
\emph{description} contains a doc string from a function definition (with leading
and trailing quotes removed).  \emph{converters} is an a-list of functions and strings as
follows:

\small{\begin{verbatim}
      Key                              Value
      ---                              -----
      shu-capture-a-type-hdr           Function to format a section header
      shu-capture-a-type-func          Function to format a function signature
      shu-capture-a-type-buf           Function to format a buffer name
      shu-capture-a-type-arg           Function to format an argument name
      shu-capture-a-type-keywd         Function to format a key word
      shu-capture-a-type-doc-string    Function to finish formatting the doc string
      shu-capture-a-type-enclose-doc   Function to enclose doc string in begin / end
      shu-capture-a-type-before        String that starts a block of verbatim code
      shu-capture-a-type-after         String that ends a block of verbatim code
      shu-capture-a-type-open-quote    String that is an open quote
      shu-capture-a-type-close-quote   String that is a close quote
\end{verbatim}}

This function turns escaped quotes into open and close quote strings, turns names
with leading and trailing asterisks (e.g., \emph\{**project-buffer**\}) into formatted buffer
names, turns upper case names that match any argument names into lower case,
formatted argument names.  This is an internal function of shu-capture-doc and
will likely crash if called with an invalid a-list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-convert-func-latex }}
\usebox{\funcname}\emph{func-def} \emph{converters}
\index{shu-capture-convert-func-latex} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Take a function definition and turn it into a string of LaTex.  Return said string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-convert-func-md }}
\usebox{\funcname}\emph{func-def} \emph{converters}
\index{shu-capture-convert-func-md} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Take a function definition and turn it into a string of markdown.  Return said string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-convert-quotes }}
\usebox{\funcname}\emph{open-quote} \emph{close-quote}
\index{shu-capture-convert-quotes} \hfill [Function]

\begin{doc-string}
Go through the current buffer converting any escaped quote to either an open or
close quote.  If an escaped quote is preceded by whitespace, ``(``, ``\{'', ``$<$``, or ``$>$``,
or by a close quote, then we replace it with an open quote.  Otherwise we replace it
with a close quote.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-doc }}
\usebox{\funcname}\emph{converters}
\index{shu-capture-doc} \hfill [Function]

\begin{doc-string}
Top level function that captures all definitions and doc strings in a language
neutral manner and then uses the supplied \emph{converters} to convert the documentation to
either markdown or LaTex.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-doc-code-indent }}
\usebox{\funcname}
\index{shu-capture-doc-code-indent} \hfill [Constant]

\begin{doc-string}
Any line indented by this much in a doc string is assumed to be a sample
code snippet.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-doc-convert-args }}
\usebox{\funcname}\emph{signature} \emph{converters}
\index{shu-capture-doc-convert-args} \hfill [Function]

\begin{doc-string}
The current buffer contains a doc string from a function.  The argument to this
function is the \emph{signature} of the function for which the doc string was written.
This function goes through the doc string buffer looking for any word that is all
upper case.  If the upper case word matches the name of an argument to the function,
it is passed to the CONVERTER function for conversion into a markup language, which
is probably markdown or LaTex, and it is then replaced in the doc string buffer.

For example, if the function has the following signature:

\small{\begin{verbatim}
     do-something (hat cat)
\end{verbatim}}

with the following doc string:

  ``The Linux HAT is converted to an IBM CAT.''

would be converted to:

  ``The Linux \emph\{*hat*\} is converted to an IBM \emph\{*cat*.\}''
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-doc-convert-args-to-latex }}
\usebox{\funcname}\emph{signature}
\index{shu-capture-doc-convert-args-to-latex} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-doc-convert-args-to-md }}
\usebox{\funcname}\emph{signature}
\index{shu-capture-doc-convert-args-to-md} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-enclose-doc-latex }}
\usebox{\funcname}
\index{shu-capture-enclose-doc-latex} \hfill [Function]

\begin{doc-string}
Enclose the doc-string with the appropriate begin / end pair for LaTex.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-enclose-doc-md }}
\usebox{\funcname}
\index{shu-capture-enclose-doc-md} \hfill [Function]

\begin{doc-string}
Enclose the doc-string with the appropriate begin / end pair for markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-file-list }}
\usebox{\funcname}
\index{shu-capture-file-list} \hfill [Constant]

\begin{doc-string}
This is a list of all of the files in this repository from which documentation
should be extracted.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-finish-doc-string-latex }}
\usebox{\funcname}
\index{shu-capture-finish-doc-string-latex} \hfill [Command]

\begin{doc-string}
Function that executes last step in the conversion of a doc-string to
markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-finish-doc-string-md }}
\usebox{\funcname}
\index{shu-capture-finish-doc-string-md} \hfill [Function]

\begin{doc-string}
Function that executes last step in the conversion of a doc-string to
markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-func-type-name }}
\usebox{\funcname}\emph{attributes}
\index{shu-capture-func-type-name} \hfill [Command]

\begin{doc-string}
Return the name of the type ``Alias,'' ``Macro,'' ``Constant,'' ``Variable,'' or
``Function'' based on the \emph{attributes} passed in.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-get-args-as-alist }}
\usebox{\funcname}\emph{signature}
\index{shu-capture-get-args-as-alist} \hfill [Function]

\begin{doc-string}
\emph{signature} contains the function signature (both function name and arguments).
This function returns the arguments as an a-list in which all of the argument
names are the keys.  The special argument names ``\&optional'' and ``\&rest'', if
present, are not copied into the a-list.

For example, if \emph{signature} holds the following:

\small{\begin{verbatim}
     do-something (with these things \&optional and \&rest others)
\end{verbatim}}

an a-list is returned with the keys ``others,'' ``and,'' ``things,'' ``these,'' and
``with.''
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-get-doc-string }}
\usebox{\funcname}\emph{eof}
\index{shu-capture-get-doc-string} \hfill [Command]

\begin{doc-string}
Enter with point positioned immediately after a function declaration.  Try to
fetch the associated doc string as follows:  1. Look for the first open or close
parenthesis.  2. Look for the first quote.  If the first parenthesis comes before
the first quote, then there is no doc string.  In the following function, there is
no doc string:

\small{\begin{verbatim}
     (defun foo (name)
       (interactive ``sName?: ``))
\end{verbatim}}

but if we do not notice that the first parenthesis comes before the first quote, then
we might think that there is a doc string that contains ``sName?: ``.

Return the doc string if there is one, nil otherwise.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-get-func-def }}
\usebox{\funcname}\emph{func-def} \emph{signature}
\index{shu-capture-get-func-def} \hfill [Macro]
\hspace*{\wd\funcname}\emph{description} \emph{alias}

\begin{doc-string}
Extract the information from the func-def
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-get-func-def-alias }}
\usebox{\funcname}\emph{func-def} \emph{alias}
\index{shu-capture-get-func-def-alias} \hfill [Macro]

\begin{doc-string}
Extract the function alias from the func-def
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-get-func-def-sig }}
\usebox{\funcname}\emph{func-def} \emph{signature}
\index{shu-capture-get-func-def-sig} \hfill [Macro]

\begin{doc-string}
Extract the function signature from the func-def
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-get-name-and-args }}
\usebox{\funcname}\emph{signature} \emph{func-name}
\index{shu-capture-get-name-and-args} \hfill [Macro]
\hspace*{\wd\funcname}

\begin{doc-string}
Extract the function and the string of arguments from a whole signature that
includes both the function name and the arguments.  If \emph{signature} contains:

\small{\begin{verbatim}
     ``do-something (to something)''
\end{verbatim}}

The on return \emph{func-name} will hold ``do-something'' and \emph{args} will contain the
string ``to something)''.  If there are no arguments, \emph{args} will contain a string
of length zero.  If there is no function name, \emph{func-name} will contain a string
of length zero
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-headers-in-doc }}
\usebox{\funcname}\emph{section-converter}
\index{shu-capture-headers-in-doc} \hfill [Function]

\begin{doc-string}
Convert markdown section headers to either markdown or LaTex.
This allows the author of some Commentary at the beginning of a file to add section
headers.  If the heading level is 2 through 4 and the heading begins in column 1 and
the number of pound signs at the end is the same as the number of pound signs at
the beginning and the pound signs at the end are at the end of a line, then this is
considered to be a heading and is translated to either markdown or LaTex.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-index-buffer }}
\usebox{\funcname}
\index{shu-capture-index-buffer} \hfill [Constant]

\begin{doc-string}
Name of the buffer into which the markdown index is written
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-internal-all }}
\usebox{\funcname}\emph{file-list} \emph{capture-func}
\index{shu-capture-internal-all} \hfill [Function]

\begin{doc-string}
Visit all of the files in \emph{file-list}, invoking \emph{capture-func} on each
file to capture its documentation and turn it into either LaTex or
markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-internal-convert-doc-string }}
\usebox{\funcname}\emph{signature}
\index{shu-capture-internal-convert-doc-string} \hfill [Function]
\hspace*{\wd\funcname}\emph{converters}

\begin{doc-string}
\emph{description} contains a doc string from a function definition (with leading
and trailing quotes removed).  \emph{converters} is an a-list of functions and strings as
follows:

\small{\begin{verbatim}
      Key                              Value
      ---                              -----
      shu-capture-a-type-hdr           Function to format a section header
      shu-capture-a-type-func          Function to format a function signature
      shu-capture-a-type-buf           Function to format a buffer name
      shu-capture-a-type-arg           Function to format an argument name
      shu-capture-a-type-keywd         Function to format a key word
      shu-capture-a-type-doc-string    Function to finish formatting the doc string
      shu-capture-a-type-enclose-doc   Function to enclose doc string in begin / end
      shu-capture-a-type-before        String that starts a block of verbatim code
      shu-capture-a-type-after         String that ends a block of verbatim code
      shu-capture-a-type-open-quote    String that is an open quote
      shu-capture-a-type-close-quote   String that is a close quote
\end{verbatim}}

This function turns escaped quotes into open and close quote strings, turns names
with leading and trailing asterisks (e.g., \emph\{**project-buffer**\}) into formatted buffer
names, turns upper case names that match any argument names into lower case,
formatted argument names.  This is an internal function of shu-capture-doc and
will likely crash if called with an invalid a-list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-internal-doc }}
\usebox{\funcname}
\index{shu-capture-internal-doc} \hfill [Command]

\begin{doc-string}
Function that captures documentation for all instances of ``defun,'' ``defsubst,''
and ``defmacro.''
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-keywd-optional }}
\usebox{\funcname}
\index{shu-capture-keywd-optional} \hfill [Constant]

\begin{doc-string}
The argument list keyword for an optional argument.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-keywd-rest }}
\usebox{\funcname}
\index{shu-capture-keywd-rest} \hfill [Constant]

\begin{doc-string}
The argument list keyword for a multiple optional arguments.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-keywd-to-latex }}
\usebox{\funcname}\emph{keywd-name}
\index{shu-capture-keywd-to-latex} \hfill [Function]

\begin{doc-string}
Convert a function argument key word in a doc-string or argument list
to LaTex.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-keywd-to-md }}
\usebox{\funcname}\emph{arg-name}
\index{shu-capture-keywd-to-md} \hfill [Function]

\begin{doc-string}
Convert a function argument key word in a doc-string or argument list
to markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex }}
\usebox{\funcname}
\index{shu-capture-latex} \hfill [Command]

\begin{doc-string}
Capture all of the function and macro definitions in a .el source file and turn
them into a LaTex text that documents the functions and their doc strings.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-arg-end }}
\usebox{\funcname}
\index{shu-capture-latex-arg-end} \hfill [Constant]

\begin{doc-string}
Define the latex string that is used to terminate an argument name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-arg-start }}
\usebox{\funcname}
\index{shu-capture-latex-arg-start} \hfill [Constant]

\begin{doc-string}
Define the latex string that is used to prepended to an argument name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-buf-end }}
\usebox{\funcname}
\index{shu-capture-latex-buf-end} \hfill [Constant]

\begin{doc-string}
Define the LaTex string that is used at the end of a buffer name or
any other name that has leading and trailing asterisks
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-buf-start }}
\usebox{\funcname}
\index{shu-capture-latex-buf-start} \hfill [Constant]

\begin{doc-string}
Define the LaTex string that is used in front of a buffer name or
any other name that has leading and trailing asterisks
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-close-quote }}
\usebox{\funcname}
\index{shu-capture-latex-close-quote} \hfill [Constant]

\begin{doc-string}
Define the LaTex string that is a close quote.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-code-end }}
\usebox{\funcname}
\index{shu-capture-latex-code-end} \hfill [Constant]

\begin{doc-string}
Define the LaTex string that is at the end of a verbatim
code snippet.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-code-start }}
\usebox{\funcname}
\index{shu-capture-latex-code-start} \hfill [Constant]

\begin{doc-string}
Define the LaTex string that is at the beginning of a verbatim
code snippet.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-converters }}
\usebox{\funcname}
\index{shu-capture-latex-converters} \hfill [Constant]

\begin{doc-string}
This is the association list of functions and strings that is used to take an elisp
function and its associated doc string and convert it to LaTex.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-doc-end }}
\usebox{\funcname}
\index{shu-capture-latex-doc-end} \hfill [Constant]

\begin{doc-string}
Define the LaTex string that ends a doc string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-doc-start }}
\usebox{\funcname}
\index{shu-capture-latex-doc-start} \hfill [Constant]

\begin{doc-string}
Define the LaTex string that starts a doc string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-keywd-end }}
\usebox{\funcname}
\index{shu-capture-latex-keywd-end} \hfill [Constant]

\begin{doc-string}
Define the latex string that is used to terminate an argument name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-keywd-start }}
\usebox{\funcname}
\index{shu-capture-latex-keywd-start} \hfill [Constant]

\begin{doc-string}
Define the latex string that is used to prepended to an argument name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-open-quote }}
\usebox{\funcname}
\index{shu-capture-latex-open-quote} \hfill [Constant]

\begin{doc-string}
Define the LaTex string that is an open quote.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-section-end }}
\usebox{\funcname}
\index{shu-capture-latex-section-end} \hfill [Constant]

\begin{doc-string}
Define the LaTex tag that is used to identify the start of a section heading.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-latex-section-start }}
\usebox{\funcname}
\index{shu-capture-latex-section-start} \hfill [Constant]

\begin{doc-string}
Define the LaTex tag that is used to identify the start of a section heading.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-make-args-latex }}
\usebox{\funcname}\emph{func-name} \emph{markups}
\index{shu-capture-make-args-latex} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{func-name} is the name of the function, macro, alias, etc.  \emph{func-type} is a
string that represents the function type.  This will be part of the argument
display.  \emph{markups} is either nil or is a cons cell that points to two lists.  If
\emph{markups} is nil, the function has no arguments.  If \emph{markups} is non-nil, it is a
cons cell that points to two lists.  The car of \emph{markups} is a list of the lengths
of each argument before any markup was added to the argument.  If an argument
name is ``arg1,'' its length is 4 even though the length of the argument name
after markup is applied may be longer.  The cdr of \emph{markups} is a list of the
arguments with markup applied to them.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-make-args-md }}
\usebox{\funcname}\emph{func-name} \emph{markups}
\index{shu-capture-make-args-md} \hfill [Function]
\hspace*{\wd\funcname}\emph{section-converter}

\begin{doc-string}
\emph{func-name} is the name of the function, macro, alias, etc.  \emph{func-type} is a
string that represents the function type.  This will be part of the argument
display.  \emph{markups} is either nil or is a cons cell that points to two lists.  If
\emph{markups} is nil, the function has no arguments.  If \emph{markups} is non-nil, it is a
cons cell that points to two lists.  The car of \emph{markups} is a list of the lengths
of each argument before any markup was added to the argument.  If an argument
name is ``arg1,'' its length is 4 even though the length of the argument name
after markup is applied may be longer.  The cdr of \emph{markups} is a list of the
arguments with markup applied to them.  \emph{section-converter} is the function that
will turn a string into a section heading.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-make-latex-section }}
\usebox{\funcname}\emph{level} \emph{hdr}
\index{shu-capture-make-latex-section} \hfill [Function]

\begin{doc-string}
Turn \emph{hdr} into a LaTex section header of level \emph{level}, where 1 is a section,
2 a subsection, etc.  Return the LaTex string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-make-md-section }}
\usebox{\funcname}\emph{level} \emph{hdr}
\index{shu-capture-make-md-section} \hfill [Function]

\begin{doc-string}
Turn \emph{hdr} into a markdown section header of level \emph{level}, where 1 is a section,
2 a subsection, etc.  Return the markdown string.  If level is one (major heading),
write a corresponding entry into the markdown table of contents buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-md }}
\usebox{\funcname}
\index{shu-capture-md} \hfill [Command]

\begin{doc-string}
Capture all of the function and macro definitions in a .el source file and turn
them into markdown text that documents the functions and their doc strings.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-md-arg-delimiter }}
\usebox{\funcname}
\index{shu-capture-md-arg-delimiter} \hfill [Constant]

\begin{doc-string}
Define the markdown delimiter that is used to surround an argument name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-md-buf-delimiter }}
\usebox{\funcname}
\index{shu-capture-md-buf-delimiter} \hfill [Constant]

\begin{doc-string}
Define the markdown delimiter that is used to surround a buffer name or
any other name that has leading and trailing asterisks
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-md-code-delimiter }}
\usebox{\funcname}
\index{shu-capture-md-code-delimiter} \hfill [Constant]

\begin{doc-string}
Define the markdown delimiter that is used to surround a code snippet.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-md-converters }}
\usebox{\funcname}
\index{shu-capture-md-converters} \hfill [Constant]

\begin{doc-string}
This is the association list of functions and strings that is used to take an elisp
function and its associated doc string and convert it to markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-md-keywd-delimiter }}
\usebox{\funcname}
\index{shu-capture-md-keywd-delimiter} \hfill [Constant]

\begin{doc-string}
Define the markdown delimiter that is used to surround an key word such as
``\&optional'' or ``\&rest''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-md-quote-delimiter }}
\usebox{\funcname}
\index{shu-capture-md-quote-delimiter} \hfill [Constant]

\begin{doc-string}
Define the markdown delimiter that is used for open and close quote.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-md-section-delimiter }}
\usebox{\funcname}
\index{shu-capture-md-section-delimiter} \hfill [Constant]

\begin{doc-string}
Define the markdown delimiter that is used to identify a section.  This is separated
from the section name by a space.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-pre-code-in-doc }}
\usebox{\funcname}
\index{shu-capture-pre-code-in-doc} \hfill [Constant]

\begin{doc-string}
The a-list key value that identifies the function that converts characters in a
doc string right before the code snippets are captured.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-pre-code-latex }}
\usebox{\funcname}\emph{min-point} \emph{max-point}
\index{shu-capture-pre-code-latex} \hfill [Function]

\begin{doc-string}
Function that prepares a doc string to capture code snippets in LaTex.
Enter with \emph{min-point} and \emph{max-point} defining the region to be changed.
\emph{min-point} cannot change because all changes are made after it.  But
\emph{max-point} will change if replacements add extra characters.  Return the
new value of \emph{max-point} which takes into account the number of characters
added to the text.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-pre-code-md }}
\usebox{\funcname}\emph{min-point} \emph{max-point}
\index{shu-capture-pre-code-md} \hfill [Function]

\begin{doc-string}
Function that prepares a doc string to capture code snippets in markdown.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-set-func-def }}
\usebox{\funcname}\emph{func-def} \emph{signature}
\index{shu-capture-set-func-def} \hfill [Macro]
\hspace*{\wd\funcname}\emph{description}

\begin{doc-string}
Create a func-def to describe the function
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-set-func-def-alias }}
\usebox{\funcname}\emph{func-def} \emph{signature}
\index{shu-capture-set-func-def-alias} \hfill [Macro]
\hspace*{\wd\funcname}\emph{description} \emph{alias}

\begin{doc-string}
Create a func-def to describe the function
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-show-list }}
\usebox{\funcname}\emph{func-list} \emph{converters} \emph{buffer}
\index{shu-capture-show-list} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{func-list} is a list of function and macro definitions.  \emph{converters}
is an a-list of functions and strings as
follows:

\small{\begin{verbatim}
      Key                              Value
      ---                              -----
      shu-capture-a-type-hdr           Function to format a section header
      shu-capture-a-type-func          Function to format a function signature
      shu-capture-a-type-buf           Function to format a buffer name
      shu-capture-a-type-arg           Function to format an argument name
      shu-capture-a-type-keywd         Function to format a key word
      shu-capture-a-type-doc-string    Function to finish formatting the doc string
      shu-capture-a-type-enclose-doc   Function to enclose doc string in begin / end
      shu-capture-a-type-before        String that starts a block of verbatim code
      shu-capture-a-type-after         String that ends a block of verbatim code
      shu-capture-a-type-open-quote    String that is an open quote
      shu-capture-a-type-close-quote   String that is a close quote
\end{verbatim}}

This function goes through the list and uses the \emph{converters} to turn the set of
function definitions into either markdown or LaTex.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-show-list-md }}
\usebox{\funcname}\emph{func-list} \emph{buffer}
\index{shu-capture-show-list-md} \hfill [Function]

\begin{doc-string}
Show a list
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-toc-buffer }}
\usebox{\funcname}
\index{shu-capture-toc-buffer} \hfill [Constant]

\begin{doc-string}
Name of the buffer into which the markdown table of contents is written
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-capture-vars }}
\usebox{\funcname}\emph{func-list}
\index{shu-capture-vars} \hfill [Function]

\begin{doc-string}
Find the name and doc-string for instances of ``defvar'' or ``defconst.''
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-doc-internal-func-to-md }}
\usebox{\funcname}\emph{func-def}
\index{shu-doc-internal-func-to-md} \hfill [Function]

\begin{doc-string}
Take a function definition and turn it into a string of markdown text.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-doc-internal-to-md }}
\usebox{\funcname}\emph{description}
\index{shu-doc-internal-to-md} \hfill [Function]

\begin{doc-string}
\emph{description} contains a doc string from a function definition (with leading
and trailing quotes removed).  This function turns escaped quotes into regular
(non-escaped) quotes and turns names with leading and trailing asterisks (e.g.,
\emph\{**project-count-buffer**\}) into short code blocks surrounded by back ticks.  It also
turns upper case names into lower case names surrounded by markdown ticks.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-doc-sort-compare }}
\usebox{\funcname}\emph{lhs} \emph{rhs}
\index{shu-doc-sort-compare} \hfill [Function]

\begin{doc-string}
Compare two function names in a sort.
\end{doc-string}

\eject
\section{shu-cpp-general}


A collection of useful functions for dealing with C++ code.

\subsection{Selected highlights}

Here are some useful features of this package.

\subsubsection{Dealing with long string constants}

If you copy strings of text into string constants in your program, you may end up
with some very long lines.  \emph{shu-csplit} can automatically split such a line
for you.  \emph{shu-cunsplit} can undo the split.  \emph{shu-creplace} can in one
operation, replace a split line with a different string constant.



\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{add-include }}
\usebox{\funcname}
\index{add-include} \hfill [Command]\\%
 (Function: shu-add-include)

\begin{doc-string}
When positioned on a line below an include block, this function yanks the
contents of the kill buffer (which is assumed to contain an \#include statement)
and then sorts all of the lines in the current include block.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{author }}
\usebox{\funcname}
\index{author} \hfill [Command]\\%
 (Function: shu-author)

\begin{doc-string}
Insert the doxygen author tag in an existing file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{binclude }}
\usebox{\funcname}
\index{binclude} \hfill [Command]\\%
 (Function: shu-binclude)

\begin{doc-string}
If point is sitting on something that resembles a fully qualified class name,
first check to see if it is in list of standard class names defined in
\emph{shu-cpp-include-names}.  If it is found there, that defines the name of the
defining include file.  If it is not found there, then use the standard BDE
algorithm to turn the class name into the name of an include file.  The standard
BDE algorithm replaces the :: between namespace and class name with an
underscore, makes all letters lower case, and appends ``.h'' to the end of the
name.

Thus ``abcdef::MumbleFrotz'' becomes ``abcdef\_mumblefrotz.h''.

An include directive for the file is then created and put into the kill ring for
a subsequent yank.

The file name is delimited by double quotes unless \emph{shu-cpp-include-user-brackets}
variable is true, in which case the file name is delimited by left and right
angle brackets.

Return true if a class name was found an an include generated.  This is for the
benefit of unit tests.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cdo }}
\usebox{\funcname}
\index{cdo} \hfill [Command]\\%
 (Function: shu-cdo)

\begin{doc-string}
Insert an empty do statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{celse }}
\usebox{\funcname}
\index{celse} \hfill [Command]\\%
 (Function: shu-celse)

\begin{doc-string}
Insert an empty else statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cfor }}
\usebox{\funcname}
\index{cfor} \hfill [Command]\\%
 (Function: shu-cfor)

\begin{doc-string}
Insert an empty for statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cif }}
\usebox{\funcname}
\index{cif} \hfill [Command]\\%
 (Function: shu-cif)

\begin{doc-string}
Insert an empty if statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{ck }}
\usebox{\funcname}\emph{start} \emph{end}
\index{ck} \hfill [Command]\\%
 (Function: shu-cpp-check-streaming-op)

\begin{doc-string}
Check a streaming operation.   Mark a region that contains a set of streaming
operators and invoke this function.  It will make sure that you have no unterminated
strings and that you are not missing any occurrences of $<$$<$.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{clc }}
\usebox{\funcname}
\index{clc} \hfill [Command]\\%
 (Function: shu-clc)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cpp1-class }}
\usebox{\funcname}\emph{class-name}
\index{cpp1-class} \hfill [Command]\\%
 (Function: shu-cpp1-class)

\begin{doc-string}
Place a skeleton class definition in the current buffer at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cpp2-class }}
\usebox{\funcname}\emph{class-name}
\index{cpp2-class} \hfill [Command]\\%
 (Function: shu-cpp2-class)

\begin{doc-string}
Place a skeleton class definition in the current buffer at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{creplace }}
\usebox{\funcname}\emph{prefix}
\index{creplace} \hfill [Command]\\%
 (Function: shu-creplace)

\begin{doc-string}
This function will replace the C++ string in which point is placed with the
C++ string in the kill ring.  The C++ string in the kill ring is expected to be
a single string with or without quotes.  The C++ string in which point is placed
may have been split into smaller substrings in order to avoid long lines.

Assume you have the sample string that is shown in \emph{shu-csplit}

\small{\begin{verbatim}
     static const std::string x(``This is a very long line of text that looks ``
                                ``as though it will go on forever.'');
\end{verbatim}}

You wish to replace it with a slightly different line of text, perhaps something
that came from the output of a program.  Copy the new string into the kill ring.
Then put the cursor into any part of any line of the string to be replaced
and invoke this function.  This function will remove the old string, replace it
with the contents of the string in the kill ring, and then split it up into
shorter lines as in the following example.  The string in the kill ring may have
opening and closing quotes or not.

\small{\begin{verbatim}
     static const std::string x(``This is a very long line of text that looks ``
                                ``as though it will go on forever and probably ``
                                ``already has done so or is threatening to do ``
                                ``so.'');
\end{verbatim}}

This is especially useful if you have a a string constant in a unit test and you
have modified the code that creates the string.  gtest will complain that the
expected string did not match the actual string.  If the actual string is
correct, copy it into the kill ring, go into your unit test, find the old
string, place the cursor in the old string, and replace it with the new.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{csplit }}
\usebox{\funcname}\emph{prefix}
\index{csplit} \hfill [Command]\\%
 (Function: shu-csplit)

\begin{doc-string}
Split a C++ string into multiple strings in order to keep the line length
below a certain minimum length..  The line length used is defined by the custom
variable \emph{shu-cpp-line-end}.

For example, you may copy a very long line of text into a section of code as
follows:

\small{\begin{verbatim}
     static const std::string x(``This is a very long line of text that looks as though it will go on forever.'');
\end{verbatim}}

To be polite to future code readers, you want to split this into multiple lines.
This can be a bit cumbersome if the text is very long.  This function splits the
text at a somewhat arbitrary boundary so that it can be read by others whose
text editors do not show code much beyond column 80 or so.  This is an example
of the above line after csplit was invoked:

\small{\begin{verbatim}
     static const std::string x(``This is a very long line of text that looks ``
                                ``as though it will go on forever.'');
\end{verbatim}}

This function normally splits lines on a word boundary.  If any prefix argument
is present, the split will be composed of fixed length lines with no respect to
word boundaries.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cunsplit }}
\usebox{\funcname}
\index{cunsplit} \hfill [Command]\\%
 (Function: shu-cunsplit)

\begin{doc-string}
The beginnings of a re-write of \emph{shu-cunsplit}.
Needs more testing.
Undo the split that was done by csplit.  Place the cursor anywhere
in any of the strings and invoke this function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cwhile }}
\usebox{\funcname}
\index{cwhile} \hfill [Command]\\%
 (Function: shu-cwhile)

\begin{doc-string}
Insert an empty while statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dbx-malloc }}
\usebox{\funcname}
\index{dbx-malloc} \hfill [Command]\\%
 (Function: shu-dbx-summarize-malloc)

\begin{doc-string}
Go through the output of a dbx malloc dump and generate a summary.  dbx is
the AIX debugger.  It has a malloc command that goes through the heap and prints
one line for every allocated buffer.  Here is a sample of some of its output:

\small{\begin{verbatim}
         ADDRESS         SIZE HEAP    ALLOCATOR
      0x30635678          680    0     YORKTOWN
      0x30635928          680    0     YORKTOWN
      0x30635bd8          680    0    HEAPCACHE
      0x30635bcf          680    0     YORKTOWN
\end{verbatim}}

YORKTOWN is the name of the default allocator on AIX.  This function goes
through the malloc output and gets the number and sizes of all buffers
allocated.  This tells you how many buffers were allocated, the total number of
bytes allocated, and the total number of buffers allocated by size.  The output
is placed in a separate buffer called \emph\{**shu-aix-malloc**.\}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dcc }}
\usebox{\funcname}
\index{dcc} \hfill [Command]\\%
 (Function: shu-dcc)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dce }}
\usebox{\funcname}
\index{dce} \hfill [Command]\\%
 (Function: shu-dce)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dciterate }}
\usebox{\funcname}\emph{type-name} \emph{var-name-1} \emph{var-name-2}
\index{dciterate} \hfill [Command]\\%
 (Function: shu-dciterate)

\begin{doc-string}
Insert the code to iterate through a pair of data structures of type
\emph{type-name}, whose first instance is identified by \emph{var-name-1} and whose second
instance is identified by \emph{var-name-2}.

The first prompt reads the type name, second and third prompts read the two
variable names.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (std::pair<type-name::const_iterator,
                     type-name::const_iterator>
               its(var-name-1.begin(), var-name-2.begin());
           its.first != var-name-1.end() \&\& its.second != var-name-2.end();
           ++its.first, ++its.second)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.

The name of the namespace used for the standard library is defined in the custom
variable shu-cpp-std-namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{diterate }}
\usebox{\funcname}\emph{type-name} \emph{var-name-1} \emph{var-name-2}
\index{diterate} \hfill [Command]\\%
 (Function: shu-diterate)

\begin{doc-string}
Insert the code to iterate through a pair of data structures of type
\emph{type-name}, whose first instance is identified by \emph{var-name-1} and whose second
instance is identified by \emph{var-name-2}.

The first prompt reads the type name, second and third prompts read the two
variable names.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (std::pair<type-name::iterator,
                     type-name::iterator>
               its(var-name-1.begin(), var-name-2.begin());
           its.first != var-name-1.end() \&\& its.second != var-name-2.end();
           ++its.first, ++its.second)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.

The name of the namespace used for the standard library is defined in the custom
variable shu-cpp-std-namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dox-brief }}
\usebox{\funcname}
\index{dox-brief} \hfill [Command]\\%
 (Function: shu-dox-brief)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dox-cbt }}
\usebox{\funcname}
\index{dox-cbt} \hfill [Command]\\%
 (Function: shu-dox-cbt)

\begin{doc-string}
Convert a section of comments delimited by //! into Doxygen brief format.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dox-cvt }}
\usebox{\funcname}
\index{dox-cvt} \hfill [Command]\\%
 (Function: shu-dox-cvt)

\begin{doc-string}
Convert a section of comments delimited by // into Doxygen format.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dox2-hdr }}
\usebox{\funcname}
\index{dox2-hdr} \hfill [Command]\\%
 (Function: shu-dox2-hdr)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{drc }}
\usebox{\funcname}
\index{drc} \hfill [Command]\\%
 (Function: shu-drc)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{fill-area }}
\usebox{\funcname}\emph{start} \emph{end}
\index{fill-area} \hfill [Command]\\%
 (Function: shu-cpp-fill-test-area)

\begin{doc-string}
For all lines between the marked start and end points, if a recognized data
type has been declared on a line, fill it with random test data.

For the benefit of unit tests, this function returns a a cons cell whose car is
the number of unrecognized data types and whose cdr is the number of values
generated.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{fill-data }}
\usebox{\funcname}
\index{fill-data} \hfill [Command]\\%
 (Function: shu-cpp-fill-test-data)

\begin{doc-string}
If the data type at the beginning of the line is a recognized data type, then
fill in a random value for that data type at point.  This allows someone writing
a test to declare a data type and a name and then call this function.  If the
author creates a line that looks like this and then invokes this function

\small{\begin{verbatim}
     std::string   abc
\end{verbatim}}

The line will be transformed into one that looks something like this:

\small{\begin{verbatim}
     std::string   abc(``RDATZC'');
\end{verbatim}}

The recognized data types are the ones that are defined by the custom variables
shu-cpp-date-type, shu-cpp-datetime-timezone-type, shu-cpp-datetime-type,
shu-cpp-interval-type, shu-cpp-long-long-type, shu-cpp-string-type, or
shu-cpp-time-type plus many of the standard C++ types, such as int, bool, short,
etc.

The data types may optionally be preceded by ``const''.

If the last character of the line is ``;'', it is deleted before a data type is
filled in with a new semi-colon following it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{fixp }}
\usebox{\funcname}
\index{fixp} \hfill [Command]\\%
 (Function: shu-cpp-fix-prototype)

\begin{doc-string}
Place the cursor on the beginning of a function declaration that has been
copied from a .cpp file to a .h file.  This function fixes up the function
prototype to make it suitable for a .h file.
For example, this declaration:

\small{\begin{verbatim}
      double Frobnitz::hitRatio(
          const int  reads,
          const int  writes)
      const
\end{verbatim}}

would be transformed into

\small{\begin{verbatim}
          double hitRatio(
              const int  reads,
              const int  writes)
          const;
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gcc }}
\usebox{\funcname}
\index{gcc} \hfill [Command]\\%
 (Function: shu-gcc)

\begin{doc-string}
Get compile command command from current buffer.  While in a compile buffer,
go to the top of the buffer, search for the end of the prompt line, collect the
rest of the line and put it into the kill ring.  This takes the string that was
used for the last compile command in the current buffer and puts it into the
kill ring.  To compile again with the same command, kill the buffer, open a new
shell, and yank.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{get-set }}
\usebox{\funcname}
\index{get-set} \hfill [Command]\\%
 (Function: shu-get-set)

\begin{doc-string}
Generate get and set functions for an instance variable in a C++ class.
Position the cursor ahead of the Doxygen comment above the variable.  The get
and set functions will be placed in the buffer \emph\{*get-set*.\}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{getdef }}
\usebox{\funcname}
\index{getdef} \hfill [Command]\\%
 (Function: shu-cpp-find-h-definition)

\begin{doc-string}
While in a cpp file, position point on a variable name that is defined in the
corresponding header file and invoke this function.  It will find all occurrences of
the name in the header file and put them in the message area.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{getters }}
\usebox{\funcname}\emph{start} \emph{end}
\index{getters} \hfill [Command]\\%
 (Function: shu-getters)

\begin{doc-string}
Mark a region in a file that contains C++ instance variable declarations.
This function will create get and set functions for all of the instance
variables.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{ginclude }}
\usebox{\funcname}
\index{ginclude} \hfill [Command]\\%
 (Function: shu-ginclude)

\begin{doc-string}
While in a file buffer, wrap the file name in a C++ include directive and
put it in the kill ring.  The file name is delimited by double quotes unless
\emph{shu-cpp-include-user-brackets} variable is true, in which case the file name
is delimited by left and right angle brackets.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{is-keyword }}
\usebox{\funcname}
\index{is-keyword} \hfill [Command]\\%
 (Function: shu-is-keyword)

\begin{doc-string}
Do a COMPLETING-READ from the minibuffer of a string that may or may not be a
C++ key word.  If the string is a C++ key word, display the key word, else
display ``no''.  If (point) is sitting on a C++ key word, that is the default
initial input to the completing read.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{make-datetime }}
\usebox{\funcname}
\index{make-datetime} \hfill [Command]\\%
 (Function: shu-cpp-make-datetime)

\begin{doc-string}
insert a string that is the list of values to be passed to the constructor of
 a datetime type that accepts year, month, day, hour, minute, second,
 milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{make-interval }}
\usebox{\funcname}
\index{make-interval} \hfill [Command]\\%
 (Function: shu-cpp-make-interval)

\begin{doc-string}
insert a string that is the list of values to be passed to the constructor of a datetime
 type that accepts year, month, day, hour, minute, second, milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{make-tzdate }}
\usebox{\funcname}
\index{make-tzdate} \hfill [Command]\\%
 (Function: shu-cpp-tz-make-datetime)

\begin{doc-string}
insert a string that is the list of values to be passed to the constructor of
 a datetime type that accepts year, month, day, hour, minute, second,
 milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{new-c-class }}
\usebox{\funcname}
\index{new-c-class} \hfill [Command]\\%
 (Function: shu-new-c-class)

\begin{doc-string}
Place a skeleton class definition in the current buffer at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{new-c-file }}
\usebox{\funcname}
\index{new-c-file} \hfill [Command]\\%
 (Function: shu-new-c-file)

\begin{doc-string}
Generate a skeleton code file for a C or C++ file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{new-h-file }}
\usebox{\funcname}
\index{new-h-file} \hfill [Command]\\%
 (Function: shu-new-h-file)

\begin{doc-string}
Generate a skeleton header file for C or C++ file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{new-x-file }}
\usebox{\funcname}
\index{new-x-file} \hfill [Command]\\%
 (Function: shu-new-x-file)

\begin{doc-string}
Generate a skeleton Doxygen \\file directive.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{operators }}
\usebox{\funcname}\emph{class-name}
\index{operators} \hfill [Command]\\%
 (Function: shu-operators)

\begin{doc-string}
Place skeletons of all of the standard c++ operator functions at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{qualify-bsl }}
\usebox{\funcname}
\index{qualify-bsl} \hfill [Command]\\%
 (Function: shu-qualify-namespace-bsl)

\begin{doc-string}
Add ``bsl'' namespace qualifier to some of the classes in ``bsl''.  Return the
count of class names changed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{qualify-class }}
\usebox{\funcname}
\index{qualify-class} \hfill [Command]\\%
 (Function: shu-interactive-qualify-class-name)

\begin{doc-string}
Interactively call \emph{shu-qualify-class-name} to find all instances of a class name and
add a namespace qualifier to it.  First prompt is for the class name.  If a fully qualified
class name is supplied, then the given namespace is applied to the class name.  If the name
supplied is not a namespace qualified class name, then a second prompt is given to read the
namespace.
This is intended to help rescue code that has one or more ``using namespace''
directives in it.  The problem with ``using namespace'' is that you now have
class names from other namespaces with no easy way to identify the namespace
to which they belong.  The best thing to do is get rid of the ``using
namespace'' statements and explicitly qualify the class names.  But if you
use a simple replace to do that, you will qualify variable names that resemble
class names as well as class names that are already qualified.  This function
only adds a namespace to a class name that does not already have a namespace
qualifier.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{qualify-std }}
\usebox{\funcname}
\index{qualify-std} \hfill [Command]\\%
 (Function: shu-qualify-namespace-std)

\begin{doc-string}
Add ``std'' namespace qualifier to some of the classes in ``std''.  Return the
count of class names changed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-default-namespace }}
\usebox{\funcname}\emph{name}
\index{set-default-namespace} \hfill [Command]\\%
 (Function: shu-set-default-namespace)

\begin{doc-string}
Set the local namespace for C++ classes.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-modern }}
\usebox{\funcname}
\index{set-modern} \hfill [Command]\\%
 (Function: shu-set-modern)

\begin{doc-string}
Unconditionally set shu-cpp-modern to true.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-no-modern }}
\usebox{\funcname}
\index{set-no-modern} \hfill [Command]\\%
 (Function: shu-set-no-modern)

\begin{doc-string}
Unconditionally set shu-cpp-modern to false.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{sort-all-includes }}
\usebox{\funcname}
\index{sort-all-includes} \hfill [Command]\\%
 (Function: shu-sort-all-includes)

\begin{doc-string}
Sort each contiguous block of \#include directives in the entire buffer.  This
is similar to \emph{shu-sort-includes} but instead of restricting the sort to the
current block of contiguous \#include directives, it finds all of the blocks of
contiguous \#include directives and sorts each block.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{sort-includes }}
\usebox{\funcname}
\index{sort-includes} \hfill [Command]\\%
 (Function: shu-sort-includes)

\begin{doc-string}
When positioned on a line that is an \#include directive, find all of the
\#include directives above and below that line that are not separated by a line
that is not an \#include directive and sort them into alphabetical order with
case ignored.  If not positioned on a line that is an \#include directive, do
nothing.  The return value is the number of lines sorted.  If no lines were
sorted because (point) is not positioned on an \#include directive, return nil.
The return value is for the benefit of the unit tests.  Additionally, if there
are spaces surrounding the ``\#'' of the \#include, they are removed.  After the
sort, any duplicate \#include directives are removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{tciterate }}
\usebox{\funcname}\emph{type-name-1} \emph{type-name-2} \emph{var-name-1}
\index{tciterate} \hfill [Command]
\hspace*{\wd\funcname}\\%
 (Function: shu-tciterate)

\begin{doc-string}
Insert the code to iterate through a pair of data structures of types
\emph{type-name-1} and \emph{type-name-2}, whose first instance is identified by \emph{var-name-1}
and whose second instance is identified by \emph{var-name-2}.

The first two prompt reads the two type names, third and fourth prompts read the
two variable names.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (std::pair<type-name-1::const_iterator,
                     type-name-2::const_iterator>
               its(var-name-1.begin(), var-name-2.begin());
           its.first != var-name-1.end() \&\& its.second != var-name-2.end();
           ++its.first, ++its.second)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.

The name of the namespace used for the standard library is defined in the custom
variable shu-cpp-std-namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{titerate }}
\usebox{\funcname}\emph{type-name-1} \emph{type-name-2} \emph{var-name-1}
\index{titerate} \hfill [Command]
\hspace*{\wd\funcname}\\%
 (Function: shu-titerate)

\begin{doc-string}
Insert the code to iterate through a pair of data structures of types
\emph{type-name-1} and \emph{type-name-2}, whose first instance is identified by \emph{var-name-1}
and whose second instance is identified by \emph{var-name-2}.

The first two prompt reads the two type names, third and fourth prompts read the
two variable names.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (std::pair<type-name-1::iterator,
                     type-name-2::iterator>
               its(var-name-1.begin(), var-name-2.begin());
           its.first != var-name-1.end() \&\& its.second != var-name-2.end();
           ++its.first, ++its.second)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.

The name of the namespace used for the standard library is defined in the custom
variable shu-cpp-std-namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{to-camel }}
\usebox{\funcname}
\index{to-camel} \hfill [Command]\\%
 (Function: shu-to-camel)

\begin{doc-string}
Convert the variable name at point from snake case to camel case.

For example, ``mumble\_something\_other'' becomes ``mumbleSomethingOther''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{to-snake }}
\usebox{\funcname}
\index{to-snake} \hfill [Command]\\%
 (Function: shu-to-snake)

\begin{doc-string}
Convert the variable name at point from camel case to snake case.

For example, ``mumbleSomethingOther'' becomes ``mumble\_something\_other''.
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-cpp-base-types }}
\usebox{\funcname}\emph{ntypes}
\index{shu-add-cpp-base-types} \hfill [Function]

\begin{doc-string}
Add one or more data types to the list of C++ native data types defined in shu-cpp-base-types
in shu-cpp-general.el.  Argument may be a single type in a string or a list of strings.
This modifies shu-cpp-base-types.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-include }}
\usebox{\funcname}
\index{shu-add-include} \hfill [Command]\\%
 (Alias: add-include)

\begin{doc-string}
When positioned on a line below an include block, this function yanks the
contents of the kill buffer (which is assumed to contain an \#include statement)
and then sorts all of the lines in the current include block.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-aix-show-allocators }}
\usebox{\funcname}\emph{sizes} \emph{gb}
\index{shu-aix-show-allocators} \hfill [Function]

\begin{doc-string}
\emph{sizes} is an alist whose car is an allocator name and whose cdr is the number of
allocations attributed to that allocator.  For each allocator, display in the
buffer \emph{gb}, the name of the allocator and its counts
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-aix-show-malloc-list }}
\usebox{\funcname}\emph{mlist} \emph{gb}
\index{shu-aix-show-malloc-list} \hfill [Function]

\begin{doc-string}
Print the number of buffers allocated by size from an AIX dbx malloc command.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-announce-sort-counts }}
\usebox{\funcname}\emph{ret-val} \textbf{\&optional}
\index{shu-announce-sort-counts} \hfill [Function]
\hspace*{\wd\funcname}\emph{changed-group-count}

\begin{doc-string}
\emph{ret-val} is a cons cell whose car is the count of lines sorted by
\emph{shu-internal-sort-includes} and whose cdr is the number of duplicate lines
removed.  The optional \emph{group-count} is the number of groups sorted, if present.
The optional \emph{changed-group-count} is the number of groups that were actually
changed.  Display the appropriate message in the minibuffer with those counts.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-attr-name }}
\usebox{\funcname}
\index{shu-attr-name} \hfill [Variable]

\begin{doc-string}
The name of an attribute.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-author }}
\usebox{\funcname}
\index{shu-author} \hfill [Command]\\%
 (Alias: author)

\begin{doc-string}
Insert the doxygen author tag in an existing file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-binclude }}
\usebox{\funcname}
\index{shu-binclude} \hfill [Command]\\%
 (Alias: binclude)

\begin{doc-string}
If point is sitting on something that resembles a fully qualified class name,
first check to see if it is in list of standard class names defined in
\emph{shu-cpp-include-names}.  If it is found there, that defines the name of the
defining include file.  If it is not found there, then use the standard BDE
algorithm to turn the class name into the name of an include file.  The standard
BDE algorithm replaces the :: between namespace and class name with an
underscore, makes all letters lower case, and appends ``.h'' to the end of the
name.

Thus ``abcdef::MumbleFrotz'' becomes ``abcdef\_mumblefrotz.h''.

An include directive for the file is then created and put into the kill ring for
a subsequent yank.

The file name is delimited by double quotes unless \emph{shu-cpp-include-user-brackets}
variable is true, in which case the file name is delimited by left and right
angle brackets.

Return true if a class name was found an an include generated.  This is for the
benefit of unit tests.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-bsl-include-list }}
\usebox{\funcname}
\index{shu-bsl-include-list} \hfill [Constant]

\begin{doc-string}
An alist that maps include file names to class names when using BDE.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cciterate }}
\usebox{\funcname}\emph{type-name} \emph{var-name}
\index{shu-cciterate} \hfill [Command]

\begin{doc-string}
Insert the code to iterate through a data structure of type \emph{type-name} whose
instance is identified by \emph{var-name}.  First prompt reads the type name.  Second
prompt read the variable name.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (type_name::const_iterator it = var_name.begin();
           it != var_name.end(); ++it)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cdo }}
\usebox{\funcname}
\index{shu-cdo} \hfill [Command]\\%
 (Alias: cdo)

\begin{doc-string}
Insert an empty do statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-celse }}
\usebox{\funcname}
\index{shu-celse} \hfill [Command]\\%
 (Alias: celse)

\begin{doc-string}
Insert an empty else statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cfor }}
\usebox{\funcname}
\index{shu-cfor} \hfill [Command]\\%
 (Alias: cfor)

\begin{doc-string}
Insert an empty for statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cif }}
\usebox{\funcname}
\index{shu-cif} \hfill [Command]\\%
 (Alias: cif)

\begin{doc-string}
Insert an empty if statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-citerate }}
\usebox{\funcname}\emph{type-name} \emph{var-name}
\index{shu-citerate} \hfill [Command]

\begin{doc-string}
Insert the code to iterate through a data structure of type \emph{type-name} whose
instance is identified by \emph{var-name}.  First prompt reads the type name.  Second
prompt read the variable name.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (type_name::iterator it = var_name.begin();
           it != var_name.end(); ++it)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-class-is-blocked }}
\usebox{\funcname}\emph{pos} \textbf{\&optional} \emph{in-string}
\index{shu-class-is-blocked} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Return true if a class name should be ignored because it is either in a
string or a comment.

We have found something at point \emph{pos} that looks as though it might be a class
name.  If it is in a string or is preceded on the same line by ``//'' (also not
in a string), then it is either in a string or is probably in a comment, so we
may want to ignore it.  \emph{in-string} is true if a class name inside of a string is
to be replaced.  \emph{in-comment} is true if a class name inside of a comment is to be
replaced.

Return true if the class name should be ignored.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-clc }}
\usebox{\funcname}
\index{shu-clc} \hfill [Command]\\%
 (Alias: clc)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-allocator-type }}
\usebox{\funcname}
\index{shu-cpp-allocator-type} \hfill [Custom]

\begin{doc-string}
The data type that represents an allocator.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-base-types }}
\usebox{\funcname}
\index{shu-cpp-base-types} \hfill [Constant]

\begin{doc-string}
A list of all of the base types in C and C++.  This may be modified by shu-add-cpp-base-types
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-check-streaming-op }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-cpp-check-streaming-op} \hfill [Command]\\%
 (Alias: ck)

\begin{doc-string}
Check a streaming operation.   Mark a region that contains a set of streaming
operators and invoke this function.  It will make sure that you have no unterminated
strings and that you are not missing any occurrences of $<$$<$.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-date-type }}
\usebox{\funcname}
\index{shu-cpp-date-type} \hfill [Custom]

\begin{doc-string}
The data type that represents a date.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-datetime-timezone-type }}
\usebox{\funcname}
\index{shu-cpp-datetime-timezone-type} \hfill [Custom]

\begin{doc-string}
The data type that represents a date and time with an associated time zone.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-datetime-type }}
\usebox{\funcname}
\index{shu-cpp-datetime-type} \hfill [Custom]

\begin{doc-string}
The data type that represents a date and time.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-fill-test-area }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-cpp-fill-test-area} \hfill [Command]\\%
 (Alias: fill-area)

\begin{doc-string}
For all lines between the marked start and end points, if a recognized data
type has been declared on a line, fill it with random test data.

For the benefit of unit tests, this function returns a a cons cell whose car is
the number of unrecognized data types and whose cdr is the number of values
generated.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-fill-test-data }}
\usebox{\funcname}
\index{shu-cpp-fill-test-data} \hfill [Command]\\%
 (Alias: fill-data)

\begin{doc-string}
If the data type at the beginning of the line is a recognized data type, then
fill in a random value for that data type at point.  This allows someone writing
a test to declare a data type and a name and then call this function.  If the
author creates a line that looks like this and then invokes this function

\small{\begin{verbatim}
     std::string   abc
\end{verbatim}}

The line will be transformed into one that looks something like this:

\small{\begin{verbatim}
     std::string   abc(``RDATZC'');
\end{verbatim}}

The recognized data types are the ones that are defined by the custom variables
shu-cpp-date-type, shu-cpp-datetime-timezone-type, shu-cpp-datetime-type,
shu-cpp-interval-type, shu-cpp-long-long-type, shu-cpp-string-type, or
shu-cpp-time-type plus many of the standard C++ types, such as int, bool, short,
etc.

The data types may optionally be preceded by ``const''.

If the last character of the line is ``;'', it is deleted before a data type is
filled in with a new semi-colon following it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-find-current-include-block }}
\usebox{\funcname}
\index{shu-cpp-find-current-include-block} \hfill [Function]

\begin{doc-string}
This function returns a cons cell that defines the upper and lower bounds of
the contiguous block of \#include directives in which point it sitting.  If point
is not sitting in a contiguous block of one or more \#include directives, return
nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-find-h-definition }}
\usebox{\funcname}
\index{shu-cpp-find-h-definition} \hfill [Command]\\%
 (Alias: getdef)

\begin{doc-string}
While in a cpp file, position point on a variable name that is defined in the
corresponding header file and invoke this function.  It will find all occurrences of
the name in the header file and put them in the message area.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-find-include-blocks }}
\usebox{\funcname}
\index{shu-cpp-find-include-blocks} \hfill [Function]

\begin{doc-string}
This function returns a list of cons cells, each of which holds the point of
the start and end of a contiguous block of \#include directives.

For example, if a buffer contains

\small{\begin{verbatim}
      #include <able>
      #include <charlie>
      // Hello
      #include <delta>
\end{verbatim}}

this function will return a list of two cons cells.  The first one holds the
point of the ``\#'' of \#include $<$delta$>$ and the point of the ``$>$`` of \#include
$<$delta$>$.  The second holds the point of the ``\#'' of \#include $<$able$>$ and the
point of the ``$>$`` of \#include $<$charlie$>$.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-find-include-direction }}
\usebox{\funcname}\emph{pllist}
\index{shu-cpp-find-include-direction} \hfill [Function]

\begin{doc-string}
\emph{pllist} is a list returned from \emph{shu-cpp-find-include-locations}.  Each entry in
the list is a cons cell whose car is the point of the ``\#'' sign and whose cdr
is the line number on which the ``\#'' was found.  The list may have been
produced by either a forward or backward tokenization.  i.e., The first item on
the list may be the last \#include in the buffer or the first.  This function
returns +1 if the list is in order by ascending location or -1 if the list is in
order by descending location.  If the list has no order because it only has one
entry, +1 is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-find-include-locations }}
\usebox{\funcname}
\index{shu-cpp-find-include-locations} \hfill [Function]

\begin{doc-string}
Return a list of the locations of all \#include directives in the current
buffer.  Each entry in the list is a cons cell whose car is the point of the
``\#'' sign and whose cdr is the line number on which the ``\#'' was found.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-find-using }}
\usebox{\funcname}\textbf{\&optional} \emph{top-name}
\index{shu-cpp-find-using} \hfill [Command]

\begin{doc-string}
Return the name of the class found on the next ``using namespace'' directive
or nil of no such directive found.

\emph{top-name}, if present is a higher level namespace.  Given a top level namespace
of ``WhammoCorp'', then the following line:

\small{\begin{verbatim}
     using namespace WhammoCorp::world;
\end{verbatim}}

would be interpreted as though it had been written:

\small{\begin{verbatim}
     using namespace world;
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-find-variable-name-by-token }}
\usebox{\funcname}\emph{var-name}
\index{shu-cpp-find-variable-name-by-token} \hfill [Function]

\begin{doc-string}
Tokenize the entire buffer and return the position of the first token
that matches var-name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-find-variable-name-lines-by-token }}
\usebox{\funcname}\emph{var-name}
\index{shu-cpp-find-variable-name-lines-by-token} \hfill [Function]

\begin{doc-string}
Tokenize the entire buffer and return a string that is composed of each
line that contains the token.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-fix-prototype }}
\usebox{\funcname}
\index{shu-cpp-fix-prototype} \hfill [Command]\\%
 (Alias: fixp)

\begin{doc-string}
Place the cursor on the beginning of a function declaration that has been
copied from a .cpp file to a .h file.  This function fixes up the function
prototype to make it suitable for a .h file.
For example, this declaration:

\small{\begin{verbatim}
      double Frobnitz::hitRatio(
          const int  reads,
          const int  writes)
      const
\end{verbatim}}

would be transformed into

\small{\begin{verbatim}
          double hitRatio(
              const int  reads,
              const int  writes)
          const;
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-general-set-alias }}
\usebox{\funcname}
\index{shu-cpp-general-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-cpp-general.
These are generally the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-get-variable-name }}
\usebox{\funcname}
\index{shu-cpp-get-variable-name} \hfill [Function]

\begin{doc-string}
If point is sitting on something that looks like a legal variable name, return it,
otherwise, return nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-get-variable-name-position }}
\usebox{\funcname}
\index{shu-cpp-get-variable-name-position} \hfill [Function]

\begin{doc-string}
If point is sitting on something that looks like a legal variable name,
return a cons cell that contains the start and end positions of the name
otherwise, return nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-include-names }}
\usebox{\funcname}
\index{shu-cpp-include-names} \hfill [Variable]

\begin{doc-string}
A hash table that maps class names to include file names  This is the hash table
inversion of shu-std-include-list or shu-bsl-include-list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-fill-test-data }}
\usebox{\funcname}
\index{shu-cpp-internal-fill-test-data} \hfill [Function]

\begin{doc-string}
If the data type at the beginning of the line is a recognized data type, then
fill in a random value for that data type at point.  This allows someone writing
a test to declare a data type and a name and then call this function.  If the
author creates a line that looks like this and then invokes this function

\small{\begin{verbatim}
     std::string   abc
\end{verbatim}}

The line will be transformed into one that looks something like this:

\small{\begin{verbatim}
     std::string   abc(``RDATZC'');
\end{verbatim}}

The recognized data types are the ones that are defined by the custom variables
shu-cpp-date-type, shu-cpp-datetime-timezone-type, shu-cpp-datetime-type,
shu-cpp-interval-type, shu-cpp-long-long-type, shu-cpp-string-type, or
shu-cpp-time-type plus many of the standard C++ types, such as int, bool, short,
etc.

The data types may optionally be preceded by ``const''.

If the last character of the line is ``;'', it is deleted before a data type is
filled in with a new semi-colon following it.

Return t if a recognized data type was found and a value was filled in.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-bool }}
\usebox{\funcname}
\index{shu-cpp-internal-make-bool} \hfill [Function]

\begin{doc-string}
Return  value for a bool type.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-char }}
\usebox{\funcname}
\index{shu-cpp-internal-make-char} \hfill [Command]

\begin{doc-string}
Return a string that can be used to initialize a test variable of type int.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-date }}
\usebox{\funcname}
\index{shu-cpp-internal-make-date} \hfill [Function]

\begin{doc-string}
Return a string that is the list of values to be passed to the constructor of
 a datetime type that accepts year, month, day, hour, minute, second,
 milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-datetime }}
\usebox{\funcname}
\index{shu-cpp-internal-make-datetime} \hfill [Function]

\begin{doc-string}
Return a string that is the list of values to be passed to the constructor of
 a datetime type that accepts year, month, day, hour, minute, second,
 milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-double }}
\usebox{\funcname}
\index{shu-cpp-internal-make-double} \hfill [Command]

\begin{doc-string}
Return a string that can be used to initialize a test variable of type double.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-float }}
\usebox{\funcname}
\index{shu-cpp-internal-make-float} \hfill [Command]

\begin{doc-string}
Return a string that can be used to initialize a test variable of type float.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-int }}
\usebox{\funcname}
\index{shu-cpp-internal-make-int} \hfill [Command]

\begin{doc-string}
Return a string that can be used to initialize a test variable of type lint.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-interval }}
\usebox{\funcname}
\index{shu-cpp-internal-make-interval} \hfill [Function]

\begin{doc-string}
Return a string that is the list of values to be passed to the constructor of a datetime
 type that accepts days, hours, minutes, seconds, milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-long-long }}
\usebox{\funcname}
\index{shu-cpp-internal-make-long-long} \hfill [Command]

\begin{doc-string}
Return a string that can be used to initialize a test variable of type long long.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-short }}
\usebox{\funcname}
\index{shu-cpp-internal-make-short} \hfill [Command]

\begin{doc-string}
Return a string that can be used to initialize a test variable of type short.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-short-interval }}
\usebox{\funcname}
\index{shu-cpp-internal-make-short-interval} \hfill [Function]

\begin{doc-string}
Return a string that is the list of values to be passed to the constructor of a datetime
 type that accepts seconds and nanoseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-time }}
\usebox{\funcname}
\index{shu-cpp-internal-make-time} \hfill [Function]

\begin{doc-string}
Return a string that is the list of values to be passed to the constructor of
 a time type that accepts hour, minute, second,  milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-make-unsigned-int }}
\usebox{\funcname}
\index{shu-cpp-internal-make-unsigned-int} \hfill [Command]

\begin{doc-string}
Return a string that can be used to initialize a test variable of type lint.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-stream-check }}
\usebox{\funcname}\emph{token-list}
\index{shu-cpp-internal-stream-check} \hfill [Function]

\begin{doc-string}
Take a list of tokens found in a C++ streaming operation and check to
ensure that every other token is a $<$$<$ operator.  Two adjacent occurrences of $<$$<$
represent an extraneous $<$$<$ operator.  Two adjacent occurrences of tokens that
are not $<$$<$ represent a missing $<$$<$ operator.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-tz-make-datetime }}
\usebox{\funcname}
\index{shu-cpp-internal-tz-make-datetime} \hfill [Function]

\begin{doc-string}
Return a string that is the list of values to be passed to the constructor of
a timezone datetime type.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-interval-type }}
\usebox{\funcname}
\index{shu-cpp-interval-type} \hfill [Custom]

\begin{doc-string}
The data type that represents a time interval type.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-is-enclosing-op }}
\usebox{\funcname}\emph{op}
\index{shu-cpp-is-enclosing-op} \hfill [Function]

\begin{doc-string}
Return true if the single character in \emph{op} is an enclosing character, a left
or right parenthesis or a left or right square bracket.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-is-keyword }}
\usebox{\funcname}\emph{word}
\index{shu-cpp-is-keyword} \hfill [Function]

\begin{doc-string}
Doc string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-keywords }}
\usebox{\funcname}
\index{shu-cpp-keywords} \hfill [Constant]

\begin{doc-string}
alist of C++ key words up to approximately C++20
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-keywords-hash }}
\usebox{\funcname}
\index{shu-cpp-keywords-hash} \hfill [Variable]

\begin{doc-string}
The hash table of C++ key words
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-long-long-type }}
\usebox{\funcname}
\index{shu-cpp-long-long-type} \hfill [Custom]

\begin{doc-string}
The data type that represents a 64 bit integer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-date }}
\usebox{\funcname}
\index{shu-cpp-make-date} \hfill [Command]

\begin{doc-string}
insert a string that is the list of values to be passed to the constructor of
 a date type that accepts year, month, day.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-datetime }}
\usebox{\funcname}
\index{shu-cpp-make-datetime} \hfill [Command]\\%
 (Alias: make-datetime)

\begin{doc-string}
insert a string that is the list of values to be passed to the constructor of
 a datetime type that accepts year, month, day, hour, minute, second,
 milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-interval }}
\usebox{\funcname}
\index{shu-cpp-make-interval} \hfill [Command]\\%
 (Alias: make-interval)

\begin{doc-string}
insert a string that is the list of values to be passed to the constructor of a datetime
 type that accepts year, month, day, hour, minute, second, milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-short-interval }}
\usebox{\funcname}
\index{shu-cpp-make-short-interval} \hfill [Command]

\begin{doc-string}
insert a string that is the list of values to be passed to the constructor of a datetime
 type that accepts year, month, day, hour, minute, second, milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-size-type }}
\usebox{\funcname}
\index{shu-cpp-make-size-type} \hfill [Function]

\begin{doc-string}
insert a string that is a possible value for a size type.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-time }}
\usebox{\funcname}
\index{shu-cpp-make-time} \hfill [Command]

\begin{doc-string}
insert a string that is the list of values to be passed to the constructor of
a time type that accepts hour, minute, second,  milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-map-class-to-include }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-map-class-to-include} \hfill [Function]

\begin{doc-string}
\emph{class-name} is a fully qualified class name (std::string as an example).  This
function returns the name of the include file that defines the class, if known.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-member-prefix }}
\usebox{\funcname}
\index{shu-cpp-member-prefix} \hfill [Variable]

\begin{doc-string}
The character string that is used as the prefix to member variables of a C++ class.
This is used by shu-internal-get-set when generating getters and setters for a class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-qualify-classes }}
\usebox{\funcname}\emph{class-list} \emph{namespace}
\index{shu-cpp-qualify-classes} \hfill [Function]
\hspace*{\wd\funcname}\emph{buffer}

\begin{doc-string}
Repeatedly call \emph{shu-qualify-class-name} for all class names in \emph{class-list}.
\emph{namespace} is either the name of a single namespace to apply to all classes
in \emph{class-list} or is a list of namespaces each of which has a one to one
correspondence with a class name in \emph{class-list}.  The optional \emph{buffer}
argument may be a buffer in which the actions are recorded.  Return the
number of names changed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-rmv-blocked }}
\usebox{\funcname}\emph{class-list} \emph{top-name} \emph{gb}
\index{shu-cpp-rmv-blocked} \hfill [Function]

\begin{doc-string}
Do a pre-check on a file to see if we will be able to remove its ``using
namespace'' directives.  \emph{class-list} is the a-list passed to \emph{shu-cpp-rmv-using}.
USING is the regular expression used to search for ``using namespace''
directives.  TOP-QUAL is the regular expression used to strip out a higher level
qualifier from the class name in a ``using namespace'' directive, if any.  \emph{gb} is
the buffer into which diagnostic messages are written.

This function finds all of the ``using namespace'' directives in the file and
checks to see if there is any ambiguity in the resulting class list.  For
example, if namespace ``mumble'' contains class ``Bumble'' and namespace
``stubble'' also contains class ``Bumble'', we will not know which namespace to
apply to instances of class ``Bumble''.  But this is not an ambiguity if there
is a ``using namespace'' directive for only one of those classes.  That is why
we do the ambiguity check only for namespaces referenced by ``using namespace''
directives.

This function returns true if such an ambiguity exists.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-rmv-using-old }}
\usebox{\funcname}\emph{class-list} \textbf{\&optional}
\index{shu-cpp-rmv-using-old} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Remove ``using namespace'' directives from a C++ file, adding the appropriate
namespace qualifier to all of the unqualified class names.  \emph{class-list} is an
a-list in which the car of each entry is a namespace and the cdr of each entry
is a list of class names.  Here is an example of such an a-list:

\small{\begin{verbatim}
     (list
      (cons ``std''    (list ``set'' ``string'' ``vector''))
      (cons ``world''  (list ``Hello'' ``Goodbye'')))
\end{verbatim}}

\emph{top-name}, if present is a higher level namespace.  Given a top level namespace
of ``WhammoCorp'', then the following line:

\small{\begin{verbatim}
     using namespace WhammoCorp::world;
\end{verbatim}}

would be interpreted as though it had been written:

\small{\begin{verbatim}
     using namespace world;
\end{verbatim}}

NB: This version is deprecated.  See the new version in shu-match.el
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-short-interval-type }}
\usebox{\funcname}
\index{shu-cpp-short-interval-type} \hfill [Custom]

\begin{doc-string}
The data type that represents a short time interval type.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-sitting-on-keyword }}
\usebox{\funcname}
\index{shu-cpp-sitting-on-keyword} \hfill [Function]

\begin{doc-string}
If (point) is sitting on a C++ key word, return that key word, else return
 nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-size-type }}
\usebox{\funcname}
\index{shu-cpp-size-type} \hfill [Custom]

\begin{doc-string}
The data type that represents a size.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-string-type }}
\usebox{\funcname}
\index{shu-cpp-string-type} \hfill [Custom]

\begin{doc-string}
The data type that represents a string type.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-time-type }}
\usebox{\funcname}
\index{shu-cpp-time-type} \hfill [Custom]

\begin{doc-string}
The data type that represents a time.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-tz-make-datetime }}
\usebox{\funcname}
\index{shu-cpp-tz-make-datetime} \hfill [Command]\\%
 (Alias: make-tzdate)

\begin{doc-string}
insert a string that is the list of values to be passed to the constructor of
 a datetime type that accepts year, month, day, hour, minute, second,
 milliseconds, microseconds.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp1-class }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp1-class} \hfill [Command]\\%
 (Alias: cpp1-class)

\begin{doc-string}
Place a skeleton class definition in the current buffer at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp2-class }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp2-class} \hfill [Command]\\%
 (Alias: cpp2-class)

\begin{doc-string}
Place a skeleton class definition in the current buffer at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-creplace }}
\usebox{\funcname}\emph{prefix}
\index{shu-creplace} \hfill [Command]\\%
 (Alias: creplace)

\begin{doc-string}
This function will replace the C++ string in which point is placed with the
C++ string in the kill ring.  The C++ string in the kill ring is expected to be
a single string with or without quotes.  The C++ string in which point is placed
may have been split into smaller substrings in order to avoid long lines.

Assume you have the sample string that is shown in \emph{shu-csplit}

\small{\begin{verbatim}
     static const std::string x(``This is a very long line of text that looks ``
                                ``as though it will go on forever.'');
\end{verbatim}}

You wish to replace it with a slightly different line of text, perhaps something
that came from the output of a program.  Copy the new string into the kill ring.
Then put the cursor into any part of any line of the string to be replaced
and invoke this function.  This function will remove the old string, replace it
with the contents of the string in the kill ring, and then split it up into
shorter lines as in the following example.  The string in the kill ring may have
opening and closing quotes or not.

\small{\begin{verbatim}
     static const std::string x(``This is a very long line of text that looks ``
                                ``as though it will go on forever and probably ``
                                ``already has done so or is threatening to do ``
                                ``so.'');
\end{verbatim}}

This is especially useful if you have a a string constant in a unit test and you
have modified the code that creates the string.  gtest will complain that the
expected string did not match the actual string.  If the actual string is
correct, copy it into the kill ring, go into your unit test, find the old
string, place the cursor in the old string, and replace it with the new.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-csplit }}
\usebox{\funcname}\emph{prefix}
\index{shu-csplit} \hfill [Command]\\%
 (Alias: csplit)

\begin{doc-string}
Split a C++ string into multiple strings in order to keep the line length
below a certain minimum length..  The line length used is defined by the custom
variable \emph{shu-cpp-line-end}.

For example, you may copy a very long line of text into a section of code as
follows:

\small{\begin{verbatim}
     static const std::string x(``This is a very long line of text that looks as though it will go on forever.'');
\end{verbatim}}

To be polite to future code readers, you want to split this into multiple lines.
This can be a bit cumbersome if the text is very long.  This function splits the
text at a somewhat arbitrary boundary so that it can be read by others whose
text editors do not show code much beyond column 80 or so.  This is an example
of the above line after csplit was invoked:

\small{\begin{verbatim}
     static const std::string x(``This is a very long line of text that looks ``
                                ``as though it will go on forever.'');
\end{verbatim}}

This function normally splits lines on a word boundary.  If any prefix argument
is present, the split will be composed of fixed length lines with no respect to
word boundaries.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cunsplit }}
\usebox{\funcname}
\index{shu-cunsplit} \hfill [Command]\\%
 (Alias: cunsplit)

\begin{doc-string}
The beginnings of a re-write of \emph{shu-cunsplit}.
Needs more testing.
Undo the split that was done by csplit.  Place the cursor anywhere
in any of the strings and invoke this function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cwhile }}
\usebox{\funcname}
\index{shu-cwhile} \hfill [Command]\\%
 (Alias: cwhile)

\begin{doc-string}
Insert an empty while statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dbx-summarize-malloc }}
\usebox{\funcname}
\index{shu-dbx-summarize-malloc} \hfill [Command]\\%
 (Alias: dbx-malloc)

\begin{doc-string}
Go through the output of a dbx malloc dump and generate a summary.  dbx is
the AIX debugger.  It has a malloc command that goes through the heap and prints
one line for every allocated buffer.  Here is a sample of some of its output:

\small{\begin{verbatim}
         ADDRESS         SIZE HEAP    ALLOCATOR
      0x30635678          680    0     YORKTOWN
      0x30635928          680    0     YORKTOWN
      0x30635bd8          680    0    HEAPCACHE
      0x30635bcf          680    0     YORKTOWN
\end{verbatim}}

YORKTOWN is the name of the default allocator on AIX.  This function goes
through the malloc output and gets the number and sizes of all buffers
allocated.  This tells you how many buffers were allocated, the total number of
bytes allocated, and the total number of buffers allocated by size.  The output
is placed in a separate buffer called \emph\{**shu-aix-malloc**.\}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dcc }}
\usebox{\funcname}
\index{shu-dcc} \hfill [Command]\\%
 (Alias: dcc)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dce }}
\usebox{\funcname}
\index{shu-dce} \hfill [Command]\\%
 (Alias: dce)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dciterate }}
\usebox{\funcname}\emph{type-name} \emph{var-name-1} \emph{var-name-2}
\index{shu-dciterate} \hfill [Command]\\%
 (Alias: dciterate)

\begin{doc-string}
Insert the code to iterate through a pair of data structures of type
\emph{type-name}, whose first instance is identified by \emph{var-name-1} and whose second
instance is identified by \emph{var-name-2}.

The first prompt reads the type name, second and third prompts read the two
variable names.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (std::pair<type-name::const_iterator,
                     type-name::const_iterator>
               its(var-name-1.begin(), var-name-2.begin());
           its.first != var-name-1.end() \&\& its.second != var-name-2.end();
           ++its.first, ++its.second)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.

The name of the namespace used for the standard library is defined in the custom
variable shu-cpp-std-namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-diterate }}
\usebox{\funcname}\emph{type-name} \emph{var-name-1} \emph{var-name-2}
\index{shu-diterate} \hfill [Command]\\%
 (Alias: diterate)

\begin{doc-string}
Insert the code to iterate through a pair of data structures of type
\emph{type-name}, whose first instance is identified by \emph{var-name-1} and whose second
instance is identified by \emph{var-name-2}.

The first prompt reads the type name, second and third prompts read the two
variable names.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (std::pair<type-name::iterator,
                     type-name::iterator>
               its(var-name-1.begin(), var-name-2.begin());
           its.first != var-name-1.end() \&\& its.second != var-name-2.end();
           ++its.first, ++its.second)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.

The name of the namespace used for the standard library is defined in the custom
variable shu-cpp-std-namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dox-brief }}
\usebox{\funcname}
\index{shu-dox-brief} \hfill [Command]\\%
 (Alias: dox-brief)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dox-cbt }}
\usebox{\funcname}
\index{shu-dox-cbt} \hfill [Command]\\%
 (Alias: dox-cbt)

\begin{doc-string}
Convert a section of comments delimited by //! into Doxygen brief format.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dox-cvt }}
\usebox{\funcname}
\index{shu-dox-cvt} \hfill [Command]\\%
 (Alias: dox-cvt)

\begin{doc-string}
Convert a section of comments delimited by // into Doxygen format.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dox-hdr }}
\usebox{\funcname}
\index{shu-dox-hdr} \hfill [Command]

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dox2-hdr }}
\usebox{\funcname}
\index{shu-dox2-hdr} \hfill [Command]\\%
 (Alias: dox2-hdr)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-drc }}
\usebox{\funcname}
\index{shu-drc} \hfill [Command]\\%
 (Alias: drc)

\begin{doc-string}
Place a skeleton Doxygen header definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-emit-get }}
\usebox{\funcname}
\index{shu-emit-get} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-emit-set }}
\usebox{\funcname}\emph{arg}
\index{shu-emit-set} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gcc }}
\usebox{\funcname}
\index{shu-gcc} \hfill [Command]\\%
 (Alias: gcc)

\begin{doc-string}
Get compile command command from current buffer.  While in a compile buffer,
go to the top of the buffer, search for the end of the prompt line, collect the
rest of the line and put it into the kill ring.  This takes the string that was
used for the last compile command in the current buffer and puts it into the
kill ring.  To compile again with the same command, kill the buffer, open a new
shell, and yank.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gen-return-ptr }}
\usebox{\funcname}
\index{shu-gen-return-ptr} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-cpp-keywords-hash }}
\usebox{\funcname}
\index{shu-get-cpp-keywords-hash} \hfill [Function]

\begin{doc-string}
Return a hash table containing all of the C++ key words.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-set }}
\usebox{\funcname}
\index{shu-get-set} \hfill [Command]\\%
 (Alias: get-set)

\begin{doc-string}
Generate get and set functions for an instance variable in a C++ class.
Position the cursor ahead of the Doxygen comment above the variable.  The get
and set functions will be placed in the buffer \emph\{*get-set*.\}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-getters }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-getters} \hfill [Command]\\%
 (Alias: getters)

\begin{doc-string}
Mark a region in a file that contains C++ instance variable declarations.
This function will create get and set functions for all of the instance
variables.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-ginclude }}
\usebox{\funcname}
\index{shu-ginclude} \hfill [Command]\\%
 (Alias: ginclude)

\begin{doc-string}
While in a file buffer, wrap the file name in a C++ include directive and
put it in the kill ring.  The file name is delimited by double quotes unless
\emph{shu-cpp-include-user-brackets} variable is true, in which case the file name
is delimited by left and right angle brackets.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-interactive-qualify-class-name }}
\usebox{\funcname}
\index{shu-interactive-qualify-class-name} \hfill [Command]\\%
 (Alias: qualify-class)

\begin{doc-string}
Interactively call \emph{shu-qualify-class-name} to find all instances of a class name and
add a namespace qualifier to it.  First prompt is for the class name.  If a fully qualified
class name is supplied, then the given namespace is applied to the class name.  If the name
supplied is not a namespace qualified class name, then a second prompt is given to read the
namespace.
This is intended to help rescue code that has one or more ``using namespace''
directives in it.  The problem with ``using namespace'' is that you now have
class names from other namespaces with no easy way to identify the namespace
to which they belong.  The best thing to do is get rid of the ``using
namespace'' statements and explicitly qualify the class names.  But if you
use a simple replace to do that, you will qualify variable names that resemble
class names as well as class names that are already qualified.  This function
only adds a namespace to a class name that does not already have a namespace
qualifier.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-citerate }}
\usebox{\funcname}\emph{type-name} \emph{var-name} \textbf{\&optional}
\index{shu-internal-citerate} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Insert the code to iterate through a data structure of type \emph{type-name} whose
instance is identified by \emph{var-name}.  First prompt reads the variable name.
Second prompt read the variable name.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (type_name::iterator it = var_name.begin();
           it != var_name.end(); ++it)
      {
      }
\end{verbatim}}

If optional \emph{const} is true, a const iterator is generated.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-cpp2-class }}
\usebox{\funcname}\emph{class-name}
\index{shu-internal-cpp2-class} \hfill [Function]

\begin{doc-string}
Place a skeleton class definition in the current buffer at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-creplace }}
\usebox{\funcname}\textbf{\&optional} \emph{fixed-width}
\index{shu-internal-creplace} \hfill [Function]

\begin{doc-string}
This is the internal implementation of \emph{shu-creplace}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-csplit }}
\usebox{\funcname}\textbf{\&optional} \emph{fixed-width}
\index{shu-internal-csplit} \hfill [Function]

\begin{doc-string}
This is the internal implementation of \emph{shu-csplit}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-double-citerate }}
\usebox{\funcname}\emph{type-name-1}
\index{shu-internal-double-citerate} \hfill [Function]
\hspace*{\wd\funcname}\emph{var-name-1} \emph{var-name-2}
\hspace*{\wd\funcname}\emph{const}

\begin{doc-string}
Insert the code to iterate through a pair of data structures of types
\emph{type-name-1} and \emph{type-name-2}, whose first instance is identified by \emph{var-name-1}
and whose second instance is identified by \emph{var-name-2}.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (std::pair<type-name-1::const_iterator,
                     type-name-2::const_iterator>
               its(var-name-1.begin(), var-name-2.begin());
           its.first != var-name-1.end() \&\& its.second != var-name-2.end();
           ++its.first, ++its.second)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.

The name of the namespace used for the standard library is defined in the custom
variable shu-cpp-std-namespace.

If optional \emph{const} is true, a const iterator is generated.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-get-set }}
\usebox{\funcname}\emph{comment} \emph{shu-lc-comment}
\index{shu-internal-get-set} \hfill [Command]

\begin{doc-string}
Generate get and set functions for an instance variable in a C++ class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-replace-class-name }}
\usebox{\funcname}\emph{target-name}
\index{shu-internal-replace-class-name} \hfill [Function]
\hspace*{\wd\funcname}\emph{replace-arg}
\hspace*{\wd\funcname}\emph{in-string}
\hspace*{\wd\funcname}

\begin{doc-string}
Find all instances of the class name \emph{target-name} and if it actually appears
to be a class name, call REPLACE-FUN passing to it \emph{replace-arg} and the class
name.  REPLACE-FUN issues the appropriate replace-match call, constructing the
replacement for the class name from some combination of \emph{replace-arg} and the
class name.  \emph{in-string} is true if a class name inside of a string is to be
replaced.  \emph{in-comment} is true if a class name inside of a comment is to be
replaced.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-sort-includes }}
\usebox{\funcname}\emph{pl}
\index{shu-internal-sort-includes} \hfill [Function]

\begin{doc-string}
There are times when \emph{shu-sub-sort-includes} does not actually change anything
in the buffer.  After it has done its transformation and sorting, nothing in the
\#include block has changed because the \#includes were already in sorted order.
But emacs still marks the buffer as modified, which can be confusing.

This function copies the include block into a temporary buffer, calls
\emph{shu-sub-sort-includes}, checks to see if the temporary buffer contents are
unchanged.  If the temporary buffer contents remain unchanged, then
\emph{shu-sub-sort-includes} is not called at all on the real buffer and its sort and
delete counts are set to zero.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-is-const }}
\usebox{\funcname}
\index{shu-is-const} \hfill [Variable]

\begin{doc-string}
Set true if the C++ data member we are working is declared to be const.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-is-keyword }}
\usebox{\funcname}
\index{shu-is-keyword} \hfill [Command]\\%
 (Alias: is-keyword)

\begin{doc-string}
Do a COMPLETING-READ from the minibuffer of a string that may or may not be a
C++ key word.  If the string is a C++ key word, display the key word, else
display ``no''.  If (point) is sitting on a C++ key word, that is the default
initial input to the completing read.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-lc-comment }}
\usebox{\funcname}
\index{shu-lc-comment} \hfill [Variable]

\begin{doc-string}
Comment string with the first letter downcased.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-include-block }}
\usebox{\funcname}\emph{first-line} \textbf{\&optional}
\index{shu-make-include-block} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{first-line} is a cons cell that holds the point and line of an \#include
directive.  \emph{last-line} optionally holds the point and line of another \#include
directive.  \emph{first-line} and \emph{last-line} may be in any order.  This function returns
a cons cell whose car holds the point of the start of the first \#include
directive and whose cdr holds the point of the end of the last \#include.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-padded-line }}
\usebox{\funcname}\emph{line} \emph{tlen}
\index{shu-make-padded-line} \hfill [Function]

\begin{doc-string}
Add sufficient spaces to make \emph{line} the length \emph{tlen}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-sort-announcement }}
\usebox{\funcname}\emph{ret-val} \textbf{\&optional}
\index{shu-make-sort-announcement} \hfill [Function]
\hspace*{\wd\funcname}\emph{changed-group-count}

\begin{doc-string}
\emph{ret-val} is a cons cell whose car is the count of lines sorted by
\emph{shu-internal-sort-includes} and whose cdr is the number of duplicate lines
removed.  The optional \emph{group-count} is the number of groups sorted, if present.
The optional \emph{changed-group-count} is the number of groups that were actually
changed.  Return an appropriately formatted message with these counts.  This is
a separate function in order to allow it to be unit tested.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nc-vtype }}
\usebox{\funcname}
\index{shu-nc-vtype} \hfill [Variable]

\begin{doc-string}
Set true if the C++ data member we are working is declared to be non-const.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-c-class }}
\usebox{\funcname}
\index{shu-new-c-class} \hfill [Command]\\%
 (Alias: new-c-class)

\begin{doc-string}
Place a skeleton class definition in the current buffer at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-c-file }}
\usebox{\funcname}
\index{shu-new-c-file} \hfill [Command]\\%
 (Alias: new-c-file)

\begin{doc-string}
Generate a skeleton code file for a C or C++ file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-deallocate }}
\usebox{\funcname}\emph{var-name}
\index{shu-new-deallocate} \hfill [Command]

\begin{doc-string}
Insert the code to do a standard deallocation of memory allocated by a
specific allocator.  First prompt reads the variable name that points to the
memory to be deallocated.  Second prompt reads the name of the class whose
destructor is to be called.

This generates a code sequence as follows:

\small{\begin{verbatim}
        if (var-name)
        {
            m_allocator->deleteObject(var-name);
            var-name = 0;
        }
\end{verbatim}}

If \emph{shu-cpp-modern} is true, the code sequence is:

\small{\begin{verbatim}
        if (var-name != nullptr)
        {
            m_allocator->deleteObject(var-name);
            var-name = nullptr;
        }
\end{verbatim}}

\emph{var-name} is read from a prompt.  The number of spaces to indent inside that
braces is defined in the custom variable shu-cpp-indent-length.  The name of the
member variable that points to the allocator in use by the class comes from the
custom variable shu-cpp-default-allocator-name
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-h-file }}
\usebox{\funcname}
\index{shu-new-h-file} \hfill [Command]\\%
 (Alias: new-h-file)

\begin{doc-string}
Generate a skeleton header file for C or C++ file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-x-file }}
\usebox{\funcname}
\index{shu-new-x-file} \hfill [Command]\\%
 (Alias: new-x-file)

\begin{doc-string}
Generate a skeleton Doxygen \\file directive.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-operators }}
\usebox{\funcname}\emph{class-name}
\index{shu-operators} \hfill [Command]\\%
 (Alias: operators)

\begin{doc-string}
Place skeletons of all of the standard c++ operator functions at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-qualify-class-fun }}
\usebox{\funcname}\emph{namespace} \emph{name}
\index{shu-qualify-class-fun} \hfill [Function]

\begin{doc-string}
This is the replacement function for \emph{shu-qualify-class-name}.  It is called
with the \emph{namespace} to be applied to the class whose name is \emph{name}.  It
constructs a new name and issues replace-match to replace it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-qualify-class-name }}
\usebox{\funcname}\emph{target-name} \emph{namespace}
\index{shu-qualify-class-name} \hfill [Function]

\begin{doc-string}
Find all instances of the class name \emph{target-name} and add an explicit namespace
qualifier \emph{namespace}.  If the \emph{target-name} is ``Mumble'' and the \emph{namespace} is
``abcd'', then ``Mumble'' becomes ``abcd::Mumble''.  But variable names such
as ``d\_Mumble'' or ``MumbleIn'' remain unchanged and already qualified class
names remain unchanged.
This is intended to help rescue code that has one or more ``using namespace''
directives in it.  The problem with ``using namespace'' is that you now have
class names from other namespaces with no easy way to identify the namespace
to which they belong.  The best thing to do is get rid of the ``using
namespace'' statements and explicitly qualify the class names.  But if you
use a simple replace to do that, you will qualify variable names that resemble
class names as well as class names that are already qualified.  This function
only adds a namespace to a class name that does not already have a namespace
qualifier.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-qualify-namespace-bsl }}
\usebox{\funcname}
\index{shu-qualify-namespace-bsl} \hfill [Command]\\%
 (Alias: qualify-bsl)

\begin{doc-string}
Add ``bsl'' namespace qualifier to some of the classes in ``bsl''.  Return the
count of class names changed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-qualify-namespace-std }}
\usebox{\funcname}
\index{shu-qualify-namespace-std} \hfill [Command]\\%
 (Alias: qualify-std)

\begin{doc-string}
Add ``std'' namespace qualifier to some of the classes in ``std''.  Return the
count of class names changed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-replace-class-fun }}
\usebox{\funcname}\emph{new-name} \emph{name}
\index{shu-replace-class-fun} \hfill [Function]

\begin{doc-string}
This is the replacement function for \emph{shu-replace-class-name}.  It is called
with the \emph{new-name} to replace the class \emph{name}.  It calls replace-match to replace
\emph{name} with \emph{new-name}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-replace-class-name }}
\usebox{\funcname}\emph{target-name} \emph{new-name}
\index{shu-replace-class-name} \hfill [Function]
\hspace*{\wd\funcname}\emph{in-string} \emph{in-comment}

\begin{doc-string}
Find all instances of the class name \emph{target-name} and replace it with the name
\emph{new-name}.  If the target name is ``Mumble'', then all instances of ``Mumble''
that resemble class names are replaced.  But names such as ``d\_Mumble'' or
``MumbleIn'' remain unchanged.  if \emph{in-string} is true, then instances of the
class name found inside a string are replaced.  if \emph{in-comment} is true, then
instances of the class name found inside a comment are replaced.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-return-ptr }}
\usebox{\funcname}
\index{shu-return-ptr} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-return-ref }}
\usebox{\funcname}
\index{shu-return-ref} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-rmv-classes }}
\usebox{\funcname}
\index{shu-rmv-classes} \hfill [Variable]

\begin{doc-string}
An alist of ``using namespace'' directives and their line numbers where first declared.
Used to filter duplicates.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-s-mode-find-long-line }}
\usebox{\funcname}
\index{shu-s-mode-find-long-line} \hfill [Command]

\begin{doc-string}
Place point in column 79 of the next line whose length exceeds 79 characters.
No movement occurs if no lines, starting with the current position, exceed 79
characters in length.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-author }}
\usebox{\funcname}\emph{name}
\index{shu-set-author} \hfill [Command]

\begin{doc-string}
Set the author name to be placed in generated C++ classes.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-default-global-namespace }}
\usebox{\funcname}\emph{name}
\index{shu-set-default-global-namespace} \hfill [Command]

\begin{doc-string}
Set the global namespace for C++ classes.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-default-namespace }}
\usebox{\funcname}\emph{name}
\index{shu-set-default-namespace} \hfill [Command]\\%
 (Alias: set-default-namespace)

\begin{doc-string}
Set the local namespace for C++ classes.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-modern }}
\usebox{\funcname}
\index{shu-set-modern} \hfill [Command]\\%
 (Alias: set-modern)

\begin{doc-string}
Unconditionally set shu-cpp-modern to true.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-no-modern }}
\usebox{\funcname}
\index{shu-set-no-modern} \hfill [Command]\\%
 (Alias: set-no-modern)

\begin{doc-string}
Unconditionally set shu-cpp-modern to false.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-obj }}
\usebox{\funcname}
\index{shu-set-obj} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-ptr }}
\usebox{\funcname}
\index{shu-set-ptr} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-simple-hother-file }}
\usebox{\funcname}
\index{shu-simple-hother-file} \hfill [Function]

\begin{doc-string}
Return the name of the .h file that corresponds to the .cpp file or .t.cpp file
that is in the current buffer.  This version of the function creates the name of
the .h file from the name of the file in the current buffer.  This is in contrast
with the function shu-hother which finds the corresponding .h file from the list
of files in the current project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-sort-all-includes }}
\usebox{\funcname}
\index{shu-sort-all-includes} \hfill [Command]\\%
 (Alias: sort-all-includes)

\begin{doc-string}
Sort each contiguous block of \#include directives in the entire buffer.  This
is similar to \emph{shu-sort-includes} but instead of restricting the sort to the
current block of contiguous \#include directives, it finds all of the blocks of
contiguous \#include directives and sorts each block.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-sort-includes }}
\usebox{\funcname}
\index{shu-sort-includes} \hfill [Command]\\%
 (Alias: sort-includes)

\begin{doc-string}
When positioned on a line that is an \#include directive, find all of the
\#include directives above and below that line that are not separated by a line
that is not an \#include directive and sort them into alphabetical order with
case ignored.  If not positioned on a line that is an \#include directive, do
nothing.  The return value is the number of lines sorted.  If no lines were
sorted because (point) is not positioned on an \#include directive, return nil.
The return value is for the benefit of the unit tests.  Additionally, if there
are spaces surrounding the ``\#'' of the \#include, they are removed.  After the
sort, any duplicate \#include directives are removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-std-include-list }}
\usebox{\funcname}
\index{shu-std-include-list} \hfill [Constant]

\begin{doc-string}
An alist that maps include file names to class names.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-sub-sort-includes }}
\usebox{\funcname}\emph{pl}
\index{shu-sub-sort-includes} \hfill [Function]

\begin{doc-string}
\emph{pl} is a cons cell that defines the start and end position of a block one or
more contiguous \#include directives.  Any lines that have extra spacing in them,
such as `` \# include `` have the extra spacing removed and then the entire block
is sorted into alphabetical order with any duplicate lines removed.  The return
value is a cons cell whose car holds the number of lines sorted and whose cdr
holds the number of duplicates removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-tciterate }}
\usebox{\funcname}\emph{type-name-1} \emph{type-name-2} \emph{var-name-1}
\index{shu-tciterate} \hfill [Command]
\hspace*{\wd\funcname}\\%
 (Alias: tciterate)

\begin{doc-string}
Insert the code to iterate through a pair of data structures of types
\emph{type-name-1} and \emph{type-name-2}, whose first instance is identified by \emph{var-name-1}
and whose second instance is identified by \emph{var-name-2}.

The first two prompt reads the two type names, third and fourth prompts read the
two variable names.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (std::pair<type-name-1::const_iterator,
                     type-name-2::const_iterator>
               its(var-name-1.begin(), var-name-2.begin());
           its.first != var-name-1.end() \&\& its.second != var-name-2.end();
           ++its.first, ++its.second)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.

The name of the namespace used for the standard library is defined in the custom
variable shu-cpp-std-namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-titerate }}
\usebox{\funcname}\emph{type-name-1} \emph{type-name-2} \emph{var-name-1}
\index{shu-titerate} \hfill [Command]
\hspace*{\wd\funcname}\\%
 (Alias: titerate)

\begin{doc-string}
Insert the code to iterate through a pair of data structures of types
\emph{type-name-1} and \emph{type-name-2}, whose first instance is identified by \emph{var-name-1}
and whose second instance is identified by \emph{var-name-2}.

The first two prompt reads the two type names, third and fourth prompts read the
two variable names.

The generated code sequence is as follows:

\small{\begin{verbatim}
      for (std::pair<type-name-1::iterator,
                     type-name-2::iterator>
               its(var-name-1.begin(), var-name-2.begin());
           its.first != var-name-1.end() \&\& its.second != var-name-2.end();
           ++its.first, ++its.second)
      {
      }
\end{verbatim}}

The number of spaces to indent inside the braces is defined in the custom
variable shu-cpp-indent-length.

The name of the namespace used for the standard library is defined in the custom
variable shu-cpp-std-namespace.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-to-camel }}
\usebox{\funcname}
\index{shu-to-camel} \hfill [Command]\\%
 (Alias: to-camel)

\begin{doc-string}
Convert the variable name at point from snake case to camel case.

For example, ``mumble\_something\_other'' becomes ``mumbleSomethingOther''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-to-snake }}
\usebox{\funcname}
\index{shu-to-snake} \hfill [Command]\\%
 (Alias: to-snake)

\begin{doc-string}
Convert the variable name at point from camel case to snake case.

For example, ``mumbleSomethingOther'' becomes ``mumble\_something\_other''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-var-name }}
\usebox{\funcname}
\index{shu-var-name} \hfill [Variable]

\begin{doc-string}
The variable name that corresponds to an attribute name.
\end{doc-string}

\eject
\section{shu-cpp-match}


Functions to match patterns against list of tokens produced by
shu-cpp-token.el.


The functions in shu-cpp-token.el can scan a section of C++ source code and
turn it into a list of tokens.  Each token has a type (comment, string,
keyword, operator or unquoted token) and a value, which is the token itself.
Each token also contains its start and end position within the file.

The functions in this file, shu-cpp-match.el, allow one to use data
structures to describe patterns to be found in a list of tokens.

The simplest data structure consists of a list of match items that must
exactly match a list of tokens.  If you want to find something that looks
like

\small{\begin{verbatim}
      pointer->thing
\end{verbatim}}

you put together a list of three match items.  The first specifies a regular
expression that can match a C++ name.  The second is an exact match for the
operator "-$>$", and the third is another regular expression that can match a
C++ name.

You can also search for more than one pattern at a time by supplying a list
of lists of match items.  Suppose you want to search for an occurrence of a
"using namespace" directive.  You might have one list that matches "using
namespace name;", another list that matches "using namespace ::name;", and
another list that matches "using namespace component::name";.

If you try to match this set of three lists against the following string

\small{\begin{verbatim}
      using namespace thing::Bob;
\end{verbatim}}

The three lists are evaluated as follows:

The first list matches "using," "namespace," "thing," but fails when it does
not find a semi-colon following "thing."

The second list matches "using," "namespace," but fails when it does not find
an operator "::".

The third list matches "using," "namespace," "thing," "::," "Bob," and ";".

With one function call, you have found a reasonably complex pattern.  The
tokens scanned do not include comments.  This means that the above example
would have worked identically on a list of tokens derived from

\small{\begin{verbatim}
      using /* Hello \emph{*/} namespace
      // Something here
      thing /* How are you? \emph{*/} :: Bob ;
\end{verbatim}}

A list of match items can also include a side list.  A side list is another
list of match items that is to be matched.  There are different types of side
lists.  One of them is a repeating side list.  A repeating side list matches
zero or more occurrences of a list.

In the above example, we matched the name thing::Bob by having three match
items.  But what if we want to match an arbitrary nesting of namespaces, such
as

\small{\begin{verbatim}
      thing::Bob::Fred::Ted
\end{verbatim}}

One way to do this is with a repeating side list.

This list of tokens above could be matched by a single match item followed by
a repeating side list.  The first item in the list is a regular expression
match for a C++ name.  The second item in the list is a repeating side list,
which contains two items, the first of which is an exact match for operator
"::", and the second of which is a regular expression that matches a C++
name.

The match would work as follows:

The first match item would match "thing".  Then the repeating side list would
match "::," "Bob," "::," "Fred," "::," and "Ted."

On return from a successful match, how do you know what was matched?  Each
match item can specify that when the item is matched, the matched item is to
be added to a list of items to be returned to the caller.

Let us return to our original example in which we had three lists, the last
of which finally matched.

\small{\begin{verbatim}
                *       *     *
      using namespace thing::Bob
\end{verbatim}}

An asterisk has been placed over each item that is marked to be returned to
the caller.  At the end of the match, the matching function would return the
list

\small{\begin{verbatim}
      namespace
      thing
      Bob
\end{verbatim}}

Now the caller knows what was matched and has a copy of the matched tokens.

In our example of matching a nested namespace name, the function might return

\small{\begin{verbatim}
      thing
      Bob
      Fred
      Ted
\end{verbatim}}

Now the caller can tell from the length of the list, how deeply nested the
namespace name is.

Note that since the matched tokens are pushed onto the list, the list is
actually returned in reverse order, which the caller can reverse with
nreverse.

Each matching function also accepts a return list to which it will add newly
matched items.  The caller can then match several patterns that build up an
ever expanding return list of tokens.  Only the caller knows when it makes
sense to reverse the list and to then start processing the reversed list.

A final example is the list of match items that is actually used elsewhere to
find occurrences of using namespace directives.  It uses another type of side
list, which is a list of lists.  This is an illustration of that match
structure:



\small{\begin{verbatim}
                                  using
                                    |
                                    V
                                namespace
                                    |
                                    |
          +-------------------------+-------------------------+
          |                         |                         |
          |                         |                         |
          V                         V                         V
        <name>                     ::                       <name>
          |                         |                         |
          |                         |                         |
          |                         V                         V
          |                       <name>           loop of :: followed by <name>
          |                         |                         |
          |                         |                         |
          V                         V                         V
          ;                         ;                         ;
\end{verbatim}}

This is how the above match structure would match

\small{\begin{verbatim}
      using namespace thing::Bob::Ted;
\end{verbatim}}

The first two tokens "using" and "namespace" are matched exactly.  The we
come to three lists to be evaluated.  The first one matches "thing" but fails
to match the ";".  The second fails trying to match "::".  The third matches
"thing" and then the repeating side list matches "::," "Bob", "::," and
"Ted."  The repeating side list stops the matching when it encounters the
terminating semi-colon, and then the next match item in the list matches the
terminating semi-colon.

The returned list would be

\small{\begin{verbatim}
      using
      namespace
      thing
      Bob
      Ted
\end{verbatim}}

You can look in the unit tests and in other code that uses the matching code
here for more examples of the power of match lists.



Here is an example taken from shu-match.el.  This match list is used to find
all forms of the using statement, including

\small{\begin{verbatim}
     using namespace name;
     using namespace ::name;
     using namespace name::name;
     using name;
     using name::name;
\end{verbatim}}

The actual data structures that define this match list are found in
shu-match.el in the constant shu-cpp-match-using-list-single, which is used by
the function shu-match-find-all-using-internal, which returns all statements
in the above form with one pass through the token list.






\small{\begin{verbatim}
                                                           using
                                                             |
                                                             |
                                 +---------------------------+----------------------+
                                 |                                                  |
                                 |                                                  |
                                 V                                                  |
                             namespace                                              |
                                 |                                                  |
                                 |                                                  |
       +-------------------------+-------------------------+                        |
       |                         |                         |                        |
       |                         |                         |                        |
       V                         V                         V                        |
     <name>                     ::                       <name>                     |
       |                         |                         |                        |
       |                         |                         |                        |
       |                         V                         V                        |
       |                       <name>           loop of :: followed by <name>       |
       |                         |                         |                        |
       |                         |                         |                        |
       V                         V                         V                        |
       ;                         ;                         ;                        |
                                                                                    |
                                                                                    |
                                                                                    |
                                                                                    |
                                                                                    |
                                                     +------------------------------+
                                                     |
                                                     |
                                    +----------------+---------------+
                                    |                                |
                                    |                                |
                                    V                                V
                                  <name>                           <name>
                                    |                                |
                                    |                                |
                                    |                                V
                                    |                     loop of :: followed by <name>
                                    |                                |
                                    |                                |
                                    V                                V
                                    ;                                ;


\end{verbatim}}


\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-all-search-match-tokens }}
\usebox{\funcname}\emph{rlist} \emph{match-list}
\index{shu-cpp-all-search-match-tokens} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Repeatedly call shu-cpp-search-match-tokens until there are no remaining tokens
to match.  If the return value is nil, there were no tokens found to match.  If
the return value is non-nil, its \emph{rlist} is the list of all of the returned tokens
from all of the matches.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-sub-match-tokens }}
\usebox{\funcname}\emph{rlist} \emph{mlist}
\index{shu-cpp-internal-sub-match-tokens} \hfill [Command]
\hspace*{\wd\funcname}

\begin{doc-string}
Do the matching for one list only.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-match-info }}
\usebox{\funcname}\emph{op-code} \emph{match-eval-func}
\index{shu-cpp-make-match-info} \hfill [Function]
\hspace*{\wd\funcname}\emph{match-token-type}
\hspace*{\wd\funcname}

\begin{doc-string}
Return a match-info structure from the given arguments
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-match-side-list }}
\usebox{\funcname}\emph{op-code} \emph{match-list}
\index{shu-cpp-make-match-side-list} \hfill [Function]
\hspace*{\wd\funcname}\emph{side-parameter}

\begin{doc-string}
Return a match-info structure from the given arguments that represents a
side list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-evaluate-side-list }}
\usebox{\funcname}\emph{op-code} \emph{rlist}
\index{shu-cpp-match-evaluate-side-list} \hfill [Function]
\hspace*{\wd\funcname}\emph{match-info}

\begin{doc-string}
Evaluate a side list in a match list.  Use the op-code in  the match item to
find the function that should evaluate the side list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-extract-info }}
\usebox{\funcname}\emph{match-info} \emph{op-code}
\index{shu-cpp-match-extract-info} \hfill [Macro]
\hspace*{\wd\funcname}\emph{match-ret-ind}
\hspace*{\wd\funcname}\emph{match-token-value}

\begin{doc-string}
Extract the information out of a match-info
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-extract-op-code }}
\usebox{\funcname}\emph{match-info}
\index{shu-cpp-match-extract-op-code} \hfill [Function]

\begin{doc-string}
Return the op code from the match-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-extract-side-list }}
\usebox{\funcname}\emph{match-info} \emph{op-code}
\index{shu-cpp-match-extract-side-list} \hfill [Macro]
\hspace*{\wd\funcname}\emph{side-parameter}

\begin{doc-string}
Extract the side-list information out of a match-info that represents a side-list..
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-extract-side-list-only }}
\usebox{\funcname}\emph{match-info}
\index{shu-cpp-match-extract-side-list-only} \hfill [Function]

\begin{doc-string}
Extract only the side list from the match info.  This is in contract to
shu-cpp-match-extract-side-list, which extracts all of the properties of a
side list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-extract-token }}
\usebox{\funcname}\emph{match-info}
\index{shu-cpp-match-extract-token} \hfill [Function]

\begin{doc-string}
Return the token from the match-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-extract-type }}
\usebox{\funcname}\emph{match-info}
\index{shu-cpp-match-extract-type} \hfill [Function]

\begin{doc-string}
Return the token type from the match-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-is-side-list }}
\usebox{\funcname}\emph{op-code}
\index{shu-cpp-match-is-side-list} \hfill [Function]

\begin{doc-string}
Return true if the \emph{op-code} represents a side list operation.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-many-list }}
\usebox{\funcname}\emph{rlist} \emph{token-list}
\index{shu-cpp-match-many-list} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Do a recursive call to shu-cpp-match-tokens.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-op-code-name }}
\usebox{\funcname}\emph{op-code}
\index{shu-cpp-match-op-code-name} \hfill [Function]

\begin{doc-string}
Return the name of an op-code.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-or-list }}
\usebox{\funcname}\emph{rlist} \emph{token-list} \emph{match-info}
\index{shu-cpp-match-or-list} \hfill [Function]

\begin{doc-string}
\emph{rlist} points to the current return value list, if any.  \emph{token-list} points to
the next token-info to match.  \emph{match-info} is the head of the side list with
which to match.  The match succeeds if the first token-info in \emph{token-list}
matches any of the match-info members of \emph{match-info}.  If the match fails, return
nil.  If the match succeeds, return a cons cell pointing to two items.  The car
is the next token-info in \emph{token-list}.  The cdr is the return list, \emph{rlist}.  \emph{rlist}
remains unchanged if the match-info that matched did not specify that the
matched token-info was to be returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-repeat-list }}
\usebox{\funcname}\emph{rlist} \emph{token-list}
\index{shu-cpp-match-repeat-list} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{rlist} points to the current return value list, if any.  \emph{token-list} points to
the next token-info to match.  \emph{match-info} is the head of the side list with
which to match.  The match succeeds if the token-infos in \emph{token-list} match all
of the match-infos in MATCH-LIST zero or more times.  The token-infos are
matched repeatedly against the match-infos.  If there is a failure matching the
first match-info, the match is successful.  If there is a failure matching any
other match-info, the match fails.

This is useful when matching repeating but optional patterns.  For example, a
C++ name could be any of the following:

\small{\begin{verbatim}
     a
     a::b
     a::b::c
\end{verbatim}}

You can match this with a match list that requires an unquoted token that
matches a C++ name, followed by a side list looking for operator ``::'' followed
by an unquoted token.  If there is no match, then you have an unqualified name.
If it matches once, you have a name with one level of qualification.  But if it
fails in the middle, then you have found something that looks like ``a::'',
which is not a valid C++ name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-repeat-list-once }}
\usebox{\funcname}\emph{rlist} \emph{token-list}
\index{shu-cpp-match-repeat-list-once} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{rlist} points to the current return value list, if any.  \emph{token-list} points to
the next token-info to match.  \emph{match-info} is the head of the side list with
which to match.  The match succeeds if the token-infos in \emph{token-list} match all
of the match-infos in MATCH-LIST zero or more times.  The token-infos are
matched repeatedly against the match-infos.  If there is a failure matching any
match-info, the match fails.

This is useful when matching repeating patterns.  For example, a
C++ qualified name could be any of the following:

\small{\begin{verbatim}
     a::b
     a::b::c
\end{verbatim}}

You can match this with a match list that requires an unquoted token that
matches a C++ name, followed by a side list looking for operator ``::'' followed
by an unquoted token.   If there is a match, you have a name with one level of qualification.

fails in the middle, then you have found something that looks like ``a::'',
which is not a valid C++ name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-repeat-sub-list }}
\usebox{\funcname}\emph{rlist} \emph{token-list}
\index{shu-cpp-match-repeat-sub-list} \hfill [Function]
\hspace*{\wd\funcname}\emph{first-required}

\begin{doc-string}
Go through one iteration of the repeating list.  If \emph{first-required} is true,
then the first match must succeed.  Otherwise, we are matching zero or more
instances, so a first match failure is the same as a success.

The iteration is considered a success if either of the following are true:
1. The first match fails and \emph{first-required} is false, or 2. All matches succeed.
If all matches succeed, the updated \emph{rlist} and \emph{token-list} are returned.  If the
first match fails, the \emph{rlist} and \emph{token-list} are returned unaltered.  It is as
though no match was ever attempted.  If some match other than the first fails,
nil is returned.  If the \emph{token-list} is nil on entry, this is the equivalent of a
first match failure.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-tokens }}
\usebox{\funcname}\emph{rlist} \emph{match-lists} \emph{token-list}
\index{shu-cpp-match-tokens} \hfill [Function]

\begin{doc-string}
\emph{match-lists} is a list of match lists.  \emph{token-list} is a list of tokens.  \emph{rlist}
is either nil or an existing list of returned tokens on which to build.  For
each match-list in \emph{match-lists}, try to match every element of the match list to
the token list.  if a match fails or if you reach the end of the token list
before reaching the end of the match list, move to the next match list and try
again.  if all elements of a match list match the tokens in the token list, stop
the matching process and return (pushed onto RLIST) a list which consists of
matched tokens whose corresponding entry in the match list indicated that the
matched token was to be added to the list to be returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-search-match-tokens }}
\usebox{\funcname}\emph{rlist} \emph{match-list}
\index{shu-cpp-search-match-tokens} \hfill [Command]
\hspace*{\wd\funcname}

\begin{doc-string}
A function that advances through the \emph{token-list} until the first item in the
single \emph{match-list} matches the token.  If that happens, try to match the whole
list.  If the whole list is matched, return.  If the whole list does not match,
restore the original \emph{rlist} and \emph{token-list} and continue.  Return only when the
whole list is matched or the \emph{token-list} is exhausted.

This could be extended to multiple lists by having the search part check for a
match with the head of any of the lists in order.  When the head of one list
matches, pursue that list.  If the list match fails, move to the next list.
When no list head or entire list matches the current token, then move to the
next token.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-side-list-functions }}
\usebox{\funcname}
\index{shu-cpp-side-list-functions} \hfill [Constant]

\begin{doc-string}
A-list that maps a side list op-code to the function that implements it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-same }}
\usebox{\funcname}\emph{match-info} \emph{token-info}
\index{shu-cpp-token-match-same} \hfill [Function]

\begin{doc-string}
Perform a single match operation between an item in a token list and an item
in a match list.  The token types must be the same and the token value in the
match list must be the same as the token value in the token list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-same-rx }}
\usebox{\funcname}\emph{match-info} \emph{token-info}
\index{shu-cpp-token-match-same-rx} \hfill [Function]

\begin{doc-string}
Perform a single match operation by regular expression between an
item in a token list and an item in a match list.  The token types
must be the same and the regular expression in the match list must
match (via string-match) the token in the token list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-skip }}
\usebox{\funcname}\emph{tlist}
\index{shu-cpp-token-match-skip} \hfill [Function]

\begin{doc-string}
Skip one cell in the input list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-type-non-loop-max }}
\usebox{\funcname}
\index{shu-cpp-token-match-type-non-loop-max} \hfill [Constant]

\begin{doc-string}
The maximum match type value that does not indicate a side loop.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-type-same }}
\usebox{\funcname}
\index{shu-cpp-token-match-type-same} \hfill [Constant]

\begin{doc-string}
The match type constant that indicates that the token type and token value
must both match.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-type-same-rx }}
\usebox{\funcname}
\index{shu-cpp-token-match-type-same-rx} \hfill [Constant]

\begin{doc-string}
The match type constant that indicates that the token type must match and
the token value must satisfy the regular expression for a C++ variable name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-type-side-choose }}
\usebox{\funcname}
\index{shu-cpp-token-match-type-side-choose} \hfill [Constant]

\begin{doc-string}
The match side constant that indicates a choice.  The match is considered a
success if any one item in the side list matches the current token.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-type-side-loop }}
\usebox{\funcname}
\index{shu-cpp-token-match-type-side-loop} \hfill [Constant]

\begin{doc-string}
The match side constant that indicates a looping side list.  The token list
must match the side list zero or more times.  If the first item in the list does
not match, this is considered a success.  If the first item matches, then all
items in the side list must match.  If all items in the side list match, we go
back to the top of the side list and try again until we find a token that does
not match the first item in the side list.  The match is considered a failure
only if there is a partial match between the tokens and the side list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-type-side-loop-once }}
\usebox{\funcname}
\index{shu-cpp-token-match-type-side-loop-once} \hfill [Constant]

\begin{doc-string}
The match side constant that indicates a looping side list.  The token list
must match the side list one or more times.  All items in the side list must
match at least once.  If all items in the side list match, we go back to the top
of the side list and try again until we find a token that does not match the
first item in the side list.  The match is considered a failure if there is no
match or only a a partial match between the tokens and the side list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-type-side-many }}
\usebox{\funcname}
\index{shu-cpp-token-match-type-side-many} \hfill [Constant]

\begin{doc-string}
The match side constant that indicates a choice among multiple lists.
This does a recursive call to shu-cpp-match-tokens.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-match-type-skip }}
\usebox{\funcname}
\index{shu-cpp-token-match-type-skip} \hfill [Constant]

\begin{doc-string}
The match type constant that indicates skip one input cell.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-show-match-info }}
\usebox{\funcname}\emph{match-info}
\index{shu-cpp-token-show-match-info} \hfill [Function]

\begin{doc-string}
Show the data in an instance of match-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-show-match-info-buffer }}
\usebox{\funcname}\emph{match-info} \emph{gb}
\index{shu-cpp-token-show-match-info-buffer} \hfill [Function]

\begin{doc-string}
Show the data in an instance of match-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-show-match-list }}
\usebox{\funcname}\emph{match-list} \textbf{\&optional}
\index{shu-cpp-token-show-match-list} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Show the data in a list of match-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-show-match-lists }}
\usebox{\funcname}\emph{match-lists}
\index{shu-cpp-token-show-match-lists} \hfill [Function]
\hspace*{\wd\funcname}\emph{title}

\begin{doc-string}
Show the data in a list of match lists.
\end{doc-string}

\eject
\section{shu-cpp-misc}


A collection of useful functions for dealing with C++ code


\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{acgen }}
\usebox{\funcname}\emph{class-name}
\index{acgen} \hfill [Command]\\%
 (Function: shu-cpp-acgen)

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{ccdecl }}
\usebox{\funcname}\emph{class-name}
\index{ccdecl} \hfill [Command]\\%
 (Function: shu-cpp-ccdecl)

\begin{doc-string}
Generate a skeleton class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{ccgen }}
\usebox{\funcname}\emph{class-name}
\index{ccgen} \hfill [Command]\\%
 (Function: shu-cpp-ccgen)

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cdecl }}
\usebox{\funcname}\emph{class-name}
\index{cdecl} \hfill [Command]\\%
 (Function: shu-cpp-cdecl)

\begin{doc-string}
Generate a skeleton class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cgen }}
\usebox{\funcname}\emph{class-name} \textbf{\&optional} \emph{use-allocator}
\index{cgen} \hfill [Command]\\%
 (Function: shu-cpp-cgen)

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dox-file }}
\usebox{\funcname}
\index{dox-file} \hfill [Command]\\%
 (Function: shu-dox-file)

\begin{doc-string}
Place a skeleton Doxygen file definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{fline }}
\usebox{\funcname}
\index{fline} \hfill [Command]\\%
 (Function: shu-fline)

\begin{doc-string}
Place a stream of \_\_FILE\_\_ and \_\_LINE\_\_ at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gen-component }}
\usebox{\funcname}\emph{class-name}
\index{gen-component} \hfill [Command]\\%
 (Function: shu-gen-component)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{hcgen }}
\usebox{\funcname}\emph{class-name}
\index{hcgen} \hfill [Command]\\%
 (Function: shu-cpp-hcgen)

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-acgen }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-acgen} \hfill [Command]\\%
 (Alias: acgen)

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-ccdecl }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-ccdecl} \hfill [Command]\\%
 (Alias: ccdecl)

\begin{doc-string}
Generate a skeleton class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-ccgen }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-ccgen} \hfill [Command]\\%
 (Alias: ccgen)

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-cdecl }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-cdecl} \hfill [Command]\\%
 (Alias: cdecl)

\begin{doc-string}
Generate a skeleton class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-cgen }}
\usebox{\funcname}\emph{class-name} \textbf{\&optional} \emph{use-allocator}
\index{shu-cpp-cgen} \hfill [Command]\\%
 (Alias: cgen)

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-decl-class-name }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-decl-class-name} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Generate a comment which is the name of the class with a line of outline
characters above and below it.  \emph{class-name} is the name of the class.
\emph{outline-character} is a string containing the outline character (usually
``='' or ``-'')
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-decl-cpp-class-name }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-decl-cpp-class-name} \hfill [Function]

\begin{doc-string}
Generate a comment which is the name of the class with a line of dashes
above and below it to set off the class name in a cpp file.
\emph{class-name} is the name of the containing C++ class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-decl-cpp-print-self }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-decl-cpp-print-self} \hfill [Function]

\begin{doc-string}
Generate the skeleton code for the printSelf() function.
\emph{class-name} is the name of the containing C++ class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-decl-cpp-stream }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-decl-cpp-stream} \hfill [Function]

\begin{doc-string}
Generate the code for the streaming operator (operator$<$$<$()).  \emph{class-name} is the
name of the containing C++ class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-decl-h-class-name }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-decl-h-class-name} \hfill [Function]

\begin{doc-string}
Generate a comment which is the name of the class with a line of equal
signs above and below it to set off the class name in a header file.
\emph{class-name} is the name of the containing C++ class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-decl-h-print-self }}
\usebox{\funcname}
\index{shu-cpp-decl-h-print-self} \hfill [Function]

\begin{doc-string}
Generate the declaration of the printSelf() function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-decl-h-stream }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-decl-h-stream} \hfill [Function]

\begin{doc-string}
Generate the declaration for the streaming operator (operator$<$$<$()).
\emph{class-name} is the name of the containing C++ class.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-gen-decl-h-private }}
\usebox{\funcname}\emph{class-name} \textbf{\&optional}
\index{shu-cpp-gen-decl-h-private} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Generate the private section of the class declaration.  If \emph{copy-allowed}
is false, generate private an unimplemented copy constructor and operator=()
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-gen-h-class-intro }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-gen-h-class-intro} \hfill [Function]

\begin{doc-string}
Generate the preamble to a class declaration in a header file.  This is all
of the code that precedes the \\ DATA comment.  Return the position at which
the class comment was placed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-gen-inline-template-header }}
\usebox{\funcname}
\index{shu-cpp-gen-inline-template-header} \hfill [Function]

\begin{doc-string}
Doc string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-hcgen }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-hcgen} \hfill [Command]\\%
 (Alias: hcgen)

\begin{doc-string}
Generate a skeleton class code generation at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-inner-cdecl }}
\usebox{\funcname}\emph{class-name} \emph{copy-allowed}
\index{shu-cpp-inner-cdecl} \hfill [Function]
\hspace*{\wd\funcname}\emph{use-allocator}

\begin{doc-string}
Generate a skeleton class declaration at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-gen-ctor-not-implemented }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-misc-gen-ctor-not-implemented} \hfill [Function]

\begin{doc-string}
Generate a declaration of a non-implemented copy constructor and operator=().
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-gen-h-ctor }}
\usebox{\funcname}\emph{class-name} \textbf{\&optional}
\index{shu-cpp-misc-gen-h-ctor} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Generate a declaration of a constructor for the given \emph{class-name}.  If
\emph{use-allocator} is true, the constructor declaration includes an optional
allocator.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-gen-h-dtor }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-misc-gen-h-dtor} \hfill [Function]

\begin{doc-string}
Generate a commented out declaration of a destructor for the given \emph{class-name}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-gen-nested-traits }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-misc-gen-nested-traits} \hfill [Function]

\begin{doc-string}
Generate a nested traits declaration.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-gen-not-implemented }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-misc-gen-not-implemented} \hfill [Function]

\begin{doc-string}
Generate a declaration of a non-implemented copy constructor and operator=().
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-gen-op-equal-not-implemented }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-misc-gen-op-equal-not-implemented} \hfill [Function]

\begin{doc-string}
Generate a declaration of a non-implemented copy constructor and operator=().
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-h-tail-gen }}
\usebox{\funcname}\emph{class-name}
\index{shu-cpp-misc-h-tail-gen} \hfill [Function]

\begin{doc-string}
Generate the tail code in a header file starting with
``INLINE AND TEMPLATE FUNCTION IMPLEMENTATIONS''
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-inline-template-label }}
\usebox{\funcname}
\index{shu-cpp-misc-inline-template-label} \hfill [Constant]

\begin{doc-string}
The text of the header that starts inline and template functions in a
C++ header file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-not-implemented-label }}
\usebox{\funcname}
\index{shu-cpp-misc-not-implemented-label} \hfill [Constant]

\begin{doc-string}
The label put in a header file for functions and operators that are
deliberately not implemented.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-misc-set-alias }}
\usebox{\funcname}
\index{shu-cpp-misc-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-cpp-misc.
These are generally the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dox-file }}
\usebox{\funcname}
\index{shu-dox-file} \hfill [Command]\\%
 (Alias: dox-file)

\begin{doc-string}
Place a skeleton Doxygen file definition at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-fline }}
\usebox{\funcname}
\index{shu-fline} \hfill [Command]\\%
 (Alias: fline)

\begin{doc-string}
Place a stream of \_\_FILE\_\_ and \_\_LINE\_\_ at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gen-component }}
\usebox{\funcname}\emph{class-name}
\index{shu-gen-component} \hfill [Command]\\%
 (Alias: gen-component)

\begin{doc-string}
Generate the three files for a new component: .cpp, .h, and .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-cfile }}
\usebox{\funcname}\emph{author} \emph{namespace} \emph{class-name}
\index{shu-generate-cfile} \hfill [Function]

\begin{doc-string}
Generate a skeleton cpp file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-hfile }}
\usebox{\funcname}\emph{author} \emph{namespace} \emph{class-name}
\index{shu-generate-hfile} \hfill [Function]

\begin{doc-string}
Generate a skeleton header file
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-generate-tfile }}
\usebox{\funcname}\emph{author} \emph{namespace} \emph{class-name}
\index{shu-generate-tfile} \hfill [Function]

\begin{doc-string}
Generate a skeleton t.cpp file
\end{doc-string}

\eject
\section{shu-cpp-project}


A collection of useful functions for dealing with project files and treating
a set of source files in multiple directories as a single project

\subsubsection{Toggle back and forth between files}

If you are editing a C or C++ file and wish to switch to its associated
header file, \emph{shu-hother} will switch to the header file.  \emph{shu-cother} will
switch back to the original C or C++ file.  \emph{shu-tother} will switch to the
associated unit test file that ends in ``t.cpp.""
This set of functions allows you to treat a set of files as a single project.

You define a project by creating a project file.  A project file is simply a
text file with one or more directory names in it.  You select the text in the
file and invoke the command shu-make-c-project.  This searches the given
directories for all of the header files and C and C++ files and remembers
where these files are located.

When you want to visit a file you start typing the first few characters of the
file name.  You can use auto completion to complete the name.  Since
shu-project knows where all of the files are located, you do not have to
remember that.  Once you have typed in a complete file name, the file will be
visited wherever it happens to reside.

If you have two or more files with the same name in different directories, you
will be presented with a menu and asked to select the file you have in mind.

\subsubsection{Creating a project file}

If you do not have a project file, shu-project gives you a convenient way to
create one.  Go to the root directory of your project, open a new empty file
(I usually call it project.txt), and invoke the command shu-make-c-project.
It will prompt you for the root directory with a default being the current
directory.  It will then find all of the directories at or below the root that
contain code and it will place the directory names in the file.  Now you have
your project file.

\subsubsection{File names within the project}

shu-project now knows where all of the file names reside so you do not have to
remember that.  But it does more to simplify your life.  Many files in large
projects start with a common prefix.  If you have a class called ThingLoader,
it might be defined in a file called thingloader.h.  But in a large project,
the full file name might be something like myproject\_thingloader.h.

As shu-project is creating the list of file names, it is also creating an
index of short names with common prefixes stripped.  So if you want to visit
myproject\_thingloader.h, just type ``thing'' and hit tab to autocomplete.  If
no other file starts with ``thing'', shu-project will autocomplete to
``thingloader'' and then look in its index to find myproject\_thingloader.h.

\subsubsection{Visiting related files}

If you are in a .cpp file and you want to visit its associated .h file, issue
the command shu-hother and you will be taken to the .h file even if it is in a
different directory.  Similarly, you can visit the associated unit test file
(t.cpp) with the command shu-tother to visit the unit test file.

\subsubsection{Visiting files based on error messages}

You compile a file and the compiler complains ...

\small{\begin{verbatim}
     ..\myproject_thingloader.cpp:190:6: error: Invalid type for ...
\end{verbatim}}

Simply place the cursor under any part of the file name and type Ctl-x h.
shu-project will take you to line 190, column 6 of myproject\_thingloader.cpp.



\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{clear-c-project }}
\usebox{\funcname}
\index{clear-c-project} \hfill [Command]\\%
 (Function: shu-clear-c-project)

\begin{doc-string}
Clear an existing project, if any.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{clear-prefix }}
\usebox{\funcname}
\index{clear-prefix} \hfill [Function]\\%
 (Function: shu-clear-prefix)

\begin{doc-string}
Clear the default file name prefix for those times when we are trying to visit
a project file and point is not sitting on something that resembles a file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{cother }}
\usebox{\funcname}
\index{cother} \hfill [Command]\\%
 (Function: shu-cother)

\begin{doc-string}
Visit a .cpp file from the corresponding .t.cpp or .h file.  If visiting a
t.cpp or .h file, invoke this function and you will be taken to the
corresponding .cpp or .c file.  This function will use a project if one is
active.  Otherwise, it will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{count-c-project }}
\usebox{\funcname}
\index{count-c-project} \hfill [Command]\\%
 (Function: shu-count-c-project)

\begin{doc-string}
Count the number of lines of code in a project.  The final count is shown in
the minibuffer.  The counts of individual subdirectories are stored in the
temporary buffer \emph\{*shu-project-count*\}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{hother }}
\usebox{\funcname}
\index{hother} \hfill [Command]\\%
 (Function: shu-hother)

\begin{doc-string}
Visit a .h file from the corresponding .cpp or t.cpp file.  If visiting a
.cpp or t.cpp file, invoke this function and you will be taken to the
corresponding .h file.  This function will use a project if one is active.
Otherwise, it will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{iother }}
\usebox{\funcname}
\index{iother} \hfill [Command]\\%
 (Function: shu-iother)

\begin{doc-string}
Visit a i.cpp file from the corresponding .cpp or .h file.  If visiting a .c
or .cpp file, invoke this function and you will be taken to the corresponding
.i.cpp file.  This function will use a project if one is active.  Otherwise, it
will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{list-c-all-project }}
\usebox{\funcname}
\index{list-c-all-project} \hfill [Command]\\%
 (Function: shu-list-c-all-project)

\begin{doc-string}
Insert into the current buffer everything that is known about the files,
prefixes, short names, long names, and duplicate names within the current
project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{list-c-directories }}
\usebox{\funcname}
\index{list-c-directories} \hfill [Command]\\%
 (Function: shu-list-c-directories)

\begin{doc-string}
Insert into the current buffer the names of all of the directories in a project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{list-c-duplicates }}
\usebox{\funcname}
\index{list-c-duplicates} \hfill [Command]\\%
 (Function: shu-list-c-duplicates)

\begin{doc-string}
Insert into the current buffer a list of all of the duplicate files names.
Under each duplicate file name, insert a list of the full paths to all of the
duplicates.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{list-c-file-names }}
\usebox{\funcname}
\index{list-c-file-names} \hfill [Command]\\%
 (Function: shu-list-c-file-names)

\begin{doc-string}
Insert into the buffer a list of all of the unique file names in the project.
This does not include the file path as it will be different for duplicate
names.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{list-c-prefixes }}
\usebox{\funcname}
\index{list-c-prefixes} \hfill [Command]\\%
 (Function: shu-list-c-prefixes)

\begin{doc-string}
List all of the file prefixes found in the current project, if any.
See the doc-string for \emph{shu-project-split-file-name} for further information
about extracted file prefixes.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{list-c-project }}
\usebox{\funcname}
\index{list-c-project} \hfill [Command]\\%
 (Function: shu-list-c-project)

\begin{doc-string}
Insert into the current buffer the names of all of the code files in the
current project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{list-completing-names }}
\usebox{\funcname}
\index{list-completing-names} \hfill [Command]\\%
 (Function: shu-cpp-list-completing-names)

\begin{doc-string}
List all of the names that are used to do a completing read of a file name
along with the names of the actual files to which they map.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{list-project-names }}
\usebox{\funcname}
\index{list-project-names} \hfill [Command]\\%
 (Function: shu-cpp-list-project-names)

\begin{doc-string}
List all of the names in a project with the names of the files to
which they map.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{list-short-names }}
\usebox{\funcname}
\index{list-short-names} \hfill [Command]\\%
 (Function: shu-cpp-list-short-names)

\begin{doc-string}
List all of the short names in a project with the names of the files to
which they map.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{make-c-project }}
\usebox{\funcname}\emph{proj-root}
\index{make-c-project} \hfill [Command]\\%
 (Function: shu-make-c-project)

\begin{doc-string}
Create a project file of all directories containing c or h files.  Starts at
the specified root directory and searches all subdirectories for any that
contain c or h files.  Top level directories whose names are found in
\emph{shu-project-exclude-list} are excluded from the search.  Typically
\emph{shu-project-exclude-list} is used to exclude CMake directories that include c or
h files that have been created as part of the build process and are not members
of the repository itself.  It then inserts all of the directory names into the
current file at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{make-full-c-project }}
\usebox{\funcname}\emph{proj-root}
\index{make-full-c-project} \hfill [Command]\\%
 (Function: shu-make-full-c-project)

\begin{doc-string}
Create a project file of all directories containing c or h files.
Starts at the specified root directory and searches all subdirectories for
any that contain c or h files.  It then inserts all of the directory names
into the current file at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{make-p-project }}
\usebox{\funcname}\emph{proj-root}
\index{make-p-project} \hfill [Command]\\%
 (Function: shu-make-p-project)

\begin{doc-string}
Create a Python project that is analogous to a c project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{other }}
\usebox{\funcname}
\index{other} \hfill [Command]\\%
 (Function: shu-other)

\begin{doc-string}
Visit an h file from a c file or a c file from an h file If visiting a .h
file, invoke this function and you will be taken to the .c or .cpp file.  If
visiting a .c or .cpp file, invoke this function and you will be taken to the
corresponding .h file.  This function will use a project if one is active.
Otherwise, it will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{renew-c-project }}
\usebox{\funcname}
\index{renew-c-project} \hfill [Command]\\%
 (Function: shu-renew-c-project)

\begin{doc-string}
Renew a previously established project to pick up any new files.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-c-project }}
\usebox{\funcname}\emph{start} \emph{end}
\index{set-c-project} \hfill [Command]\\%
 (Function: shu-set-c-project)

\begin{doc-string}
Mark a region in a file that contains one subdirectory name per line.  Then
invoke set-c-project and it will find and remember all of the c and h files in
those subdirectories.  You may then subsequently visit any of those files by
invoking M-x vh which will allow you to type in the file name only (with auto
completion) and will then visit the file in the appropriate subdirectory.  If
this function is called interactively, it clears the project name that was
established by either \emph{shu-setup-project-and-tags} of \emph{shu-visit-project-and-tags}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-dir-prefix }}
\usebox{\funcname}\emph{prefix}
\index{set-dir-prefix} \hfill [Command]\\%
 (Function: shu-set-dir-prefix)

\begin{doc-string}
Set the default file name prefix to be the current directory name end for those
times when we are trying to visit a project file and point is not sitting on
something that resembles a file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-p-project }}
\usebox{\funcname}\emph{start} \emph{end}
\index{set-p-project} \hfill [Command]\\%
 (Function: shu-set-p-project)

\begin{doc-string}
Mark a region in a file that contains one subdirectory name per line.  Then
invoke set-c-project and it will find and remember all of the c and h files in
those subdirectories.  You may then subsequently visit any of those files by
invoking M-x vh which will allow you to type in the file name only (with auto
completion) and will then visit the file in the appropriate subdirectory.  If
this function is called interactively, it clears the project name that was
established by either \emph{shu-setup-project-and-tags} of \emph{shu-visit-project-and-tags}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-prefix }}
\usebox{\funcname}\emph{prefix}
\index{set-prefix} \hfill [Command]\\%
 (Function: shu-set-prefix)

\begin{doc-string}
Set the default file name prefix for those times when we are trying to visit
a project file and point is not sitting on something that resembles a file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{tother }}
\usebox{\funcname}
\index{tother} \hfill [Command]\\%
 (Function: shu-tother)

\begin{doc-string}
Visit a t.cpp file from the corresponding .cpp or .h file.  If visiting a .c
or .cpp file, invoke this function and you will be taken to the corresponding
.t.cpp file.  This function will use a project if one is active.  Otherwise, it
will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{vf }}
\usebox{\funcname}
\index{vf} \hfill [Command]\\%
 (Function: shu-vf)

\begin{doc-string}
If point is on something that looks like a file name, visit the file.  If the
file name is followed by a colon and a number, the number is interpreted as a
line number within the file and point is moved to the beginning of that line.
If the line number is followed by a colon and another number, then the second
number is interpreted as a column number and point is moved to that column
number.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{which-c-project }}
\usebox{\funcname}
\index{which-c-project} \hfill [Command]\\%
 (Function: shu-which-c-project)

\begin{doc-string}
Identify the current project by putting into a project buffer the name of the file
from which the project was derived as well as the name of all of the directories in the
project.  Then switch to that buffer.  The idea is to invoke this function, look at the
results in that buffer, and then quit out of the buffer.
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-cpp-c-extensions }}
\usebox{\funcname}\emph{xtns}
\index{shu-add-cpp-c-extensions} \hfill [Function]

\begin{doc-string}
Add one or more file extensions to the list of C and C++ extensions recognized by the
C package functions.  Argument may be a single extension in a string or a list of strings.
This modifies both shu-cpp-c-extensions and shu-project-extensions.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-cpp-h-extensions }}
\usebox{\funcname}\emph{xtns}
\index{shu-add-cpp-h-extensions} \hfill [Function]

\begin{doc-string}
Add one or more file extensions to the list of C and C++ extensions recognized by the
C package functions.  Argument may be a single extension in a string or a list of strings.
This modifies both shu-cpp-h-extensions and shu-project-extensions.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-cpp-package-line }}
\usebox{\funcname}\emph{dir-name}
\index{shu-add-cpp-package-line} \hfill [Function]

\begin{doc-string}
Called with point at the beginning of the line.  Take the whole line as the
name of a directory, look into the directory, and create an alist of all of the
files in the directory as described in shu-cpp-subdir-for-package.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-clear-c-project }}
\usebox{\funcname}
\index{shu-clear-c-project} \hfill [Command]\\%
 (Alias: clear-c-project)

\begin{doc-string}
Clear an existing project, if any.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-clear-prefix }}
\usebox{\funcname}
\index{shu-clear-prefix} \hfill [Function]\\%
 (Alias: clear-prefix)

\begin{doc-string}
Clear the default file name prefix for those times when we are trying to visit
a project file and point is not sitting on something that resembles a file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-completion-is-directory }}
\usebox{\funcname}
\index{shu-completion-is-directory} \hfill [Variable]

\begin{doc-string}
True if we are to use the current directory name as the file name prefix.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cother }}
\usebox{\funcname}
\index{shu-cother} \hfill [Command]\\%
 (Alias: cother)

\begin{doc-string}
Visit a .cpp file from the corresponding .t.cpp or .h file.  If visiting a
t.cpp or .h file, invoke this function and you will be taken to the
corresponding .cpp or .c file.  This function will use a project if one is
active.  Otherwise, it will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-count-c-project }}
\usebox{\funcname}
\index{shu-count-c-project} \hfill [Command]\\%
 (Alias: count-c-project)

\begin{doc-string}
Count the number of lines of code in a project.  The final count is shown in
the minibuffer.  The counts of individual subdirectories are stored in the
temporary buffer \emph\{*shu-project-count*\}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-count-in-cpp-directory }}
\usebox{\funcname}\emph{directory-name} \emph{pbuf}
\index{shu-count-in-cpp-directory} \hfill [Function]
\hspace*{\wd\funcname}\emph{t-h-files} \emph{t-c-files}
\hspace*{\wd\funcname}\emph{t-c-count}

\begin{doc-string}
Count the lines of code in each of the code files in the given directory, updating
the message in the minibuffer and passing the totals back to the caller.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-c-extensions }}
\usebox{\funcname}
\index{shu-cpp-c-extensions} \hfill [Constant]

\begin{doc-string}
A list of file extensions for all of the C file types we want to find.  This is defined
as defconst in shu-cpp-base.el but may be modified by shu-add-cpp-c-extensions.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-c-file-count }}
\usebox{\funcname}
\index{shu-cpp-c-file-count} \hfill [Variable]

\begin{doc-string}
This is the count of the number of C files found in the project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-choose-file }}
\usebox{\funcname}\emph{assoc-result}
\index{shu-cpp-choose-file} \hfill [Function]

\begin{doc-string}
Choose the file to visit for a given unqualified name.  If there is
only one file associated with the name then visit it.  If there are
multiple files put all of the fully qualified file names in the completion
buffer and give the user the opportunity to select the desired file.  Then
visit that file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-choose-other-file }}
\usebox{\funcname}\emph{newfile}
\index{shu-cpp-choose-other-file} \hfill [Function]

\begin{doc-string}
\emph{newfile} is a fully qualified file name that has been formed by changing the
file suffix, perhaps from .cpp to .h or .h to .t.cpp.  We want to try to open
the file either in the current directory or in the project.

Up until 5 February 2022, we first looked for the file in the project, then in
the local directory.  But if two .h files were duplicate names and two .cpp
files were duplicate names, a request to visit the ``other'' file would bring up
a choice of the duplicate names.  It seems logical that if you are in a .h file
and you want to visit the associated .cpp file, the one that you want to visit
is the one in the current directory.

As of 5 February 2022, we first look for the file in the current directory and
then in the project.  The local variable LOCAL-DIRECTORY-FIRST can be used to
invert that choice and return to the original behavior of first looking in the
project for the file.

If a file was found and visited, return true.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-choose-project-file }}
\usebox{\funcname}\emph{newfile}
\index{shu-cpp-choose-project-file} \hfill [Function]

\begin{doc-string}
Try to visit a file within a project.  If a project is in use, try to visit
the given file in the list of files that belong to the project.  This goes
through the standard project selection process, including prompting the user to
choose the desired file if more than one file with the same name exists.  If a
file was found and visited, return true.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-class-list }}
\usebox{\funcname}
\index{shu-cpp-class-list} \hfill [Variable]

\begin{doc-string}
This is an alist whose keys are unqualified file names and whose values
contain a list of the fully qualified files with the same unqualified name.  if
\emph{shu-cpp-project-short-names} is nil, this list is identical to the one stored in
\emph{shu-cpp-completing-list}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-common-completion }}
\usebox{\funcname}
\index{shu-cpp-common-completion} \hfill [Function]

\begin{doc-string}
Called when the user hits enter or clicks mouse button 2 on completion window.
At this point the users selected choice is in the current buffer.  We get the
answer from the current buffer and call the function that is currently
pointed to by shu-cpp-completion-target.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-completing-list }}
\usebox{\funcname}
\index{shu-cpp-completing-list} \hfill [Variable]

\begin{doc-string}
This is an alist whose keys are unqualified file names and whose values
contain a list of the fully qualified files with the same unqualified name.  If
\emph{shu-cpp-project-short-names} is non-nil, then this alist includes the short file
names as well.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-completion-current-buffer }}
\usebox{\funcname}
\index{shu-cpp-completion-current-buffer} \hfill [Variable]

\begin{doc-string}
Active buffer just before we have to do a completion.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-completion-prefix }}
\usebox{\funcname}
\index{shu-cpp-completion-prefix} \hfill [Variable]

\begin{doc-string}
The default file name prefix when we are looking for a file and point is not
sitting on something that appears to be a file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-completion-scratch }}
\usebox{\funcname}
\index{shu-cpp-completion-scratch} \hfill [Variable]

\begin{doc-string}
Scratch buffer used by C file name completions.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-completion-target }}
\usebox{\funcname}
\index{shu-cpp-completion-target} \hfill [Variable]

\begin{doc-string}
Global variable used to hold the function to be invoked at the end of the
current completion.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-fetch-list }}
\usebox{\funcname}
\index{shu-cpp-fetch-list} \hfill [Variable]

\begin{doc-string}
The name of the shared variable that contains the list of directories assembled
by shu-make-c-project
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-final-list }}
\usebox{\funcname}
\index{shu-cpp-final-list} \hfill [Variable]

\begin{doc-string}
The name of the shared variable that contains the list of directories assembled
by shu-make-c-project
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-finish-project }}
\usebox{\funcname}
\index{shu-cpp-finish-project} \hfill [Function]

\begin{doc-string}
Finish constructing a C project from a user file list.  The input is
KEY-LIST, which is an a-list.  The cdr of each entry is the short (unqualified)
file name.  The cdr of each entry is the fully qualified name.  This alist may
have duplicate short names.  This function produces a new list.  The car of each
item is still the short (unqualified) file name.  The cdr is a list of all of
the fully qualified file names to which the short name maps.  If a user selects
a file that has only one fully qualified file name, we open the file.  But if it
has more than one fully qualified file name, we have to ask the user which one
is wanted.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-found-extensions }}
\usebox{\funcname}
\index{shu-cpp-found-extensions} \hfill [Variable]

\begin{doc-string}
This is a list of all of the file extensions found in the current project.  While
shu-project-extensions contains all of the extensions that we look for.  This variable
contains those that we actually found in building the current project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-get-inverted-class-list }}
\usebox{\funcname}
\index{shu-cpp-get-inverted-class-list} \hfill [Function]

\begin{doc-string}
Return \emph{shu-cpp-inverted-class-list}, creating it if it is currently nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-h-extensions }}
\usebox{\funcname}
\index{shu-cpp-h-extensions} \hfill [Constant]

\begin{doc-string}
A list of file extensions for all of the H file types we want to find.  This is defined
as defconst in shu-cpp-base.el but may be modified by shu-add-cpp-h-extensions
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-h-file-count }}
\usebox{\funcname}
\index{shu-cpp-h-file-count} \hfill [Variable]

\begin{doc-string}
This is the count of the number of H files found in the project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-internal-list-names }}
\usebox{\funcname}\emph{name-list} \emph{type-name}
\index{shu-cpp-internal-list-names} \hfill [Function]

\begin{doc-string}
Implementation function for \emph{shu-cpp-list-short-names},
\emph{shu-cpp-list-project-names}, and \emph{shu-cpp-list-completing-names}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-inverted-class-list }}
\usebox{\funcname}
\index{shu-cpp-inverted-class-list} \hfill [Variable]

\begin{doc-string}
This is the inversion of \emph{shu-cpp-class-list}.  It is a list of all of the
fully qualified file names found in \emph{shu-cpp-class-list}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-list-completing-names }}
\usebox{\funcname}
\index{shu-cpp-list-completing-names} \hfill [Command]\\%
 (Alias: list-completing-names)

\begin{doc-string}
List all of the names that are used to do a completing read of a file name
along with the names of the actual files to which they map.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-list-project-names }}
\usebox{\funcname}
\index{shu-cpp-list-project-names} \hfill [Command]\\%
 (Alias: list-project-names)

\begin{doc-string}
List all of the names in a project with the names of the files to
which they map.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-list-short-names }}
\usebox{\funcname}
\index{shu-cpp-list-short-names} \hfill [Command]\\%
 (Alias: list-short-names)

\begin{doc-string}
List all of the short names in a project with the names of the files to
which they map.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-prefix-list }}
\usebox{\funcname}
\index{shu-cpp-prefix-list} \hfill [Variable]

\begin{doc-string}
This is the list of prefixes removed from the short names if
\emph{shu-cpp-project-short-names} is non-nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-collapse-list }}
\usebox{\funcname}\emph{key-list}
\index{shu-cpp-project-collapse-list} \hfill [Function]

\begin{doc-string}
\emph{key-list} is an alist in which the cdr of each item is the unqualified file name
and the car of each item is the fully qualified file name, including the path to
the file.  The output is a different alist in which the car of each item is the
unqualified file name and the cdr of each item is the list of fully qualified
file names to which the unqualified file name refers.

For example, if \emph{key-list} contains:

\small{\begin{verbatim}
    (``xxx_mumble.h'' . ``/foo/bar/xxx_mumble.h'')
    (``xxx_stumble.h . ``/foo/bar/xxx_stumble..h'')
    (``xxx_stumble.h . ``/boo/baz/xxx_stumble..h'')
\end{verbatim}}

then the returned list will contain

\small{\begin{verbatim}
    (``xxx_mumble.h'' . ``/foo/bar/xxx_mumble.h'')
    (``xxx_stumble.h . ``/foo/bar/xxx_stumble..h'' ``/boo/baz/xxx_stumble..h'')
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-extract-base-name }}
\usebox{\funcname}\emph{name}
\index{shu-cpp-project-extract-base-name} \hfill [Function]

\begin{doc-string}
This is the implementation function of \emph{shu-cpp-project-get-base-name} so that
the logic of the function can be unit tested.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-file }}
\usebox{\funcname}
\index{shu-cpp-project-file} \hfill [Variable]

\begin{doc-string}
The name of the file from which the current project was read.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-get-base-name }}
\usebox{\funcname}
\index{shu-cpp-project-get-base-name} \hfill [Command]

\begin{doc-string}
When visiting a file within a project, the name might consist of two or three
parts - the file name, the normal extension, such as .h or .cpp, and the
intermediate extension, such as .i or .t when visiting .i.cpp or .t.cpp.  This
function gets the buffer file name and removes the one or two extensions in
order to get the name with no extensions at all.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-get-list-counts }}
\usebox{\funcname}\emph{proj-list}
\index{shu-cpp-project-get-list-counts} \hfill [Function]

\begin{doc-string}
\emph{proj-list} is an alist whose structure is identical to that of \emph{shu-cpp-class-list}.
This function returns a list with three items on it: the number of c / cpp files, the
number of h files, and the number of duplicate names found in the list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-invert-list }}
\usebox{\funcname}\emph{proj-list}
\index{shu-cpp-project-invert-list} \hfill [Function]

\begin{doc-string}
\emph{proj-list} is an alist in which the cdr of each item is the unqualified file name
and the car of each item is the list of fully qualified file names to which
the unqualified name refers.  The returned output is a single list of fully
qualified file names.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-is-type-wanted }}
\usebox{\funcname}\emph{sname} \emph{cpp-type}
\index{shu-cpp-project-is-type-wanted} \hfill [Function]

\begin{doc-string}
Determine if a file should be included based on its file type and on the
argument \emph{cpp-type}.  If \emph{cpp-type} is t then we only want files of type C++.

If \emph{cpp-type} is nil, we want any file of any type..

If \emph{cpp-type} is nil, this function returns true.  If \emph{cpp-type} is t, this function
returns true iff the file extension of \emph{sname} is one that holds C++ code.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-list }}
\usebox{\funcname}
\index{shu-cpp-project-list} \hfill [Variable]

\begin{doc-string}
List that holds all of the subdirectories in the current project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-name }}
\usebox{\funcname}
\index{shu-cpp-project-name} \hfill [Variable]

\begin{doc-string}
If the current project was established by either \emph{shu-setup-project-and-tags}
of \emph{shu-visit-project-and-tags}, this is the name of the interactive function that
was invoked by the user to set it up.  This is useful when you are in a project
and you forgot the name of the interactive function that got you there.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-set-alias }}
\usebox{\funcname}
\index{shu-cpp-project-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-cpp-project.
These are generally the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-short-names }}
\usebox{\funcname}
\index{shu-cpp-project-short-names} \hfill [Custom]

\begin{doc-string}
Set non-nil if shu-cpp-project creates short names for files in a project.  A
short name is an approximation of the file name that may be easier to type.  For
example, if all of the files in a project begin with a common prefix (e.g.,
``x\_server\_mumble.cpp'' and ``x\_server\_stumble.cpp'', then the short names for
these two files would be ``mumble.cpp'' and ``stumble.cpp''.  This means that
the user does not have to type the prefix in order to find the file.  If the
user types ``mumble.cpp'' as the file name, emacs will open the file
``x\_server\_mumble.cpp''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-subdirs }}
\usebox{\funcname}\emph{dir-name} \emph{level}
\index{shu-cpp-project-subdirs} \hfill [Function]

\begin{doc-string}
Starting with the directory name \emph{dir-name}. create a list of subdirectories
whose head is in \emph{shu-cpp-final-list}, that contains the name of every directory and
subdirectory that contains C, C++, or H files.  This is used by shu-make-c-project
and other functions that wish to discover all directories that might contain
source code.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-time }}
\usebox{\funcname}
\index{shu-cpp-project-time} \hfill [Variable]

\begin{doc-string}
This is the time at which the current project was created.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-very-short-names }}
\usebox{\funcname}
\index{shu-cpp-project-very-short-names} \hfill [Custom]

\begin{doc-string}
Set non-nil if shu-cpp-project creates very short names for files in a
project.  A short name is an approximation of the file name that may be easier
to type.  For example, if all of the files in a project begin with a common
prefix (e.g., ``my\_own\_server\_mumble.cpp'' and ``my\_own\_server\_stumble.cpp'',
then the short names for these two files would be ``mumble.cpp'' and
``stumble.cpp''.  This means that the user does not have to type the prefix in
order to find the file.  If the user types ``mumble.cpp'' as the file name,
emacs will open the file ``my\_own\_server\_mumble.cpp''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-visit-prefer-local }}
\usebox{\funcname}\emph{newfile}
\index{shu-cpp-project-visit-prefer-local} \hfill [Function]

\begin{doc-string}
\emph{newfile} is a fully qualified file name that has been formed by changing the
file suffix, perhaps from .cpp to .h or .h to .t.cpp.  We want to try to open
the file either in the current directory or in the project.

First try to visit the file in the local directory.  If not found in the local
directory, try to find and visit it within the project.

If a file was found and visited, return true.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-project-visit-prefer-project }}
\usebox{\funcname}\emph{newfile}
\index{shu-cpp-project-visit-prefer-project} \hfill [Function]

\begin{doc-string}
\emph{newfile} is a fully qualified file name that has been formed by changing the
file suffix, perhaps from .cpp to .h or .h to .t.cpp.  We want to try to open
the file either in the current directory or in the project.

First try to visit the file in the project.  If not found in the project, try to
visit the file in the local directory.

If a file was found and visited, return true.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-resolve-choice }}
\usebox{\funcname}\emph{full-name-list} \emph{target}
\index{shu-cpp-resolve-choice} \hfill [Function]

\begin{doc-string}
Choose from a number of possible file names.
We have found an unqualified file name of interest but it resolves to multiple
fully qualified file names.  Display all of the possibilities in a completion
buffer and ask the user to choose the desired one.  The string containing the
chosen fully qualified file name will then be passed to the function pointed
to by target.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-short-list }}
\usebox{\funcname}
\index{shu-cpp-short-list} \hfill [Variable]

\begin{doc-string}
This is the list of short names, if there are any.  The car of each item is
the short name.  The cdr of each item is the full path to the associated
file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-subdir-for-package }}
\usebox{\funcname}\emph{directory-name}
\index{shu-cpp-subdir-for-package} \hfill [Function]

\begin{doc-string}
Given a subdirectory name return an alist that contains as keys the names
of all of the c and h files in the subdirectory, and as values the the
fully qualified name and path of the c or h file.  So if the directory
``/u/foo/bar'' contains thing.c and what.h the returned alist would be

\small{\begin{verbatim}
      ( (``thing.c'' ``/u/foo/bar/thing.c'')
        (``what.h''  ``/u/foo/bar/what.h'' ) )
\end{verbatim}}

This allows us to associate the key ``thing.c'' with the fully qualified
name ``/u/foo/bar/thing.c''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-target-file-column }}
\usebox{\funcname}
\index{shu-cpp-target-file-column} \hfill [Variable]

\begin{doc-string}
If non-nil, this represents the column number that is to be located after a
file is visited by vh() and has gone through buffer completion selection.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-target-file-line }}
\usebox{\funcname}
\index{shu-cpp-target-file-line} \hfill [Variable]

\begin{doc-string}
If non-nil, this represents the line number that is to be located after a
file is visited by vh() and has gone through buffer completion selection.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-visit-target }}
\usebox{\funcname}\emph{file-name}
\index{shu-cpp-visit-target} \hfill [Function]

\begin{doc-string}
This is the function that visits the file name chosen by vh() and perhaps
by a completing read from a completion buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-default-file-to-seek }}
\usebox{\funcname}
\index{shu-default-file-to-seek} \hfill [Variable]

\begin{doc-string}
The default file to seek that is proposed as a possible file when vh() finds a
file name under the cursor, possibly with a line number.  If the user chooses a
file other than this one, we need to forget the associated line number.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-find-default-cpp-name }}
\usebox{\funcname}
\index{shu-find-default-cpp-name} \hfill [Function]

\begin{doc-string}
Find a default file name to visit.  Calls shu-find-line-and-file to find a possible file
name and possible line number within the file.  Return the file name if one is found and
sets shu-cpp-target-file-line to the line number if one is found
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-find-line-and-file }}
\usebox{\funcname}
\index{shu-find-line-and-file} \hfill [Function]

\begin{doc-string}
If point is sitting on the word ``line'', then look for a string of the form
``line 678 of frobnitz.cpp'' and return a list whose first item is the file name
and whose second item is the line number.  If point is not sitting on the word ``line'',
then check to see if point is sitting on a string that has the syntax of a valid
file name.  If that is the case, remember the file name.  If the file name is
followed by a colon, look for a line number following the colon.  If found, look
for another colon followed by a possible column number.  This function will return
nil if none of the above are found.  If only a file name is found, return a list
with one entry.  If file name and line number, a list with two entries.  If file
name, line number, and column number, a list with three entries.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-line-column-of-file }}
\usebox{\funcname}
\index{shu-get-line-column-of-file} \hfill [Function]

\begin{doc-string}
Fetch the potential line number and column number within a file.  On entry,
point is positioned at the character following a file name.  This file name
may be followed by a line number and the line number may be followed by a
column number.  This function recognizes four forms of line and column
specifications.

  thing.cpp:1234:42

indicates the file thing.cpp line number 1234, column 42

  [file=thing.cpp] [line=1234]

indicates the file thing.cpp line number 1234.

  ``thing.cpp'', line 55.16:

indicates the file thing.cpp line number 55, column 16.

  ``thing.cpp'', line 55:

indicates the file thing.cpp line number 55.

The purpose of this function is only to gather the line and column
specification following the file name.  The return value is a list, which is
empty if no line or column number was found.  It has only one element, which
is the line number if only a line number was found.  It has two elements,
which are the line number and column number if both line number and column
number were found.

This should probably be turned into a hook at some point so that other line
and column number indications may be used.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-real-this-command-name }}
\usebox{\funcname}
\index{shu-get-real-this-command-name} \hfill [Function]

\begin{doc-string}
Return the symbol name of the variable ``real-this-command'' if it is defined.
If not defined, return the string ``\emph\{**unknown**\}''.  Some older versions of emacs
do not support real-this-command.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-global-operation }}
\usebox{\funcname}\emph{documentation}
\index{shu-global-operation} \hfill [Function]
\hspace*{\wd\funcname}\textbf{\&optional} \emph{search-target}
\hspace*{\wd\funcname}

\begin{doc-string}
Invoke a function on every file in the project.
documentation is the string to put in the buffer to describe the operation.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-global-search-replace }}
\usebox{\funcname}\emph{file} \emph{argument1} \emph{argument2}
\index{shu-global-search-replace} \hfill [Function]

\begin{doc-string}
This function is called once for each file in the project.  The first
argument is the file name.  The second argument is a list holding lists of
search and replace operations.  Each search and replace operation is defined by
a list of arguments as follows:

\small{\begin{verbatim}
     1. A boolean value, t means case sensitive search, nil means ignore case
     2. The function to call to do the search.  This must be
        'search-forward, 're-search-forward, or any function with the same
        signature and behavior.
     3. The string that is the target of the search
     4. The string the is to replace the target whenever found
     5. An optional second argument to be passed to replace-match
        The default value is t
     6. An optional third argument to be passed to replace-match
        The default value is t
\end{verbatim}}

For example

\small{\begin{verbatim}
     (list
       (list t 'search-forward ``Mumble'' ``Bumble'')
       (list nil 'search-forward ``howdy'' ``doody''))
\end{verbatim}}

is a list that defines two search and replace operations.  Both operations use
the search-forward function.  The first is a case sensitive search and replace to
replace all instances of ``Mumble'' with ``Bumble''.  The second is a case
insensitive search and replace to replace all instances of ``howdy'' with ``doody''.

These operations may be performed on every file in the project as follows:

\small{\begin{verbatim}
     (setq ops
       (list
         (list t 'search-forward ``Mumble'' ``Bumble'')
         (list nil 'search-forward ``howdy'' ``doody'')))
     (setq doc ``Description of change'')
     (shu-global-operation doc 'shu-global-search-replace ops)
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-hother }}
\usebox{\funcname}
\index{shu-hother} \hfill [Command]\\%
 (Alias: hother)

\begin{doc-string}
Visit a .h file from the corresponding .cpp or t.cpp file.  If visiting a
.cpp or t.cpp file, invoke this function and you will be taken to the
corresponding .h file.  This function will use a project if one is active.
Otherwise, it will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-list-c-all-project }}
\usebox{\funcname}
\index{shu-internal-list-c-all-project} \hfill [Function]

\begin{doc-string}
The internal implementation function for \emph{shu-list-c-all-project}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-list-c-duplicates }}
\usebox{\funcname}\emph{proj-list}
\index{shu-internal-list-c-duplicates} \hfill [Function]

\begin{doc-string}
Internal implementation of shu-list-c-duplicates.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-list-c-file-names }}
\usebox{\funcname}\emph{proj-list}
\index{shu-internal-list-c-file-names} \hfill [Function]

\begin{doc-string}
Internal implementation function of \emph{shu-list-c-file-names}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-list-c-project }}
\usebox{\funcname}\emph{proj-list}
\index{shu-internal-list-c-project} \hfill [Function]

\begin{doc-string}
Insert into the current buffer the names of all of the code files in the
project whose files are in \emph{proj-list}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-set-c-project }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-internal-set-c-project} \hfill [Function]

\begin{doc-string}
Mark a region in a file that contains one subdirectory name per line.
Then invoke set-c-project and it will find and remember all of the c and h
files in those subdirectories.  You may then subsequently visit any of
those files by invoking M-x vh which will allow you to type in the file
name only (with auto completion) and will then visit the file in the
appropriate subdirectory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-visit-project-file }}
\usebox{\funcname}\emph{look-for-target}
\index{shu-internal-visit-project-file} \hfill [Function]

\begin{doc-string}
Visit a c or h file in a project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-which-c-project }}
\usebox{\funcname}\emph{pbuf}
\index{shu-internal-which-c-project} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-iother }}
\usebox{\funcname}
\index{shu-iother} \hfill [Command]\\%
 (Alias: iother)

\begin{doc-string}
Visit a i.cpp file from the corresponding .cpp or .h file.  If visiting a .c
or .cpp file, invoke this function and you will be taken to the corresponding
.i.cpp file.  This function will use a project if one is active.  Otherwise, it
will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-list-c-all-project }}
\usebox{\funcname}
\index{shu-list-c-all-project} \hfill [Command]\\%
 (Alias: list-c-all-project)

\begin{doc-string}
Insert into the current buffer everything that is known about the files,
prefixes, short names, long names, and duplicate names within the current
project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-list-c-directories }}
\usebox{\funcname}
\index{shu-list-c-directories} \hfill [Command]\\%
 (Alias: list-c-directories)

\begin{doc-string}
Insert into the current buffer the names of all of the directories in a project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-list-c-duplicates }}
\usebox{\funcname}
\index{shu-list-c-duplicates} \hfill [Command]\\%
 (Alias: list-c-duplicates)

\begin{doc-string}
Insert into the current buffer a list of all of the duplicate files names.
Under each duplicate file name, insert a list of the full paths to all of the
duplicates.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-list-c-file-names }}
\usebox{\funcname}
\index{shu-list-c-file-names} \hfill [Command]\\%
 (Alias: list-c-file-names)

\begin{doc-string}
Insert into the buffer a list of all of the unique file names in the project.
This does not include the file path as it will be different for duplicate
names.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-list-c-prefixes }}
\usebox{\funcname}
\index{shu-list-c-prefixes} \hfill [Command]\\%
 (Alias: list-c-prefixes)

\begin{doc-string}
List all of the file prefixes found in the current project, if any.
See the doc-string for \emph{shu-project-split-file-name} for further information
about extracted file prefixes.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-list-c-project }}
\usebox{\funcname}
\index{shu-list-c-project} \hfill [Command]\\%
 (Alias: list-c-project)

\begin{doc-string}
Insert into the current buffer the names of all of the code files in the
current project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-list-in-cpp-directory }}
\usebox{\funcname}\emph{directory-name}
\index{shu-list-in-cpp-directory} \hfill [Function]

\begin{doc-string}
Insert into the current buffer the names of all of the code files in a directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-c-project }}
\usebox{\funcname}\emph{proj-root}
\index{shu-make-c-project} \hfill [Command]\\%
 (Alias: make-c-project)

\begin{doc-string}
Create a project file of all directories containing c or h files.  Starts at
the specified root directory and searches all subdirectories for any that
contain c or h files.  Top level directories whose names are found in
\emph{shu-project-exclude-list} are excluded from the search.  Typically
\emph{shu-project-exclude-list} is used to exclude CMake directories that include c or
h files that have been created as part of the build process and are not members
of the repository itself.  It then inserts all of the directory names into the
current file at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-full-c-project }}
\usebox{\funcname}\emph{proj-root}
\index{shu-make-full-c-project} \hfill [Command]\\%
 (Alias: make-full-c-project)

\begin{doc-string}
Create a project file of all directories containing c or h files.
Starts at the specified root directory and searches all subdirectories for
any that contain c or h files.  It then inserts all of the directory names
into the current file at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-p-project }}
\usebox{\funcname}\emph{proj-root}
\index{shu-make-p-project} \hfill [Command]\\%
 (Alias: make-p-project)

\begin{doc-string}
Create a Python project that is analogous to a c project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-on-the-word-line }}
\usebox{\funcname}
\index{shu-on-the-word-line} \hfill [Function]

\begin{doc-string}
Return the character position of the start of the current word if point is sitting
anywhere on the word ``line''.  This is used pick up file positions of the form:
``line 628 of frobnitz.cpp''
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-other }}
\usebox{\funcname}
\index{shu-other} \hfill [Command]\\%
 (Alias: other)

\begin{doc-string}
Visit an h file from a c file or a c file from an h file If visiting a .h
file, invoke this function and you will be taken to the .c or .cpp file.  If
visiting a .c or .cpp file, invoke this function and you will be taken to the
corresponding .h file.  This function will use a project if one is active.
Otherwise, it will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-possible-cpp-file-name }}
\usebox{\funcname}\textbf{\&optional}
\index{shu-possible-cpp-file-name} \hfill [Function]
\hspace*{\wd\funcname}\emph{any-extension}

\begin{doc-string}
Return a list containing a possible file name with a possible line number
and a possible column number.  If the thing on point does not resemble a file
name, return nil.  If it looks like a file name, save it and call
shu-get-line-column-of-file to perhaps harvest a line number and column number
within the file.  The return result is a list of length one if there is only
a file name, a list of length two if there is a file name and line number, a
list of length three if there is a file name, line number, and column number.
If the optional argument \emph{include-directory} is true, the file name may include
the forward slash character, which means that the returned file name may also
include directory names.  Normally, this function only looks for code files,
but if the optional argument \emph{any-extension} is true, then a file name with any
extension will be returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-cpp-buffer-name }}
\usebox{\funcname}
\index{shu-project-cpp-buffer-name} \hfill [Constant]

\begin{doc-string}
The name of the buffer into which messages are placed as c and h files
are being scanned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-directory-is-excluded }}
\usebox{\funcname}\emph{directory-name}
\index{shu-project-directory-is-excluded} \hfill [Function]

\begin{doc-string}
Return t if the directory name is among those that should be ignored when
looking for files within a project.  Typically, these are the names of
CMake directories that hold generated code.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-exclude-hash }}
\usebox{\funcname}
\index{shu-project-exclude-hash} \hfill [Variable]

\begin{doc-string}
The hash table that holds the directory names from \emph{shu-project-exclude-list}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-exclude-list }}
\usebox{\funcname}
\index{shu-project-exclude-list} \hfill [Constant]

\begin{doc-string}
A list of top level directory names to exclude while creating a project via
\emph{shu-make-c-project}.  This list is ignored by \emph{shu-make-full-c-project}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-extensions }}
\usebox{\funcname}
\index{shu-project-extensions} \hfill [Constant]

\begin{doc-string}
A list of file extensions for all of the file types we want to find.  This is defined
as defconst in shu-cpp-base.el but may be modified by shu-add-cpp-c-extensions or
shu-add-cpp-h-extensions.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-file-list }}
\usebox{\funcname}
\index{shu-project-file-list} \hfill [Variable]

\begin{doc-string}
This is a list of the full path and name of every file in the project.
It is used when a global change needs to visit every file in the project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-file-pattern-match }}
\usebox{\funcname}\emph{name} \emph{pattern}
\index{shu-project-file-pattern-match} \hfill [Function]

\begin{doc-string}
If \emph{pattern} is nil, then all names qualify and this function returns t.
If \emph{pattern} is non-nil, it is a regular expression that must match \emph{name}.  If
\emph{pattern} matches \emph{name}, this function returns true.

This function returns true if \emph{pattern} is nil (all names wanted) or if
\emph{pattern} is not nil and is a regular expression that is matched by \emph{name}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-get-file-info }}
\usebox{\funcname}\emph{plist} \emph{file-name}
\index{shu-project-get-file-info} \hfill [Macro]
\hspace*{\wd\funcname}

\begin{doc-string}
Extract the file information from one entry in shu-cpp-class-list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-get-specific-files }}
\usebox{\funcname}\emph{root} \emph{pattern}
\index{shu-project-get-specific-files} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Starting at \emph{root}, search for all files that meet the following criteria:

\small{\begin{verbatim}
      - If \emph{pattern} is non-nil, it is a regular expression that the file name
        must match.  If \emph{pattern} is nil, then the file names are ignored and all
        files are potentially returned.

      - If \emph{cpp-type} is nil, then file type is ignored and all files are
        potentially returned subject to constraints of \emph{pattern} described above.
\end{verbatim}}

If \emph{pattern} and \emph{cpp-type} are both nil, then all files are returned.

If you wish to find all files that are of type C++, then set \emph{pattern} to nil and
\emph{cpp-type} to t.

If you wish to find all files with similar names that are of type C++, then set
\emph{cpp-type} to t and \emph{pattern} to some regular expression that will filter the files
appropriately, such as ``mumble\_bar*''.

The directories excluded by project search are also excluded here.  There are
typically CMake directories that are populated with temporary files.  See
\emph{shu-project-exclude-list} for a list of excluded directories.

The files are returned as a list of files with paths relative to \emph{root}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-make-exclude-hash }}
\usebox{\funcname}
\index{shu-project-make-exclude-hash} \hfill [Command]

\begin{doc-string}
Turn \emph{shu-project-exclude-list} into the hash table \emph{shu-project-exclude-hash}.
If \emph{shu-project-exclude-list} is nil or not a list or an empty list, then
\emph{shu-project-exclude-hash} is also set to nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-make-short-key-list }}
\usebox{\funcname}\emph{key-list}
\index{shu-project-make-short-key-list} \hfill [Function]

\begin{doc-string}
\emph{key-list} is an alist in which the car of each item is the unqualified file
name and the cdr of each item is the fully qualified file name, including the
path to the file.  This function creates two lists.  One is an alist of all of
the file prefixes.  That car of each item is the prefix.  The cdr of each item
is the number of times that prefix was found.  The second is a list similar to
\emph{key-list} with all of the file names changed to their equivalent short names.  If
the long and short names are the same, then that item is omitted from the new
list of short names.

Return is a cons cell whose car is the prefix list and whose cdr is the short
name list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-some-other }}
\usebox{\funcname}\emph{extension}
\index{shu-project-some-other} \hfill [Function]

\begin{doc-string}
Visit a related file within a project.  If you are in a ``.h'' file and you
wish to go to the corresponding ``.t.cpp'' file, this function will form the new
file name and then look it up within the project to find the location of the
related file and then visit that file, if possible.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-split-file-name }}
\usebox{\funcname}\emph{file-name}
\index{shu-project-split-file-name} \hfill [Function]

\begin{doc-string}
Split \emph{file-name} into two parts.  The first part is the prefix and the second
part is the short name.  The rules for splitting are as follows:

If the name has no underscores, then the prefix is empty and the short name is
the whole name.

If the name has one underscore in it (e.g., ``abcdef\_mumble.cpp''), then the
prefix is the part before the underscore (``abcdef'') and the short name is all
of the rest (``mumble.cpp'').

If the name has more than one underscore in it (e.g., ``x\_abcdef\_mumble.cpp''),
then we look as the length of the first part (``x'').  If its length is one,
then the prefix is the concatenation of the first two parts (``x\_abcdef''), and
the short name is the rest (``mumble.cpp'').  If the length of the first part is
not one (e.g., file name is ``lovely\_looking\_mumble.cpp''), then the prefix is
the first part (``lovely'') and the short name is the rest
(``looking\_mumble.cpp'').

After the split, the short name is converted to all lower case.

Return a cons cell of the form (prefix . short-name)
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-sub-specific-files }}
\usebox{\funcname}\emph{dir-name} \emph{level}
\index{shu-project-sub-specific-files} \hfill [Function]
\hspace*{\wd\funcname}\emph{cpp-type}

\begin{doc-string}
Recursively search for all files as described in
\emph{shu-project-get-specific-files}.

Two lists are accumulated.  DIR-LIST is a list of all directories encountered.
This function calls itself recursively to search all of them for the desired
files.

The global variable \emph{shu-cpp-fetch-list} is used to accumulate the list of
qualified files found.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-project-user-class-count }}
\usebox{\funcname}
\index{shu-project-user-class-count} \hfill [Variable]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-py-extensions }}
\usebox{\funcname}
\index{shu-py-extensions} \hfill [Constant]

\begin{doc-string}
A list of file extensions for Python projects
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-record-visited-project }}
\usebox{\funcname}\emph{name} \emph{proj-dir}
\index{shu-record-visited-project} \hfill [Function]

\begin{doc-string}
Record a project visit in the file ``~/visited-projects.log''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-renew-c-project }}
\usebox{\funcname}
\index{shu-renew-c-project} \hfill [Command]\\%
 (Alias: renew-c-project)

\begin{doc-string}
Renew a previously established project to pick up any new files.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-c-project }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-set-c-project} \hfill [Command]\\%
 (Alias: set-c-project)

\begin{doc-string}
Mark a region in a file that contains one subdirectory name per line.  Then
invoke set-c-project and it will find and remember all of the c and h files in
those subdirectories.  You may then subsequently visit any of those files by
invoking M-x vh which will allow you to type in the file name only (with auto
completion) and will then visit the file in the appropriate subdirectory.  If
this function is called interactively, it clears the project name that was
established by either \emph{shu-setup-project-and-tags} of \emph{shu-visit-project-and-tags}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-dir-prefix }}
\usebox{\funcname}\emph{prefix}
\index{shu-set-dir-prefix} \hfill [Command]\\%
 (Alias: set-dir-prefix)

\begin{doc-string}
Set the default file name prefix to be the current directory name end for those
times when we are trying to visit a project file and point is not sitting on
something that resembles a file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-p-project }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-set-p-project} \hfill [Command]\\%
 (Alias: set-p-project)

\begin{doc-string}
Mark a region in a file that contains one subdirectory name per line.  Then
invoke set-c-project and it will find and remember all of the c and h files in
those subdirectories.  You may then subsequently visit any of those files by
invoking M-x vh which will allow you to type in the file name only (with auto
completion) and will then visit the file in the appropriate subdirectory.  If
this function is called interactively, it clears the project name that was
established by either \emph{shu-setup-project-and-tags} of \emph{shu-visit-project-and-tags}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-prefix }}
\usebox{\funcname}\emph{prefix}
\index{shu-set-prefix} \hfill [Command]\\%
 (Alias: set-prefix)

\begin{doc-string}
Set the default file name prefix for those times when we are trying to visit
a project file and point is not sitting on something that resembles a file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-setup-project-and-tags }}
\usebox{\funcname}\emph{proj-dir}
\index{shu-setup-project-and-tags} \hfill [Function]

\begin{doc-string}
Visit a project file, make a C project from the contents of the whole file,
create a file called ``files.txt'' with the name of every file found, invoke
ctags on that file to build a new tags file, and then visit the tags file.
\emph{proj-dir} is the name of the directory in which the project file exists and in
which the tags file is to be built.
Record the visit in the file ``~/visited-projects.log''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-sub-make-c-project }}
\usebox{\funcname}\emph{proj-root}
\index{shu-sub-make-c-project} \hfill [Function]

\begin{doc-string}
Create a project file of all directories containing c or h files.
Starts at the specified root directory and searches all subdirectories for
any that contain c or h files.  It then inserts all of the directory names
into the current file at point.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-tother }}
\usebox{\funcname}
\index{shu-tother} \hfill [Command]\\%
 (Alias: tother)

\begin{doc-string}
Visit a t.cpp file from the corresponding .cpp or .h file.  If visiting a .c
or .cpp file, invoke this function and you will be taken to the corresponding
.t.cpp file.  This function will use a project if one is active.  Otherwise, it
will assume that all files reside in the same directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-validate-file-in-project }}
\usebox{\funcname}
\index{shu-validate-file-in-project} \hfill [Function]

\begin{doc-string}
Validate that the current file is a member of the current project.

If you are in a project and then visit some file in another directory tree whose
FILE-NAME-NONDIRECTORY matches a file name in the current project, an attempt to
visit a related file by using the project primitives will take you back into the
project tree, when you might have thought that you were going to some other part
of the directory tree you were in.

For example, suppose you are in a project file ``a/b/src/foo/foo.h'' and you
then visit another file in ``x/y/src/foo/foo.h.'' If you then try to go to the
unit test file for ``x/y/src/foo/foo.h,'' instead of visiting
``x/y/test/unit/foo.t.cpp,'' you will, instead, silently be taken to
``a/b/test/unit/foo.t.cpp,'' which is not the unit test file for
``x/y/src/foo/foo.h.''

When visiting related files within a project, this function verifies that the
current file is actually a member of the current project.  If there exists a
project and the current file is not a member of that project, you are probably
about to be taken silently to the wrong file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-vf }}
\usebox{\funcname}
\index{shu-vf} \hfill [Command]\\%
 (Alias: vf)

\begin{doc-string}
If point is on something that looks like a file name, visit the file.  If the
file name is followed by a colon and a number, the number is interpreted as a
line number within the file and point is moved to the beginning of that line.
If the line number is followed by a colon and another number, then the second
number is interpreted as a column number and point is moved to that column
number.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-vh }}
\usebox{\funcname}
\index{shu-vh} \hfill [Command]

\begin{doc-string}
Visit a c or h file in a project.  If point is on something that resembles a file
name, then visit that file.  If the file name is followed by a colon and a number
then go to that line in the file.  If the line number is followed by a colon and
a number then use the second number as the column number within the line.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-visit-project-and-tags }}
\usebox{\funcname}\emph{proj-dir}
\index{shu-visit-project-and-tags} \hfill [Function]

\begin{doc-string}
Visit a project file, make a C project from the contents of the whole file,
and load that tags table from the tags file in the specified directory.  This
function uses the existing tags table, whereas \emph{shu-setup-project-and-tags}
creates a new tags table.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-vj }}
\usebox{\funcname}
\index{shu-vj} \hfill [Command]

\begin{doc-string}
Visit a c or h file in a project.  Ignore any text that point is on and visit the
file typed in the completion buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-which-c-project }}
\usebox{\funcname}
\index{shu-which-c-project} \hfill [Command]\\%
 (Alias: which-c-project)

\begin{doc-string}
Identify the current project by putting into a project buffer the name of the file
from which the project was derived as well as the name of all of the directories in the
project.  Then switch to that buffer.  The idea is to invoke this function, look at the
results in that buffer, and then quit out of the buffer.
\end{doc-string}

\eject
\section{shu-cpp-token}


Functions to parse a region of C++ code and return a list of tokens
found therein.  The returned list is a list of token-info, whose structure
is shown below.

The two top level functions in this file are shu-cpp-tokenize-region and
shu-cpp-reverse-tokenize-region.  The former returns a list of tokens with the
first token in the list being the first token found.  The latter function
returns the reverse of the former.

The tokenized lists are used by the functions in shu-cpp-match.el and
shu-match.el to find and retrieve patterns in the token lists.


\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{parse-region }}
\usebox{\funcname}\emph{start} \emph{end}
\index{parse-region} \hfill [Command]\\%
 (Function: shu-cpp-parse-region)

\begin{doc-string}
Parse the region between \emph{start} and \emph{end} into a list of all of the C++ tokens
contained therein, displaying the result in the Shu unit test buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{reverse-parse-region }}
\usebox{\funcname}\emph{start} \emph{end}
\index{reverse-parse-region} \hfill [Command]\\%
 (Function: shu-cpp-reverse-parse-region)

\begin{doc-string}
Reverse parse the region between \emph{start} and \emph{end} into a list of all of the C++
tokens contained therein, displaying the result in the Shu unit test buffer.
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-adjust-template-parameters }}
\usebox{\funcname}\emph{token-list}
\index{shu-cpp-adjust-template-parameters} \hfill [Function]

\begin{doc-string}
Turn each set of template parameters in a reverse parsed list (anything between
``$>$`` and ``$<$`` into a separate token of type \emph{shu-cpp-token-type-tp}.  e.g., the
five separate tokens ``$>$``, ``double'', ``,'', ``int'', ``$<$`` will be turned into
one new token of type \emph{shu-cpp-token-type-tp} whose token value is ``int, double''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-compare-tlist-sans-comment }}
\usebox{\funcname}\emph{token-list1}
\index{shu-cpp-compare-tlist-sans-comment} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Compare the two lists of TOKEN-INFO skipping comments and stopping at the end
of the shortest one.  The purpose of this function is to determine if two bits
of reverse parsed code have the same suffix.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-compare-token-info }}
\usebox{\funcname}\emph{token-info1} \emph{token-info2}
\index{shu-cpp-compare-token-info} \hfill [Function]

\begin{doc-string}
Compare the two instances of TOKEN-INFO, returning true if their contents
are the same.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-compare-token-info-sans-pos }}
\usebox{\funcname}\emph{token-info1}
\index{shu-cpp-compare-token-info-sans-pos} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Compare the two instances of TOKEN-INFO, returning true if their contents
are the same.  Do not include the start or end points in the comparison.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-copy-token-info }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-copy-token-info} \hfill [Function]

\begin{doc-string}
Return a deep copy of the given \emph{token-info}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-get-comment }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-cpp-get-comment} \hfill [Function]

\begin{doc-string}
Get the comment that starts at point.  If it starts with //, get to end of
line.  If it starts with /\emph\{*,\} skip to terminating \emph\{*/.\}  If there is no terminating
\emph\{*/\} in the region, create a TOKEN-INFO with the appropriate error message in it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-get-operator-token }}
\usebox{\funcname}\emph{length}
\index{shu-cpp-get-operator-token} \hfill [Function]

\begin{doc-string}
Fetch the C++ operator that starts at point.  \emph{length} is the number of characters
in the operator, which is either 1, 2, or 3.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-get-quoted-token }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-cpp-get-quoted-token} \hfill [Function]

\begin{doc-string}
Find the token in the buffer between \emph{start} and \emph{end} that is terminated by an
unescaped quote.  On entry, point must be positioned on the quote that starts
the string.  The appropriate error message is returned if there is no unescaped
quote before the end of the current line.  If the character under point is not a
quote start character, nil is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-get-unquoted-token }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-cpp-get-unquoted-token} \hfill [Function]

\begin{doc-string}
Find the unquoted token in the buffer that starts at point.  The token is
terminated either by the position of \emph{end} or by the regular expression that
defines the end of an unquoted token.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-is-reverse-token-list-balanced }}
\usebox{\funcname}\emph{token-list}
\index{shu-cpp-is-reverse-token-list-balanced} \hfill [Function]
\hspace*{\wd\funcname}\emph{close-char}

\begin{doc-string}
Return t if a token-list contains matched pairs of \emph{open-char} and \emph{close-char}.
If imbalance is present, print error message and return nil.  Typically \emph{open-char}
might be a left parenthesis and \emph{close-char} might be a right parenthesis.  Or they
might be ``$<$`` and ``$>$``, or any other pair types.  Note that this function
returns t if there are no occurrences of \emph{open-char} and \emph{close-char}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-make-token-info }}
\usebox{\funcname}\emph{token} \emph{token-type} \emph{spoint}
\index{shu-cpp-make-token-info} \hfill [Function]
\hspace*{\wd\funcname}\textbf{\&optional} \emph{error-message}

\begin{doc-string}
Pack the supplied arguments into a TOKEN-INFO and return the TOKEN-INFO.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-operator-start }}
\usebox{\funcname}
\index{shu-cpp-operator-start} \hfill [Constant]

\begin{doc-string}
Define the set of characters that start C++ operators
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-operator-start-chars }}
\usebox{\funcname}
\index{shu-cpp-operator-start-chars} \hfill [Constant]

\begin{doc-string}
Define the set of characters that start C++ operators
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-operators-one }}
\usebox{\funcname}
\index{shu-cpp-operators-one} \hfill [Constant]

\begin{doc-string}
Define the set of one character operators.  Note that we include ; as
an operator, even though, strictly speaking, it is not an operator.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-operators-three }}
\usebox{\funcname}
\index{shu-cpp-operators-three} \hfill [Constant]

\begin{doc-string}
Define the set of three character C++ operators
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-operators-two }}
\usebox{\funcname}
\index{shu-cpp-operators-two} \hfill [Constant]

\begin{doc-string}
Define the set of two character C++ operators
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-parse-region }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-cpp-parse-region} \hfill [Command]\\%
 (Alias: parse-region)

\begin{doc-string}
Parse the region between \emph{start} and \emph{end} into a list of all of the C++ tokens
contained therein, displaying the result in the Shu unit test buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-remove-template-parameters }}
\usebox{\funcname}\emph{token-list}
\index{shu-cpp-remove-template-parameters} \hfill [Function]
\hspace*{\wd\funcname}\emph{preserve-template}

\begin{doc-string}
Remove from the token-list any template parameters (anything between ``$>$``
and its matching ``$>$``).  In addition, adjust the end point of the token
immediately prior to the template parameter to be that of the endpoint of the
template parameter.
Thus something like the following:
\small{\begin{verbatim}
    Mumble<int, double>
\end{verbatim}}
becomes the token ``Mumble'' with a length of 19.  If \emph{preserve-template} is true,
then we change the token that contains the type name by copying the template
parameters into it.  If the type name token was ``Mumble'', then the token
itself is changed to ``Mumble$<$int, double$>$``.  The tokens that represent the
template parameters are removed from the token list in either case.
This eliminates any comma that does not immediately follow a parameter name.
As we scan the reverse ordered token list, any comma that we find immediately
precedes a variable name in the parameter list.  There may be intervening
operators and comments.  But once we find a comma, the next unquoted token is
the variable name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-replace-token-info }}
\usebox{\funcname}\emph{token-info} \emph{token}
\index{shu-cpp-replace-token-info} \hfill [Function]
\hspace*{\wd\funcname}\emph{spoint} \emph{epoint} \textbf{\&optional}
\hspace*{\wd\funcname}

\begin{doc-string}
Replace the supplied arguments in the given \emph{token-info} and return the \emph{token-info}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-reverse-parse-region }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-cpp-reverse-parse-region} \hfill [Command]\\%
 (Alias: reverse-parse-region)

\begin{doc-string}
Reverse parse the region between \emph{start} and \emph{end} into a list of all of the C++
tokens contained therein, displaying the result in the Shu unit test buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-reverse-tokenize-region }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-cpp-reverse-tokenize-region} \hfill [Function]
\hspace*{\wd\funcname}\emph{limit}

\begin{doc-string}
Scan the region between \emph{start} and AND to build a list of tokens that represent the C++
code in the region.  Return a cons cell with two items in it.  The car of the cons cell
is a token-info that represents a parse error.  The cdr of the cons cell is the list of
tokens.  This list is incomplete if the car of the cons sell is not nil.  The optional
\emph{limit} argument is used to bound the scan as follows.  When we have added to the list the
first token that is beyond the point specified by \emph{limit}, we stop the scan.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-reverse-tokenize-region-for-command }}
\usebox{\funcname}\emph{start}
\index{shu-cpp-reverse-tokenize-region-for-command} \hfill [Function]
\hspace*{\wd\funcname}\textbf{\&optional}
\hspace*{\wd\funcname}

\begin{doc-string}
Reverse tokenize the region between \emph{start} and \emph{end} into a list of all of the C++
tokens contained therein, displaying any error message, if there is one.  If no
error, return the token list, else return nil
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-delimiter-chars }}
\usebox{\funcname}
\index{shu-cpp-token-delimiter-chars} \hfill [Constant]

\begin{doc-string}
List of all of the characters that terminate an unquoted C++ token
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-delimiter-end }}
\usebox{\funcname}
\index{shu-cpp-token-delimiter-end} \hfill [Constant]

\begin{doc-string}
Regular expression to define that which terminates an unquoted token in C++
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-extract-epoint }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-extract-epoint} \hfill [Function]

\begin{doc-string}
Return the end point from an instance of token-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-extract-info }}
\usebox{\funcname}\emph{token-info} \emph{token}
\index{shu-cpp-token-extract-info} \hfill [Macro]
\hspace*{\wd\funcname}\emph{spoint} \emph{epoint}
\hspace*{\wd\funcname}

\begin{doc-string}
Extract the information out of a token-info
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-extract-nesting-level }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-extract-nesting-level} \hfill [Function]

\begin{doc-string}
Return the nesting level from an instance of token-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-extract-spoint }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-extract-spoint} \hfill [Function]

\begin{doc-string}
Return the start point from an instance of token-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-extract-token }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-extract-token} \hfill [Function]

\begin{doc-string}
Return the token from an instance of token-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-extract-type }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-extract-type} \hfill [Function]

\begin{doc-string}
Return the token type from an instance of token-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-find-spanning-info-token }}
\usebox{\funcname}\emph{token-list}
\index{shu-cpp-token-find-spanning-info-token} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Find the token-info in \emph{token-list} that spans \emph{here-point}, if any.  If there
is no such token-info return nil.  If there is such a token-info, return a
cons cell whose car is the spanning token-info and whose cdr is a pointer
to the next token-info in the tlist.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-first-non-comment }}
\usebox{\funcname}\emph{tlist}
\index{shu-cpp-token-first-non-comment} \hfill [Function]

\begin{doc-string}
\emph{tlist} points to a list of token-info.  Return \emph{tlist} pointing to the next
token-info that does not hold a comment.  If you are scanning through a list
of tokens, it is not uncommon to want to skip all of the comments.  Use this
at the bottom of the loop in place of the usual ``setq tlist (cdr tlist))''.

i.e.,

\small{\begin{verbatim}
     (while tlist
        ...
       (setq tlist (cdr tlist)))
\end{verbatim}}

becomes

\small{\begin{verbatim}
     (setq tlist (shu-cpp-token-first-non-comment tlist))
     (while tlist
        ...
       (setq tlist (shu-cpp-token-first-non-comment tlist)))
\end{verbatim}}

and you will scan through the list without seeing any comments.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-info-replace-epoint }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-info-replace-epoint} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Replace the EPOINT of \emph{token-info} with \emph{new-epoint}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-info-replace-token }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-info-replace-token} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Replace the TOKEN of \emph{token-info} with \emph{new-token}, returning the
modified \emph{token-info}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-internal-parse-region }}
\usebox{\funcname}\emph{func} \emph{start} \emph{end}
\index{shu-cpp-token-internal-parse-region} \hfill [Function]

\begin{doc-string}
Internal function to do a forward or reverse parse of the region between \emph{start}
and \emph{end}.  \emph{func} holds the function to be invoked to do the parse.  This would be
either \emph{shu-cpp-tokenize-region} or \emph{shu-cpp-reverse-tokenize-region}.  Once the
parse is complete, the token list is shown in the Shu unit test buffer.  If any
error is detected, it is displayed at the point at which the error was
detected.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-internal-tokenize-region-for-command }}
\usebox{\funcname}\emph{func}
\index{shu-cpp-token-internal-tokenize-region-for-command} \hfill [Function]
\hspace*{\wd\funcname}\emph{end}
\hspace*{\wd\funcname}\emph{limit}

\begin{doc-string}
Internal function to do a forward or reverse parse of the region between \emph{start}
and \emph{end}.  \emph{func} holds the function to be invoked to do the parse.  This would be
either shu-cpp-tokenize-region or shu-cpp-reverse-tokenize-region.  Once the
parse is complete, we check to see if an error was detected.  If an error was
detected we go to the error point and show the error.  Then we return nil to the
caller.  If no error was detected, we return the token-list to the caller.  This
is a convenient way for a command to get the token-list and not have to do anything
to display an error message if an error is encountered.  The command calls this
function and simply exits if nil is returned, knowing that the error message has
already been displayed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-is-comment }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-is-comment} \hfill [Function]

\begin{doc-string}
Return true if the token-info represents a comment.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-next-non-comment }}
\usebox{\funcname}\emph{tlist}
\index{shu-cpp-token-next-non-comment} \hfill [Function]

\begin{doc-string}
\emph{tlist} points to a list of token-info.  Return \emph{tlist} pointing to the next
token-info that does not hold a comment.  If you are scanning through a list
of tokens, it is not uncommon to want to skip all of the comments.  Use this
at the bottom of the loop in place of the usual ``setq tlist (cdr tlist))''.

i.e.,

\small{\begin{verbatim}
     (while tlist
        ...
       (setq tlist (cdr tlist)))
\end{verbatim}}

becomes

\small{\begin{verbatim}
     (while tlist
        ...
       (setq tlist (shu-cpp-token-next-non-comment tlist)))
\end{verbatim}}

and you will scan through the list without seeing any comments.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-set-alias }}
\usebox{\funcname}
\index{shu-cpp-token-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-cpp-token.
These are usually the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-set-nesting-level }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-set-nesting-level} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Set the nesting level in an instance of token-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-show-token-info }}
\usebox{\funcname}\emph{token-info} \textbf{\&optional}
\index{shu-cpp-token-show-token-info} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Show the data returned by one of the functions in this file that scans for tokens.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-show-token-info-buffer }}
\usebox{\funcname}\emph{token-info} \emph{gb}
\index{shu-cpp-token-show-token-info-buffer} \hfill [Function]
\hspace*{\wd\funcname}\emph{title}

\begin{doc-string}
Show the data returned by one of the functions in this file that scans for tokens.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-string-token-info }}
\usebox{\funcname}\emph{token-info}
\index{shu-cpp-token-string-token-info} \hfill [Command]

\begin{doc-string}
Return a string that represents the contents of the token-info.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-token-type-name }}
\usebox{\funcname}\emph{token-type}
\index{shu-cpp-token-token-type-name} \hfill [Function]

\begin{doc-string}
Return the name of a token type.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-type-cc }}
\usebox{\funcname}
\index{shu-cpp-token-type-cc} \hfill [Constant]

\begin{doc-string}
Token type that indicates a line in which the first non-blank item is a
comment that starts in a column greater than or equal to the column defined
by shu-cpp-comment-start.  This is known as a code comment with no code present.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-type-ct }}
\usebox{\funcname}
\index{shu-cpp-token-type-ct} \hfill [Constant]

\begin{doc-string}
Token type that indicates a comment
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-type-kw }}
\usebox{\funcname}
\index{shu-cpp-token-type-kw} \hfill [Constant]

\begin{doc-string}
Token type that indicates a C++ key word
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-type-op }}
\usebox{\funcname}
\index{shu-cpp-token-type-op} \hfill [Constant]

\begin{doc-string}
Token type that indicates an operator
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-type-qt }}
\usebox{\funcname}
\index{shu-cpp-token-type-qt} \hfill [Constant]

\begin{doc-string}
Token type that indicates a quoted string
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-type-tp }}
\usebox{\funcname}
\index{shu-cpp-token-type-tp} \hfill [Constant]

\begin{doc-string}
Token type that indicates a template parameter.  The standard parsing does nothing
with template parameters.  Something like ``$<$int$>$`` is simply turned into three separate
tokens, ``$<$``, ``int'', and ``$>$`` (or ``$>$``, ``int'', and ``$<$`` in a reverse parse).
But some of the other transform functions will turn this list of tokens into the single
template parameter ``int''
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-token-type-uq }}
\usebox{\funcname}
\index{shu-cpp-token-type-uq} \hfill [Constant]

\begin{doc-string}
Token type that indicates an unquoted token
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-tokenize-region }}
\usebox{\funcname}\emph{start} \emph{end} \textbf{\&optional} \emph{limit}
\index{shu-cpp-tokenize-region} \hfill [Function]

\begin{doc-string}
Scan the region between \emph{start} and AND to build a list of tokens that represent the C++
code in the region.  Return a cons cell with two items in it.  The car of the cons cell
is a token-info that represents a parse error.  The cdr of the cons cell is the list of
tokens.  This list is incomplete if the car of the cons cell is not nil.  The optional
\emph{limit} argument is used to bound the scan as follows.  When we have added to the list the
first token that is beyond the point specified by \emph{limit}, we stop the scan.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-tokenize-region-for-command }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-cpp-tokenize-region-for-command} \hfill [Function]
\hspace*{\wd\funcname}\emph{limit}

\begin{doc-string}
Tokenize the region between \emph{start} and \emph{end} into a list of all of the C++
tokens contained therein, displaying any error message, if there is one.  If no
error, return the token list, else return nil
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-tokenize-show-list }}
\usebox{\funcname}\emph{token-list} \textbf{\&optional}
\index{shu-cpp-tokenize-show-list} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-tokenize-show-list-buffer }}
\usebox{\funcname}\emph{token-list} \emph{gb}
\index{shu-cpp-tokenize-show-list-buffer} \hfill [Function]
\hspace*{\wd\funcname}\emph{title}

\begin{doc-string}
Undocumented
\end{doc-string}

\eject
\section{shu-git}



A collection of functions for interacting with git


\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{copy-branch }}
\usebox{\funcname}
\index{copy-branch} \hfill [Command]\\%
 (Function: shu-git-copy-branch)

\begin{doc-string}
Put the name of the current branch in a git repository into the kill ring.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{diff-commits }}
\usebox{\funcname}\emph{commit-range}
\index{diff-commits} \hfill [Command]\\%
 (Function: shu-git-diff-commits)

\begin{doc-string}
In a buffer that is a numbered git log, query for a range string, find the two
commits, and put into the kill ring a git diff command specifying the two commits.

For example, given the following two numbered commits:

\small{\begin{verbatim}
    31. commit 38f25b6769385dbc3526f32a75b97218cb4a6754
    33. commit 052ee7f4297206f08d44466934f1a52678da6ec9
\end{verbatim}}

if the commit range specified is either ``31.33'' or ``31+2'', then the following
is put into the kill ring:

\small{\begin{verbatim}
    ``git diff -b 38f25b6769385dbc3526f32a75b97218cb4a6754..052ee7f4297206f08d44466934f1a52678da6ec9 ``
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gcm }}
\usebox{\funcname}
\index{gcm} \hfill [Command]\\%
 (Function: shu-git-insert-git-commit)

\begin{doc-string}
Insert at point the name the git command to commit with the commentary held
in a file called ``why.txt''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gco }}
\usebox{\funcname}
\index{gco} \hfill [Command]\\%
 (Function: shu-git-insert-checkout-default)

\begin{doc-string}
Insert at point the git command to check out the current default branch.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{get-pr-url }}
\usebox{\funcname}
\index{get-pr-url} \hfill [Command]\\%
 (Function: shu-git-get-pr-url)

\begin{doc-string}
Put into the kill ring the path required to create a new pull request for
the current branch of the current repository.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gpl }}
\usebox{\funcname}
\index{gpl} \hfill [Command]\\%
 (Function: shu-git-insert-pull-origin-branch)

\begin{doc-string}
Insert at point the name the git command to pull the current branch from
origin.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gps }}
\usebox{\funcname}
\index{gps} \hfill [Command]\\%
 (Function: shu-git-insert-push-origin-branch)

\begin{doc-string}
Insert at point the git command to push the current branch out to origin.  If
the current branch is the default branch (fka ``master''), you are prompted to
see if you want to proceed.  This is to prevent an accidental push to the
default branch.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{insb }}
\usebox{\funcname}
\index{insb} \hfill [Command]\\%
 (Function: shu-git-insert-branch)

\begin{doc-string}
Insert at point the name of the current branch in a git repository
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{inso }}
\usebox{\funcname}
\index{inso} \hfill [Command]\\%
 (Function: shu-git-insert-origin-branch)

\begin{doc-string}
Insert at point the name of the current branch in a git repository preceded by the
word ``origin''..  This can be used as part of git push or pull.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{number-commits }}
\usebox{\funcname}
\index{number-commits} \hfill [Command]\\%
 (Function: shu-git-number-commits)

\begin{doc-string}
In a git log buffer, number all of the commits with zero being the most
recent.

It is possible to refer to commits by their SHA-1 hash.  If you want to see the
difference between two commits you can ask git to show you the difference by
specifying the commit hash of each one.  But this is cumbersome.  It involves
copying and pasting two SHA-1 hashes.  Once the commits are numbered, then
\emph{shu-git-diff-commits} may be used to diff two commits by number.  See the
documentation for \emph{shu-git-diff-commits} for further information.

This function counts as a commit any instance of ``commit'' that starts at the
beginning of a line and is followed by some white space and a forty character
hexadecimal number.  Returns the count of the number of commits found.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{show-branch }}
\usebox{\funcname}
\index{show-branch} \hfill [Command]\\%
 (Function: shu-git-show-branch)

\begin{doc-string}
Display the name of the current branch in a git repository.
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-find-numbered-commit }}
\usebox{\funcname}\emph{commit-number}
\index{shu-find-numbered-commit} \hfill [Function]

\begin{doc-string}
Search through a numbered git commit log looking for the commit whose number is
\emph{commit-number}.  Return the SHA-1 hash of the commit if the commit number is found.
Return nil if no commit with the given number is found.
The commit log is assume to have been numbered by shu-git-number-commits.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-add-file }}
\usebox{\funcname}\emph{filename}
\index{shu-git-add-file} \hfill [Function]

\begin{doc-string}
Do a ``git add'' for \emph{filename}.  Return empty string if add succeeds.  Otherwise,
return git error message.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-are-files-in-git }}
\usebox{\funcname}\emph{files}
\index{shu-git-are-files-in-git} \hfill [Function]

\begin{doc-string}
Given a list of file names in \emph{files}, return a cons cell whose CAR holds the
number of files that are under git control and whose CDR holds the number of
files that are not under git control.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-copy-branch }}
\usebox{\funcname}
\index{shu-git-copy-branch} \hfill [Command]\\%
 (Alias: copy-branch)

\begin{doc-string}
Put the name of the current branch in a git repository into the kill ring.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-diff-commits }}
\usebox{\funcname}\emph{commit-range}
\index{shu-git-diff-commits} \hfill [Command]\\%
 (Alias: diff-commits)

\begin{doc-string}
In a buffer that is a numbered git log, query for a range string, find the two
commits, and put into the kill ring a git diff command specifying the two commits.

For example, given the following two numbered commits:

\small{\begin{verbatim}
    31. commit 38f25b6769385dbc3526f32a75b97218cb4a6754
    33. commit 052ee7f4297206f08d44466934f1a52678da6ec9
\end{verbatim}}

if the commit range specified is either ``31.33'' or ``31+2'', then the following
is put into the kill ring:

\small{\begin{verbatim}
    ``git diff -b 38f25b6769385dbc3526f32a75b97218cb4a6754..052ee7f4297206f08d44466934f1a52678da6ec9 ``
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-find-branch }}
\usebox{\funcname}
\index{shu-git-find-branch} \hfill [Function]

\begin{doc-string}
Return the name of the current branch in a git repository.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-find-default-branch }}
\usebox{\funcname}
\index{shu-git-find-default-branch} \hfill [Function]

\begin{doc-string}
Return the name of the default branch in a git repository.  The default
branch is the one branch that is created with a new repository.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-find-short-hash }}
\usebox{\funcname}\emph{hash}
\index{shu-git-find-short-hash} \hfill [Function]

\begin{doc-string}
Return the git short hash for the \emph{hash} supplied as an argument.  Return nil
if the given \emph{hash} is not a valid git revision.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-get-pr-url }}
\usebox{\funcname}
\index{shu-git-get-pr-url} \hfill [Command]\\%
 (Alias: get-pr-url)

\begin{doc-string}
Put into the kill ring the path required to create a new pull request for
the current branch of the current repository.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-insert-branch }}
\usebox{\funcname}
\index{shu-git-insert-branch} \hfill [Command]\\%
 (Alias: insb)

\begin{doc-string}
Insert at point the name of the current branch in a git repository
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-insert-checkout-default }}
\usebox{\funcname}
\index{shu-git-insert-checkout-default} \hfill [Command]\\%
 (Alias: gco)

\begin{doc-string}
Insert at point the git command to check out the current default branch.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-insert-git-commit }}
\usebox{\funcname}
\index{shu-git-insert-git-commit} \hfill [Command]\\%
 (Alias: gcm)

\begin{doc-string}
Insert at point the name the git command to commit with the commentary held
in a file called ``why.txt''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-insert-origin-branch }}
\usebox{\funcname}
\index{shu-git-insert-origin-branch} \hfill [Command]\\%
 (Alias: inso)

\begin{doc-string}
Insert at point the name of the current branch in a git repository preceded by the
word ``origin''..  This can be used as part of git push or pull.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-insert-pull-origin-branch }}
\usebox{\funcname}
\index{shu-git-insert-pull-origin-branch} \hfill [Command]\\%
 (Alias: gpl)

\begin{doc-string}
Insert at point the name the git command to pull the current branch from
origin.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-insert-push-origin-branch }}
\usebox{\funcname}
\index{shu-git-insert-push-origin-branch} \hfill [Command]\\%
 (Alias: gps)

\begin{doc-string}
Insert at point the git command to push the current branch out to origin.  If
the current branch is the default branch (fka ``master''), you are prompted to
see if you want to proceed.  This is to prevent an accidental push to the
default branch.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-is-file-in-git }}
\usebox{\funcname}\emph{filename}
\index{shu-git-is-file-in-git} \hfill [Function]

\begin{doc-string}
Return t if \emph{filename} is in a git repository and the file is registered with git.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-move-file }}
\usebox{\funcname}\emph{old-file} \emph{new-file}
\index{shu-git-move-file} \hfill [Function]

\begin{doc-string}
Issue ``git mv old-file new-file''.

Return a cons cell whose CAR is t if the move succeeded and whose CDR is the
output of the git move command.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-move-string }}
\usebox{\funcname}\emph{old-file} \emph{new-file}
\index{shu-git-move-string} \hfill [Function]

\begin{doc-string}
Return the ``git mv'' command to rename \emph{old-file} to \emph{new-file}.  The result is
not intended to be executed.  It is intended for use in messages that explain
what operation is being done.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-number-commits }}
\usebox{\funcname}
\index{shu-git-number-commits} \hfill [Command]\\%
 (Alias: number-commits)

\begin{doc-string}
In a git log buffer, number all of the commits with zero being the most
recent.

It is possible to refer to commits by their SHA-1 hash.  If you want to see the
difference between two commits you can ask git to show you the difference by
specifying the commit hash of each one.  But this is cumbersome.  It involves
copying and pasting two SHA-1 hashes.  Once the commits are numbered, then
\emph{shu-git-diff-commits} may be used to diff two commits by number.  See the
documentation for \emph{shu-git-diff-commits} for further information.

This function counts as a commit any instance of ``commit'' that starts at the
beginning of a line and is followed by some white space and a forty character
hexadecimal number.  Returns the count of the number of commits found.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-set-alias }}
\usebox{\funcname}
\index{shu-git-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-git.
These are generally the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-git-show-branch }}
\usebox{\funcname}
\index{shu-git-show-branch} \hfill [Command]\\%
 (Alias: show-branch)

\begin{doc-string}
Display the name of the current branch in a git repository.
\end{doc-string}

\eject
\section{shu-keyring}


This is a set of functions for maintaining and querying a keyring of names,
URLs, users IDs, passwords, and related information that are maintained in an
external keyring file.

Functions allow you to find a keyring entry by name and to put one piece of
its information, such as user ID or password, in the clip board, from which it
may be pasted into a browser or other application.

The keyring file may be encrypted with GPG.  As of emacs 23, the EasyPG
package is included with the emacs distribution.  When you tell emacs to open
a file that has been encrypted with GPG, you are prompted for the passphrase
and the file is decrypted into memory.

The file keyring.txt in the usr directory is am example of a small
keyring file that has not been encrypted.  Each entry in the file consists of
a set of name value pairs.  Each value may be enclosed in quotes and must be
enclosed in quotes if it contains embedded blanks.

A single set of name value pairs starts with an opening "$<$" and is terminated
by a closing "/$>$".

Here is an example of a set of name value pairs:

\small{\begin{verbatim}
     < name="Fred email" url=mail.google.com  id=freddy@gmail.com  pw=secret />
\end{verbatim}}

The names may be arbitrary but there are six names that are recognized by the
functions in this package.  They are:

acct represents an account number

id represents a user ID

name represents the name of the entry.  This is the key that is used to find
the entry.  If no name is given, then the name of the URL is used.  If the URL
starts with "www.", the "www." is removed to form the name.  An entry that has
no name and a URL of "www.facebook.com" would have an auto generated name of
"facebook.com".

pin represents a pin number

pw represents a password

url represents a URL

To use a keying file, place the following lines in your .emacs file:

\small{\begin{verbatim}
     (load-file "/Users/fred/.emacs.d/shu-base.elc")
     (load-file "/Users/fred/.emacs.d/shu-nvplist.elc")
     (load-file "/Users/fred/.emacs.d/shu-keyring.elc")
     (shu-keyring-set-alias)
     (setq shu-keyring-file "/Users/fred/shu/usr/keyring.txt")
\end{verbatim}}

replacing "/Users/fred/shu/usr/keyring.txt" with the path to your keyring file.

All of the shu functions require shu-base.

If using the sample keyring file, Fred can now use this to log onto his gmail
account as follows.

Type M-x krurl.  This prompts for the name of the desired key.  Type "Fred em"
and hit TAB to complete.  This fills out the name as "Fred email" and puts the
URL "mail.google.com" into the clip board.  Open a browser and paste the URL
into it to go to gmail.  At gmail, select login.  In emacs type M-x krid.
When prompted for the key, use the up arrow to retrieve the last key used,
which will be "Fred email".  This puts "freddy@gmail.com" into the clip board
for conveniently pasting into the gmail widow.  To obtain the password, type
M-x krpw.  This puts the password into the clip board from which it may be
pasted into the gmail widow.


\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{kracct }}
\usebox{\funcname}
\index{kracct} \hfill [Command]\\%
 (Function: shu-keyring-get-acct)

\begin{doc-string}
Find the account for an entry in the keyring file.  This displays the entry in the message
area and puts the password into the kill ring so that it can be yanked or pasted into the application
requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{krfn }}
\usebox{\funcname}
\index{krfn} \hfill [Command]\\%
 (Function: shu-keyring-get-file)

\begin{doc-string}
Display the name of the keyring file, if any.  This is useful if you are
getting unexpected results from some of the query functions that look up keyring
information.  Perhaps the unexpected results come from the fact that you are
using the wrong keyring file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{krid }}
\usebox{\funcname}
\index{krid} \hfill [Command]\\%
 (Function: shu-keyring-get-id)

\begin{doc-string}
Find the User Id for an entry in the keyring file.  This displays the entry
in the message area and puts the user Id into the kill ring so that it can be
yanked into a buffer or pasted into the application requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{krpin }}
\usebox{\funcname}
\index{krpin} \hfill [Command]\\%
 (Function: shu-keyring-get-pin)

\begin{doc-string}
Find the pin for an entry in the keyring file.  This displays the entry in
the message area and puts the pin into the kill ring so that it can be yanked
into a buffer or pasted into the application requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{krpps }}
\usebox{\funcname}
\index{krpps} \hfill [Command]\\%
 (Function: shu-keyring-get-passphrase)

\begin{doc-string}
Doc string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{krpw }}
\usebox{\funcname}
\index{krpw} \hfill [Command]\\%
 (Function: shu-keyring-get-pw)

\begin{doc-string}
Find the password for an entry in the keyring file.  This displays the entry
(without the password) in the message area and puts the password into the kill
ring so that it can be yanked into a buffer or pasted into the application
requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{krurl }}
\usebox{\funcname}
\index{krurl} \hfill [Command]\\%
 (Function: shu-keyring-get-url)

\begin{doc-string}
Find the url for an entry in the keyring file.  This displays the entry in
the message area and puts the url into the kill ring so that it can be yanked
into a buffer or pasted into the application requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{krvf }}
\usebox{\funcname}
\index{krvf} \hfill [Command]\\%
 (Function: shu-keyring-verify-file)

\begin{doc-string}
Parse and verify the keyring file, displaying the result of the operation in the
keyring buffer (\emph\{**shu-keyring**\}).  If one of the queries for a url or other
piece of information is unable to find the requested information, it could be
that you have the wrong keyring file or that there is a syntax error in the
keyring file.  shu-keyring-get-file (alias krfn) displays the name of the
keyring file.  This function parses the keyring file.  After the operation. look
into the keyring buffer (\emph\{**shu-keyring**\}) to see if there are any complaints
about syntax errors in the file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-passphrase }}
\usebox{\funcname}\emph{phrase}
\index{set-passphrase} \hfill [Command]\\%
 (Function: shu-keyring-set-passphrase)

\begin{doc-string}
Function to read and set the external pass phrase.
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-account-name }}
\usebox{\funcname}
\index{shu-keyring-account-name} \hfill [Constant]

\begin{doc-string}
Key word that denotes a name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-add-values-to-index }}
\usebox{\funcname}\emph{index} \emph{vlist} \emph{item}
\index{shu-keyring-add-values-to-index} \hfill [Function]

\begin{doc-string}
Add a set of keys \emph{vlist} to \emph{index} for \emph{item}.  Keys within the item are filtered for
duplicates.  But this does not prevent two different items from sharing the same key,
although it would be unusual in a keyring.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-buffer-name }}
\usebox{\funcname}
\index{shu-keyring-buffer-name} \hfill [Constant]

\begin{doc-string}
The name of the buffer into which keyring diagnostics and messages
are recorded.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-clear-index }}
\usebox{\funcname}
\index{shu-keyring-clear-index} \hfill [Function]

\begin{doc-string}
This is called from after-save-hook to clear the keyring index if the keyring file is saved.
The keyring index is built the first time it is needed and kept in memory thereafter.  But we
must refresh the index if the keyring file is modified.  The easiest way to do this is to clear
the index when the keyring file is modified.  The next time the index is needed it will be
recreated.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-external-passphrase }}
\usebox{\funcname}
\index{shu-keyring-external-passphrase} \hfill [Variable]

\begin{doc-string}
Holds the external passphrase for the keyring file.  This allows the user
to type the passphrase at the beginning of an emacs session.  Once this is
set it can then be put into kill ring by shu-keyring-get-passphrase.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-file }}
\usebox{\funcname}
\index{shu-keyring-file} \hfill [Custom]

\begin{doc-string}
Text file in which urls, names, and passwords are stored.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-find-index-duplicates }}
\usebox{\funcname}\emph{index}
\index{shu-keyring-find-index-duplicates} \hfill [Function]

\begin{doc-string}
Find any duplicates in the keyring index.  When the index is built we filter duplicate
keys for the same item.  But there could be two different items with the same key.  This
function returns TRUE if two or more items have the same key.  The index must be in sorted
order by key value before this function is called.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-get-acct }}
\usebox{\funcname}
\index{shu-keyring-get-acct} \hfill [Command]\\%
 (Alias: kracct)

\begin{doc-string}
Find the account for an entry in the keyring file.  This displays the entry in the message
area and puts the password into the kill ring so that it can be yanked or pasted into the application
requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-get-field }}
\usebox{\funcname}\emph{name}
\index{shu-keyring-get-field} \hfill [Function]

\begin{doc-string}
Fetch the value of a named field from the keyring.  Prompt the user with a completing-read
for the field that identifies the key.  Use the key to find the item.  Find the value of the named
key value pair within the item.  Put the value in the kill-ring and also return it to the caller.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-get-file }}
\usebox{\funcname}
\index{shu-keyring-get-file} \hfill [Command]\\%
 (Alias: krfn)

\begin{doc-string}
Display the name of the keyring file, if any.  This is useful if you are
getting unexpected results from some of the query functions that look up keyring
information.  Perhaps the unexpected results come from the fact that you are
using the wrong keyring file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-get-id }}
\usebox{\funcname}
\index{shu-keyring-get-id} \hfill [Command]\\%
 (Alias: krid)

\begin{doc-string}
Find the User Id for an entry in the keyring file.  This displays the entry
in the message area and puts the user Id into the kill ring so that it can be
yanked into a buffer or pasted into the application requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-get-passphrase }}
\usebox{\funcname}
\index{shu-keyring-get-passphrase} \hfill [Command]\\%
 (Alias: krpps)

\begin{doc-string}
Doc string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-get-pin }}
\usebox{\funcname}
\index{shu-keyring-get-pin} \hfill [Command]\\%
 (Alias: krpin)

\begin{doc-string}
Find the pin for an entry in the keyring file.  This displays the entry in
the message area and puts the pin into the kill ring so that it can be yanked
into a buffer or pasted into the application requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-get-pw }}
\usebox{\funcname}
\index{shu-keyring-get-pw} \hfill [Command]\\%
 (Alias: krpw)

\begin{doc-string}
Find the password for an entry in the keyring file.  This displays the entry
(without the password) in the message area and puts the password into the kill
ring so that it can be yanked into a buffer or pasted into the application
requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-get-url }}
\usebox{\funcname}
\index{shu-keyring-get-url} \hfill [Command]\\%
 (Alias: krurl)

\begin{doc-string}
Find the url for an entry in the keyring file.  This displays the entry in
the message area and puts the url into the kill ring so that it can be yanked
into a buffer or pasted into the application requesting it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-history }}
\usebox{\funcname}
\index{shu-keyring-history} \hfill [Variable]

\begin{doc-string}
The history list used by completing-read when asking the user for a key to an
entry in the keyring file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-id-name }}
\usebox{\funcname}
\index{shu-keyring-id-name} \hfill [Constant]

\begin{doc-string}
Key word that denotes a user ID.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-in-index }}
\usebox{\funcname}\emph{index} \emph{item} \emph{value}
\index{shu-keyring-in-index} \hfill [Function]

\begin{doc-string}
Return true if the \emph{index} already contains the \emph{value} for this \emph{item}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-index }}
\usebox{\funcname}
\index{shu-keyring-index} \hfill [Variable]

\begin{doc-string}
The variable that points to the in-memory keyring index.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-name-name }}
\usebox{\funcname}
\index{shu-keyring-name-name} \hfill [Constant]

\begin{doc-string}
Key word that denotes a name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-parse-keyring-file }}
\usebox{\funcname}
\index{shu-keyring-parse-keyring-file} \hfill [Command]

\begin{doc-string}
Parse the keyring file and create the in-memory index if the keyring file
contains no duplicate keys.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-pin-name }}
\usebox{\funcname}
\index{shu-keyring-pin-name} \hfill [Constant]

\begin{doc-string}
Key word that denotes a PIN.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-pw-name }}
\usebox{\funcname}
\index{shu-keyring-pw-name} \hfill [Constant]

\begin{doc-string}
Key word that denotes a password.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-set-alias }}
\usebox{\funcname}
\index{shu-keyring-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-keyring.
These are generally the same as the function names with the leading
shu- prefix removed.  But in this case the names are drastically shortened
to make them easier to type.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-set-passphrase }}
\usebox{\funcname}\emph{phrase}
\index{shu-keyring-set-passphrase} \hfill [Command]\\%
 (Alias: set-passphrase)

\begin{doc-string}
Function to read and set the external pass phrase.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-show-index }}
\usebox{\funcname}\emph{index}
\index{shu-keyring-show-index} \hfill [Function]

\begin{doc-string}
Print the keyring index
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-show-name-url }}
\usebox{\funcname}\emph{type} \emph{item}
\index{shu-keyring-show-name-url} \hfill [Function]

\begin{doc-string}
Show in the message area the name, url, or both of a keyring entry.  Also prefix
the message with the upper case type, which is the type of the entry that has been
placed in the clipboard, (PW, ID, etc.)
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-update-index }}
\usebox{\funcname}\emph{index} \emph{item}
\index{shu-keyring-update-index} \hfill [Function]

\begin{doc-string}
Extract the keys from a keyring item and add them to the keyring index.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-url-name }}
\usebox{\funcname}
\index{shu-keyring-url-name} \hfill [Constant]

\begin{doc-string}
Key word that denotes a URL.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-values-to-string }}
\usebox{\funcname}\emph{values}
\index{shu-keyring-values-to-string} \hfill [Function]

\begin{doc-string}
Turn a list of values into a single string of values separated by slashes.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-keyring-verify-file }}
\usebox{\funcname}
\index{shu-keyring-verify-file} \hfill [Command]\\%
 (Alias: krvf)

\begin{doc-string}
Parse and verify the keyring file, displaying the result of the operation in the
keyring buffer (\emph\{**shu-keyring**\}).  If one of the queries for a url or other
piece of information is unable to find the requested information, it could be
that you have the wrong keyring file or that there is a syntax error in the
keyring file.  shu-keyring-get-file (alias krfn) displays the name of the
keyring file.  This function parses the keyring file.  After the operation. look
into the keyring buffer (\emph\{**shu-keyring**\}) to see if there are any complaints
about syntax errors in the file.
\end{doc-string}

\eject
\section{shu-match}


Functions that use functions in shu-cpp-match.el


\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{find-all-variables }}
\usebox{\funcname}
\index{find-all-variables} \hfill [Command]\\%
 (Function: shu-match-find-variables)

\begin{doc-string}
Find what might be all of the variable declarations in a header file by doing
a reverse tokenized scan looking for all occurrences of operator ``;'' followed
by something that matches the regular expression for a C++ name.  Then take each
line that matches and put it in the buffer ``\emph\{**shu-vars**\}''.
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{remove-class-duplicates }}
\usebox{\funcname}\emph{proc-classes} \emph{log-buf}
\index{remove-class-duplicates} \hfill [Function]

\begin{doc-string}
\emph{proc-classes} is the alist of classes that we will process.  The car of each
item is the containing namespace.  The cdr of each item is the list of class
names contained within the namespace.  The original class list may have had
duplicate class names within a given namespace.  We may also have added class
names to a given namespace from processing one or more ``using name''
statements.

For example, if the lass list contained ``std . set map string'' and we also
processed a ``using std::string'' statement, the code that processed that
statement would have blindly added ``string'' to the list of classes in the
namespace ``std''.  The list of classes for namespace ``std'' would then contain
``string set map string''.

This function removes any duplicate class names within a given namespace.  This
is necessary because we are about to invert the class list to produce a hash
table in which the key is the class name and the value is the enclosing
namespace name.  This operation will fail if a given namespace contains
duplicate class names.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-classname-forms }}
\usebox{\funcname}
\index{shu-cpp-match-classname-forms} \hfill [Constant]

\begin{doc-string}
Match name::name or name::name::name or name::name::name::name, etc.  The
double colons make up the return value so that you can tell where one name
ends and another starts.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-colon-name }}
\usebox{\funcname}
\index{shu-cpp-match-colon-name} \hfill [Constant]

\begin{doc-string}
A repeating side list to match zero or more instances of \{:: $<$name$>$\}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-colon-name-return }}
\usebox{\funcname}
\index{shu-cpp-match-colon-name-return} \hfill [Constant]

\begin{doc-string}
A repeating side list to match one or more instances of \{:: $<$name$>$\} with the
double colons making up part of the return value.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-general-include }}
\usebox{\funcname}
\index{shu-cpp-match-general-include} \hfill [Constant]

\begin{doc-string}
A list of match-info that matches ``\#include''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-many-using-list }}
\usebox{\funcname}
\index{shu-cpp-match-many-using-list} \hfill [Constant]

\begin{doc-string}
These two lists match what may follow the key word ``using''.  The first list
matches the key word ``namespace'' followed by any of the different name types
that may follow ``using namespace''.  The second list matches any of the name
forms that may following the key word ``using'' when it is not followed by the
key word ``namespace''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-namespace-forms }}
\usebox{\funcname}
\index{shu-cpp-match-namespace-forms} \hfill [Constant]

\begin{doc-string}
;
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-namespace-list }}
\usebox{\funcname}
\index{shu-cpp-match-namespace-list} \hfill [Constant]

\begin{doc-string}
namespace
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-namespace-list-single }}
\usebox{\funcname}
\index{shu-cpp-match-namespace-list-single} \hfill [Constant]

\begin{doc-string}
namespace
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-some-include }}
\usebox{\funcname}
\index{shu-cpp-match-some-include} \hfill [Constant]

\begin{doc-string}
A list of match-info that matches ``\#include $<$name$>$``.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-using-forms }}
\usebox{\funcname}
\index{shu-cpp-match-using-forms} \hfill [Constant]

\begin{doc-string}
These two lists match the form of name that can follow a ``using'' directive
that is not a ``using namespace'' directive.  This is either $<$name$>$ or
$<$name$>$::$<$name$>$$>$, $<$name$>$::$<$name$>$::$<$name$>$, etc.  The first list above matches
$<$name$>$ followed by semicolon..  The second list matches $<$name$>$ followed
by a looping side list for zero or more occurrences of ``::'' followed by $<$name$>$
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-match-using-list-single }}
\usebox{\funcname}
\index{shu-cpp-match-using-list-single} \hfill [Constant]

\begin{doc-string}
This is a single list that is the top level list for matching anything
that may follow the key word ``using''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-cpp-rmv-using }}
\usebox{\funcname}\emph{class-list} \textbf{\&optional} \emph{top-name}
\index{shu-cpp-rmv-using} \hfill [Function]

\begin{doc-string}
Remove ``using namespace'' directives from a C++ file, adding the appropriate
namespace qualifier to all of the unqualified class names.  \emph{class-list} is an
a-list in which the car of each entry is a namespace and the cdr of each entry
is a list of class names.  Here is an example of such an a-list:

\small{\begin{verbatim}
     (list
      (cons ``std''    (list ``set'' ``string'' ``vector''))
      (cons ``world''  (list ``Hello'' ``Goodbye'')))
\end{verbatim}}

\emph{top-name}, if present is a higher level namespace.  Given a top level namespace
of ``WhammoCorp'', then the following line:

\small{\begin{verbatim}
     using namespace WhammoCorp::world;
\end{verbatim}}

would be interpreted as though it had been written:

\small{\begin{verbatim}
     using namespace world;
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-add-names-to-class-list }}
\usebox{\funcname}\emph{un-list}
\index{shu-match-add-names-to-class-list} \hfill [Function]
\hspace*{\wd\funcname}\emph{proc-rlists}
\hspace*{\wd\funcname}\textbf{\&optional}
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{un-list} is the list of rlists that represent the ``using name'' statements.
\emph{proc-classes} is the class list we will be using to do the processing.
\emph{proc-rlists} is the set of rlists that represents the ``using namespace''
statements.  This function adds the''using name'' directives, if any, to both
\emph{proc-classes} and \emph{proc-rlists}.  It returns a cons cell in which the car is the
modified \emph{proc-classes} and the cdr is the modified \emph{proc-rlists}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-erase-using }}
\usebox{\funcname}\emph{proc-rlists} \emph{log-buf}
\index{shu-match-erase-using} \hfill [Command]

\begin{doc-string}
\emph{proc-rlists} is the set of rlists we are processing that represent all of the
``using namespace'' and ``using name'' statements.  This function replaces all
of those statements in the buffer with whitespace.  This is done in order to
preserve the positions of all other items in the buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-fetch-include-hash-table }}
\usebox{\funcname}\emph{token-list}
\index{shu-match-fetch-include-hash-table} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{token-list} is the list of tokenized text from the buffer.  \emph{class-ht} is the
hash table that holds as its keys the names of all of the classes that we will
process.

This function finds all of the names in \#include statements whose included file
name matches a class name in \emph{class-ht}.  It then builds and returns a new hash
table in which the key is the name of an included file whose name matches a
class name and whose value is a list of the spoints of the included file names.

It is a list of spoints, as opposed to a single point, because an include
statement with a given file name may appear several times.

For example, in the following code:

\small{\begin{verbatim}
      #include <set>
      #include <map>
      #
       include
            <set>

      using namespace std;

      set     x;
      map     y;
\end{verbatim}}

the member variables x and y should be changed to std::set and std::map
respectively, but none of the occurrences of set or map in the include
statements should be changed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-find-all-general-include }}
\usebox{\funcname}
\index{shu-match-find-all-general-include} \hfill [Function]

\begin{doc-string}
Given a token list, return a list that holds the location of each ``\#'' that
represents the start of an \#include directive.  Return an empty list if there
are no \#include directives.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-find-all-some-include }}
\usebox{\funcname}\emph{token-list}
\index{shu-match-find-all-some-include} \hfill [Function]

\begin{doc-string}
Given a token list, return a list of tokens that represent all of the simple
names found in \#include $<$ name $>$, where ``name'' is a C++ name.  This search
will neither find nor return a name with a . in it.  This is a limited search
designed to find names that might be mistaken for class names to be qualified.

For example, if we are removing the namespace ``std'', then one of the names we
may wish to qualify is ``set''.  Buf if we encounter ``\#include $<$set$>$``, we do
not want to transform that into ``\#include $<$std::set$>$``.

Names of include files delimited by quotes will not be seen in the scan because
those are inside strings.  So we only want to find names in include statements
that are delimited by angle brackets and do not include a . in them.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-find-all-using-internal }}
\usebox{\funcname}\emph{token-list}
\index{shu-match-find-all-using-internal} \hfill [Function]

\begin{doc-string}
Given a token list, return two different lists.  The first is a list of all
``using namespace'' statements.  The second is a list of all ``using''
statements that are not ``using namespace'' statements.  ``using namespace
std;'' is an example of the first type.  ``using std::string'' is an example of
the second type.
The return value of this function is a single cons cell in which the cdr points
to the first list and the car points to the second list.
If neither list is present, then the return value is nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-find-any-using-internal }}
\usebox{\funcname}\emph{token-list}
\index{shu-match-find-any-using-internal} \hfill [Function]

\begin{doc-string}
Given a token list, return a list of all ``using namespace'' statements and
all ``using'' statements that are not ``using namespace'' statements.  ``using
namespace std;'' is an example of the first type.  ``using std::string'' is an
example of the second type.  This is used to find out whether or not a file of
code contains any such statements and to identify them.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-find-semi-names }}
\usebox{\funcname}\emph{token-list}
\index{shu-match-find-semi-names} \hfill [Function]

\begin{doc-string}
With a match list that is a semi-colon followed by the regular expression for
a C++ name, do a reverse tokenized match for all occurrences, then take each
line that holds a match and put it into the buffer ``\emph\{**shu-vars**\.\}

This version (11 Nov 2019) adds one more check.  If the token immediately in
front of the semi-colon is ``\}'', then we assume this is the last line of code
in an inline function, in which case it is not a variable declaration.  This
helps to weed out some of the extraneous ones but not all of them.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-find-unqualified-class-names }}
\usebox{\funcname}\emph{class-ht}
\index{shu-match-find-unqualified-class-names} \hfill [Command]
\hspace*{\wd\funcname}\emph{token-list}
\hspace*{\wd\funcname}\emph{log-buf}

\begin{doc-string}
Go through all of the tokens looking at any unquoted token that is in the
hash table of unqualified class names.  When an instance of a class name is
found, check to see it it is preceded by ``::'', ``.'', or ``-$>$``.  ``::''
indicates that it is probably qualified.  ``.'' or ``-$>$`` indicate that it is
probably a function name.

Check also to see if it is followed by ``)'' or ``[``, which probably indicates
that it is a variable name.

Next, check to see if it is wrapped in an \#include statement.

If it survives all of those checks, it is probably an unqualified class name, in
which case its token-info is pushed onto a list.  The list is one of the values
returned from this function.  Since each token-info is pushed onto the list, the
list is returned in reverse order.  i.e., the last token in the file is the
first in the list.

At this point it is possible to visit each token in the list, which is in
reverse order in the file, look up each token, and insert in front of it its
qualifying namespace.

The other return value from this function is the count of the number of unquoted
tokens that were looked up in the hash table of all of the class names,
\emph{class-ht}..

The actual return value from this function is a cons cell whose car is the
symbol search count and whose cdr is the list of tokens that represent
unqualified class names to be qualified.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-find-variables }}
\usebox{\funcname}
\index{shu-match-find-variables} \hfill [Command]\\%
 (Alias: find-all-variables)

\begin{doc-string}
Find what might be all of the variable declarations in a header file by doing
a reverse tokenized scan looking for all occurrences of operator ``;'' followed
by something that matches the regular expression for a C++ name.  Then take each
line that matches and put it in the buffer ``\emph\{**shu-vars**\}''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-get-start-end-pos }}
\usebox{\funcname}\emph{rlist} \textbf{\&optional}
\index{shu-match-get-start-end-pos} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Given an \emph{rlist} return the beginning and end positions.  The beginning position is
the position of the first character of the first token.  The end position is the
position of the last character of the last token.  These two are returned as a cons
cell whose car is the beginning position and whose cdr is the end position.  If
the optional \emph{whole-lines} is true, the start position is that of the beginning of
the line on which the start falls and the end position is that of the end of
the line on which the end falls.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-increment-class-count }}
\usebox{\funcname}\emph{alist} \emph{class-name}
\index{shu-match-increment-class-count} \hfill [Command]

\begin{doc-string}
\emph{alist} is an alist whose key is a \emph{class-name} and whose cdr is a count of the
number of times that class name has been found.  This function increments the
count by one.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-internal-rmv-using }}
\usebox{\funcname}\emph{class-list} \emph{log-buf}
\index{shu-match-internal-rmv-using} \hfill [Function]
\hspace*{\wd\funcname}\emph{top-name}

\begin{doc-string}
This is an overview of the entire process used to remove both the using
namespace statements (e.g., ``using namespace std;'') and the using statements
(e.g., ``using std::string;'').

The input is a class list which is an alist in which the key for each entry is a
namespace name and the value for each entry is a list of class names that are
qualified by the namespace name.  This is an example of a class list:

\small{\begin{verbatim}
     (list (cons ``std'' (list ``set'' ``string'' ``vector'')) (cons ``world''
      (list ``Hello'' ``Goodbye'')))
\end{verbatim}}

The first step is to tokenize the entire buffer and then use match functions to
find each instance of ``using namespace'' and each occurrence of ``using name''.
Each of these statements is represented by a list of token-info.

If any ``using namespace'' statements are found, they are merged with the class
list to form a new class list that contains only those namespaces for which a
``using namespace'' statement was found in the buffer.

A separate list is kept of the ``using namespace'' statements that have no
corresponding entries in the class list.  This is printed out later as a
diagnostic message.

The next step is to merge in the namespaces from the ``using name'' statements.
Each ``using name'' statement contributes one namespace name and one class name.

The original class list might have contained duplicate class name instances
within a given namespace.  The merging in the of the ``using name'' statements
may also have created duplicate class names within a namespace, so the next
thing we do is remove any duplicate class names within a given namespace.  For
example, if the input class list contained ``std . string set map'' and the
buffer contains both ``using namespace std;'' and ``using std::string;'', the
newly merged class list will contain the class name ``string'' twice under the
namespace ``std''.

Once we have the updated class list with duplicates removed, we create two new
data structures.  One is a hash table in which the key is a class name and the
value is the name of the namespace that qualifies that class name.  This will be
used to determine if an unquoted token is an unqualified class name.  The other
is an alist in which the key is a class name and the value is zero.  This will
be used to count the replacement count for each class.

In creating the hash table, we may discover that one class name maps to more
than one namespace name.  If that happens there is an unresolvable ambiguity and
the operation must cease.

The next step is to remove from the token list (from the tokenized buffer), the
lists of token-info that represent the ``using namespace'' and ``using name''
statements that we are processing.  This prevents any subsequent scan from
seeing them again.

Next, we erase the ``using namespace'' statements and ``using name'' statements
from the buffer.  We do this by replacing the statements with an equivalent
amount of whitespace, which preserves the positions of all of the other tokens
in the buffer.

Some of the class names in the class list may also appear in \#include statements
in the buffer.  For example, if we are trying to remove ``using namespace
std;'', the buffer may well contain \#include $<$set$>$ or \#include $<$map$>$.  These
instances of set and map are file names.  They are not class names that should
have the ``std'' qualifier added to them.

To handle this case we build another hash table.  This one contains class names
as its key.  It is the intersection of class names and names found in include
statements.  The value of each entry in the hash table is the list of spoints
that are the start point for each name within its include statement.  It is a
list of spoints because the same name may appear in multiple \#include
statements.

Then we go through the token list.  Whenever we encounter an unquoted token, we
look it up in the hash table to see if this is a class name that we should
qualify.  If the token exists in the hash table, we then look at its context to
see if it really looks like a class name.

IF the putative class name is preceded by any of ``::'', ``.'', or ``-$>$``, then
we assume that it is either a qualified class name or a function name.  There
are other various checks that can be found in the function
shu-match-find-unqualified-class-names.  One of the checks is to see if it
matches an instance contained in an \#include statement, which is done with the
hash of include names described above.

Each time we find an unqualified class name, we push its token-info onto a new
list of class names that need to be qualified.  Note that we use push so the
list is backwards with respect to buffer order.  The first item in the list is
that last unqualified class name in the buffer.

This means that we can use the list directly to add the namespace qualifier to
each unqualified class name.  Since we are going through the buffer backwards,
adding a qualifier to an unqualified class name does not change the position of
any other unqualified class names in the buffer.

While adding namespace qualifiers to all of the unqualified class names, we also
accumulate a change count for each class name.

When all of the unqualified class names have been qualified, we display the
final change counts in a buffer and emit a message with the sum of all the
change counts.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-line-code }}
\usebox{\funcname}\emph{stmt} \emph{spos}
\index{shu-match-line-code} \hfill [Function]

\begin{doc-string}
\emph{stmt} is a string of text taken from the buffer.  \emph{spos} is the start position
of the string of text.  This function splits the lines of text into separate
lines, each one prefixed with the line number where it appears in the file.

For example, if the string of test is ``Hello.'' and it starts at line 392 of
the file, this function will return ``   392. Hello.'' with a newline appended
to the end of the line.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-make-class-hash-table-internal }}
\usebox{\funcname}\emph{proc-classes}
\index{shu-match-make-class-hash-table-internal} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{proc-classes} is the alist of all of the namespaces and classes that we will
process, with the namespace name being the key and a list of class names within the
namespace name as the value.

This function builds a hash table that inverts the
alist.  Each entry in the hash table has a class name as the key with the name
of the enclosing namespace as the value.
If two class names map to the same enclosing namespace name, then there is an
unresolvable ambiguity that must terminate the operation.  If that is the case,
diagnostic messages are placed into the log buffer and a nil value is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-make-count-alist-from-hash }}
\usebox{\funcname}\emph{class-ht}
\index{shu-match-make-count-alist-from-hash} \hfill [Command]

\begin{doc-string}
Create an alist in which the key is a class name and the value is zero.  This alist
will be used to generate a count of number of items changed per class name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-make-include-hash-table }}
\usebox{\funcname}\emph{incl-list}
\index{shu-match-make-include-hash-table} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{incl-list} is the list of token-info, each of which represents a name found in
an include statement.  \emph{class-ht} is the hash table whose keys are the names of
the classes that we will be searching for.

For each name that appears in both \emph{incl-list} and \emph{class-ht}, create a new entry in
a new hash table whose key is the name of the class that has been found in one
or more include statements and whose value is a list of the spoints in which the
class name has been found in one or more include statements.

Whenever we find something that appears to be an unqualified class name, we can
look in this hash table to see if this occurrence of the name is one that
appears in an include statement and avoid adding a namespace qualifier if that
is the case.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-merge-namespaces-with-class-list }}
\usebox{\funcname}\emph{class-list}
\index{shu-match-merge-namespaces-with-class-list} \hfill [Function]
\hspace*{\wd\funcname}\emph{log-buf}
\hspace*{\wd\funcname}\emph{top-name}

\begin{doc-string}
Merge the \emph{uns-list} with the \emph{class-list}.  Return a cons-cell pointing to two
lists.  The first is the list of classes from the class list that have
corresponding ``using namespace'' directives in the buffer.  The second is the
lists of rlists that represent each using namespace directive that we will
process.
The updated class list will be used to identify class names to be qualified and
the namespaces with which to qualify them..  The rlists representing the ``using
namespace'' statements will be used to remove the ``using namespace'' statements
from the buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-qualify-class-names }}
\usebox{\funcname}\emph{class-ht} \emph{count-alist}
\index{shu-match-qualify-class-names} \hfill [Function]
\hspace*{\wd\funcname}\emph{np-rlists}
\hspace*{\wd\funcname}\emph{symbol-count} \emph{log-buf}

\begin{doc-string}
\emph{class-ht} is the hash table that maps a class name to its containing namespace
name.  \emph{count-alist} is the alist that counts the number of times each class
name has been qualified by its enclosing namespace.  \emph{clist} is the list of
token-info, each of which represents an unqualified class name.  The list is in
reverse order, which is important.  It means that one can add a qualification to
one class name in the list without changing the location of any other class
names, which are above the current one in the buffer.  \emph{np-rlists} is a list of
rlists, each of which represents a ``using namespace'' statement for which
there is no corresponding entry in the class list.  There are the ``using
namespace'' statements that we will not be processing..

This function goes to the position of each unqualified class name, finds its
containing namespace in the hash table, and inserts the containing namespace
followed by ``::'' in front of the unqualified class name.

After it inserts the qualifying namespace, it increments in \emph{count-alist} the number
of times that the class name was explicitly qualified.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-remove-proc-rlists }}
\usebox{\funcname}\emph{token-list}
\index{shu-match-remove-proc-rlists} \hfill [Function]
\hspace*{\wd\funcname}\emph{log-buf}

\begin{doc-string}
\emph{token-list} is the original token list.  \emph{proc-rlists} is the set of rlists that
represents the set of statements we will be processing.  This function removes
from \emph{token-list}, all of the items that are contained in the rlists in
\emph{proc-rlists}.  This is because we do not want a subsequent scan of the token list
to include any of the items in the statements we are processing.

The return value from this function is a cons cell whose car is the trimmed
\emph{token-list} and whose cdr is the sorted \emph{proc-rlists}, which has been sorted by the
start position of each rlist.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-rmv-might-be-include }}
\usebox{\funcname}\emph{incl-ht} \emph{token}
\index{shu-match-rmv-might-be-include} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{incl-ht} is a hash table whose key is a name that was found in an include
statement and whose value is a list of all of the spoints of all of the
occurrences of the name in include statements.  It is a list because the same
name may be included multiple times.

If the current token matches one of the names in \emph{incl-ht} and the spoint of the
token is a member of the list of spoints in the entry in \emph{incl-ht}, then the
current name is enclosed in an include statement and should not have a namespace
qualifier added to it.

This function returns true if the name is wrapped in an include statement.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-rmv-show-class-count }}
\usebox{\funcname}\emph{count-alist}
\index{shu-match-rmv-show-class-count} \hfill [Function]
\hspace*{\wd\funcname}\emph{np-rlists} \emph{ns-lines}
\hspace*{\wd\funcname}\emph{symbol-count}
\hspace*{\wd\funcname}

\begin{doc-string}
Put into the log buffer the count of class names that were qualified.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-set-alias }}
\usebox{\funcname}
\index{shu-match-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-match,
These are generally the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-using-namespace-string }}
\usebox{\funcname}\emph{rlist} \textbf{\&optional}
\index{shu-match-using-namespace-string} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Given an \emph{rlist} that contains a ``using namespace'' statement, return the string
that is the fully qualified namespace name.  If the first part of the name is the
optional \emph{top-name}, it is omitted from the final result.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-match-using-string }}
\usebox{\funcname}\emph{rlist} \textbf{\&optional} \emph{top-name}
\index{shu-match-using-string} \hfill [Function]

\begin{doc-string}
Given an \emph{rlist} that contains a ``using'' statement (as opposed to ``using
namespace''), return two strings.  One is the class name.  The other is the
fully qualified namespace name.  For example, if the statement is ``using
std::string,'' the fully qualified namespace name is ``std'' and the class name
is ``string''.
The two strings are returned in a cons cell whose car is the namespace name and
whose cdr is the class name.
\end{doc-string}

\eject
\section{shu-misc}



A miscellaneous collection of useful functions


\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{add-alexandria }}
\usebox{\funcname}
\index{add-alexandria} \hfill [Command]\\%
 (Function: shu-add-alexandria)

\begin{doc-string}
Add Alexandria coverage to a git repository.
This function first checks to ensure that a README.md file exists that does not
contain an Alexandria badge and that a Doxyfile does not exist.  If those two
conditions are met, an Alexandria badge is added to the bottom of the README.md
file, a Doxyfile is created, and some of the tags in the Doxyfile are set to
reasonable defaults.  An ALEXANDRIA\_DOC\_DEPENDENCIES tag is added to the end of
the Doxyfile as a comment.
If this function succeeds, it returns true, else nil.  The return value may
be used by batch mode functions that want to call this function and report
whether or not it succeeded.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{add-alexandria-badge }}
\usebox{\funcname}
\index{add-alexandria-badge} \hfill [Command]\\%
 (Function: shu-add-alexandria-badge)

\begin{doc-string}
Insert an Alexandria badge for the current project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{add-prefix }}
\usebox{\funcname}\emph{prefix}
\index{add-prefix} \hfill [Command]\\%
 (Function: shu-add-prefix)

\begin{doc-string}
Put a prefix and a space in front of each line in the region.  Prompt is issued
for the prefix.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{af }}
\usebox{\funcname}\emph{frame-no}
\index{af} \hfill [Command]\\%
 (Function: shu-adapt-frame)

\begin{doc-string}
Adapt the current frame to the current display by stretching the frame to the
full height of the display and putting the top of the frame at the top of the
display.  This function makes some assumptions about the display geometry based
on the current operating system.  It assumes that Windows loses five lines for
top and bottom tool bars.  Mac OS X loses three lines for the top tool bar.
Unix loses two lines for something.  These numbers should, at some point, be
customizable.

With a numeric prefix argument N, the emacs window is positioned N frames from
the right hand side of the display.  For example, if you open three frames and
type into the first frame C-u 1 M-x \emph{shu-adapt-frame}, into the next frame
C-u 2 M-x \emph{shu-adapt-frame}, and into the third frame C-u 3 M-x \emph{shu-adapt-frame},
then the three frames will be grouped together side by side at the right side of
the display.

If the prefix argument is large enough that the left side of the frame would be
moved past the left side of the display, the window is positioned such that the
left edge of the window is aligned with the left edge of the display.

Prefix arguments greater than 10 assume a two display system.  Prefix arguments
of 11 and 12 put two frames on the right display.  Prefix arguments of 13 and
14 put two frames on the left display.

Implementation note:

If this function is called when the left side of the frame is positioned to the
left of the leftmost edge of the display, the function FRAME-POSITION returns a
negative value for the x coordinate of the frame.  The function
SET-FRAME-POSITION takes the x and y coordinates of the new position of the top
left corner of the frame.

But if x is negative, it specifies the coordinates of the right edge of the
frame relative to the right edge of the display.  This puts a frame that is very
close to the left edge of the display all the way over to the right edge of the
display.

The assumption is that a negative x frame position means that the user has
positioned the frame just a bit past the left edge and that the desired frame
position is actually the leftmost edge of the display.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{all-quit }}
\usebox{\funcname}
\index{all-quit} \hfill [Command]\\%
 (Function: shu-all-quit)

\begin{doc-string}
Kill all dired buffers and all buffers that contain a file and are unmodified.
It is not uncommon to have dozens of buffers open that are unrelated to the current task
and this is a convenience function for closing many buffers that do not need to
be open.
If the function \emph{shu-clear-c-project} is defined, it is called to clear the current
project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{buffer-number-lines }}
\usebox{\funcname}
\index{buffer-number-lines} \hfill [Command]\\%
 (Function: shu-buffer-number-lines)

\begin{doc-string}
Create a buffer whose name is derived from the file name of the current
buffer but with the string ``-numbered'' added to the name.  Thus ``foo.cpp''
would become ``foo-numbered.cpp'' Into this new buffer, copy the contents of the
current file with each line prefixed with its line number.  This is designed for
those times when you want to copy snippets of code with the line number in front
of each line because you are commenting on code and want the person receiving
the comments to sea the line number in front of each line.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{case-insensitive }}
\usebox{\funcname}
\index{case-insensitive} \hfill [Command]\\%
 (Function: shu-case-insensitive)

\begin{doc-string}
Set the variable case-fold-search to t to make searches and matches ignore
case.  I can never remember which way to set case-fold-search, hence this
simple, little function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{case-sensitive }}
\usebox{\funcname}
\index{case-sensitive} \hfill [Command]\\%
 (Function: shu-case-sensitive)

\begin{doc-string}
Set the variable case-fold-search to nil to make searches and matches respect
case.  I can never remember which way to set case-fold-search, hence this
simple, little function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{change-namespace }}
\usebox{\funcname}\emph{input}
\index{change-namespace} \hfill [Command]\\%
 (Function: shu-change-namespace)

\begin{doc-string}
This function changes the namespace in a set of C++ source files.

The files to be changed must follow these conventions:

 - The namespace name is all lower case
 - Each file name starts with the lower case namespace name followed by an
   underscore

The following steps are performed:

 1. Locate all of the files to be changed.  These are all files that hold C++
 source code in the current directory or in any directory below the current
 directory.  The set of files may be restricted by specifying a regular
 expression.  The regular expression does not need to include the file type.

 2. The files to be changed are renamed with the new namespace replacing the
 old in the file name.  If any file is part of a git repository, then ``git mv''
 is used for the rename operation.  Otherwise, ``mv'' is used.

 3. The files are then edited to replace all occurrences of the old namespace
 with the new.

The existing namespace, new namespace and file search pattern are specified with
a single string.

The first character of the string is a delimiter character that is used to split
the string.  The existing namespace, new namespace and file search pattern are
separated from each other with the delimiter.

For example, to specify an existing namespace of ``fumblebar'', a new namespace
of ``wunderbar'', and a search pattern of ``\emph\{*exception*\}'', one might specify

\small{\begin{verbatim}
       $fumblebar$wunderbar$\emph{*exception*}
\end{verbatim}}

or

\small{\begin{verbatim}
       @fumblebar@wunderbar@\emph{*exception*}
\end{verbatim}}

The search pattern is optional.  The following string would do the same
namespace replacement for all C++ files.

\small{\begin{verbatim}
       $fumblebar$wunderbar
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{comma-names-to-letter }}
\usebox{\funcname}
\index{comma-names-to-letter} \hfill [Command]\\%
 (Function: shu-comma-names-to-letter)

\begin{doc-string}
In a list of names, change all occurrences
of Lastname, Firstname to an empty Latex letter.
Position to the start of the file and invoke once.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{copy-repo }}
\usebox{\funcname}
\index{copy-repo} \hfill [Command]\\%
 (Function: shu-copy-repo)

\begin{doc-string}
Call \emph{shu-get-repo} to find the path to the repository and put the result in
the kill ring.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{de-star }}
\usebox{\funcname}
\index{de-star} \hfill [Command]\\%
 (Function: shu-de-star)

\begin{doc-string}
Remove leading spaces and asterisk from each line in the region.  This is
useful for editing doxygen comments of the form:

   /*!
\small{\begin{verbatim}
    * This is some commentary.
    * This is more commentary, etc.
    \emph{*/}
\end{verbatim}}

You snip out the middle lines and put them into a text file for formatting and
spell-checking.  You want to get rid of all of the asterisks until you are
done.

This function gets rid of all the asterisks.  You can use \emph{shu-add-prefix} to
put them back.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{dup }}
\usebox{\funcname}
\index{dup} \hfill [Command]\\%
 (Function: shu-dup)

\begin{doc-string}
Insert a duplicate of the current line, following it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{eld }}
\usebox{\funcname}
\index{eld} \hfill [Command]\\%
 (Function: shu-save-and-load)

\begin{doc-string}
Save and load the current file as a .el file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{fix-header }}
\usebox{\funcname}
\index{fix-header} \hfill [Command]\\%
 (Function: shu-fix-header-line)

\begin{doc-string}
If the first line of the buffer contains the sentinel ``-\emph\{*-C++-*-\}'', adjust
the line length to be \emph{shu-cpp-comment-end} in length, adding or removing
internal space as necessary.

If the first line of the buffer does not contain the sentinel ``-\emph\{*-C++-*-\}'',
do nothing.

Return the number of spaces actually adjusted.  0 means no adjustment made.
A positive number represents the number of spaces added.  A negative number
represents the number of spaces removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{fixup-doxyfile }}
\usebox{\funcname}
\index{fixup-doxyfile} \hfill [Command]\\%
 (Function: shu-fixup-doxyfile)

\begin{doc-string}
The current directory is assumed to have the same name as the project for
which the Doxyfile was created.  This function sets various default values in
the Doxyfile.  The current buffer is the Doxyfile.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gd }}
\usebox{\funcname}
\index{gd} \hfill [Command]\\%
 (Function: shu-gd)

\begin{doc-string}
While in dired, put the full path to the current directory in the kill ring
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{get-repo }}
\usebox{\funcname}
\index{get-repo} \hfill [Function]\\%
 (Function: shu-get-repo)

\begin{doc-string}
When positioned anywhere in a git repository, return the git path to the
repository.  This is found in .git/config as the url of [remote ``origin''].
Return nil if the path cannot be found.

The search is made from the current directory and upwards for the first
directory called ``.git''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{getnv }}
\usebox{\funcname}
\index{getnv} \hfill [Command]\\%
 (Function: shu-getnv)

\begin{doc-string}
When positioned anywhere on a line that looks like

\small{\begin{verbatim}
        Published version 1.2.9 of library
\end{verbatim}}

put into the kill ring  a string of the form ``library=1.2.9''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gf }}
\usebox{\funcname}
\index{gf} \hfill [Command]\\%
 (Function: shu-gf)

\begin{doc-string}
While in dired, put the full path to the current file in the kill ring
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gfc }}
\usebox{\funcname}
\index{gfc} \hfill [Command]\\%
 (Function: shu-gfc)

\begin{doc-string}
While in a file buffer, put both the current line number and
column number and the name of the current file into the kill ring
in the form of ``foo.cpp:123:2''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gfl }}
\usebox{\funcname}
\index{gfl} \hfill [Command]\\%
 (Function: shu-gfl)

\begin{doc-string}
While in a file buffer, put both the current line number and the name of the current
file into the kill ring in the form of ``line 1234 of foo.cpp''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gfn }}
\usebox{\funcname}
\index{gfn} \hfill [Command]\\%
 (Function: shu-gfn)

\begin{doc-string}
While in a file buffer, put the name of the current file into the kill ring.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gquote }}
\usebox{\funcname}
\index{gquote} \hfill [Command]\\%
 (Function: shu-gquote)

\begin{doc-string}
Insert a LaTeX quote environment and position the cursor for typing the quote.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{kill-system-name }}
\usebox{\funcname}
\index{kill-system-name} \hfill [Command]\\%
 (Function: shu-kill-system-name)

\begin{doc-string}
Place the system name` (machine name) in the message area.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{loosen-lisp }}
\usebox{\funcname}
\index{loosen-lisp} \hfill [Command]\\%
 (Function: shu-loosen-lisp)

\begin{doc-string}
Within the bounds of a lisp function, unwind the parentheses that terminate
conditional and containing functions such that it is convenient to insert code
inside of them without having to worry about which line contains the closing
parenthesis.  All closing parentheses are now on separate lines.  Once the
changes to the function are complete, you can run \emph{shu-tighten-lisp} to put the
parentheses back where they belong.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{make-header }}
\usebox{\funcname}
\index{make-header} \hfill [Command]\\%
 (Function: shu-make-header-line)

\begin{doc-string}
At the top of the current buffer, insert a string that holds the standard
first line comment in a C++ file, which is of the form:

\small{\begin{verbatim}
      ``// file_name                                      -\emph{*-C++-*-}''
\end{verbatim}}

The inserted line is of length \emph{shu-cpp-comment-end}.

Does nothing if the current buffer does not have an associated file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{make-md-toc }}
\usebox{\funcname}
\index{make-md-toc} \hfill [Command]\\%
 (Function: shu-tocify-markdown-file)

\begin{doc-string}
Search the file starting at the current position for any markdown headings of
the form ``\#\# This is a heading''.  Add a tag to each heading and then insert a
complete markdown table of contents at the current position.

Pound signs that lie inside of markdown literal areas designated by `````'' are
ignored.  This prevents something such as an example of an \#include directive
from being treated as a level 1 heading.

If a heading already has a tag, it is removed.  If a heading has trailing pound
signs, they are also removed.

The default maximum heading level is two, which means that heading levels
greater than two are not included in the table of contents.  But a numeric
prefix argument can change the maximum heading level.  The maximum heading level
cannot be set to a value less than one.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{md-name }}
\usebox{\funcname}
\index{md-name} \hfill [Command]\\%
 (Function: shu-make-md-name-entry)

\begin{doc-string}
The latest item in the kill ring is assumed to be the text of a markdown
section name.  This function creates from that section name, a markdown table of
contents name that will identify the section in the table of contents.

For example, if the kill ring contains ``\#\# This is the Overview'', the table
of contents name created and inserted at point will be:

\small{\begin{verbatim}
        <a name=thisistheoverview></a>
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{md-toc }}
\usebox{\funcname}
\index{md-toc} \hfill [Command]\\%
 (Function: shu-make-md-toc-entry)

\begin{doc-string}
The latest item in the kill ring is assumed to be the text of a markdown
section name.  This function creates from that section name, a markdown table of
contents entry and inserts that entry at point.

For example, if the kill ring contains ``\#\# This is the Overview \#\#'', the table
of contents entry created and inserted at point will be

\small{\begin{verbatim}
       * [This is the overview](#thisistheoverview)
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{modified-buffers }}
\usebox{\funcname}
\index{modified-buffers} \hfill [Command]\\%
 (Function: shu-modified-buffers)

\begin{doc-string}
Show a list of all buffers associated with files whose status is modified.
It is not uncommon to have many emacs windows open and to realize that one
window has a file open and another window is also trying to edit it.  emacs
warns the second window of the conflict, but it is sometimes difficult to tell
which window holds the modified buffer.  The buffer list shows you all of the
buffers with an asterisk next to each modified buffer, but if the buffer list
is large, it can be difficult to find the one you seek.  This command lists
only modified buffers that hold the contents of a file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{new-ert }}
\usebox{\funcname}\emph{func-name}
\index{new-ert} \hfill [Command]\\%
 (Function: shu-new-ert)

\begin{doc-string}
Insert at point a skeleton lisp ert unit test.  Prompt is issued for the
function name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{new-latex }}
\usebox{\funcname}
\index{new-latex} \hfill [Command]\\%
 (Function: shu-new-latex)

\begin{doc-string}
Build a skeleton, empty LaTeX file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{new-lisp }}
\usebox{\funcname}\emph{func-name}
\index{new-lisp} \hfill [Command]\\%
 (Function: shu-new-lisp)

\begin{doc-string}
Insert at point a skeleton lisp function.  Prompt is issued for the function
name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{new-lisp-while }}
\usebox{\funcname}\emph{var-name}
\index{new-lisp-while} \hfill [Command]\\%
 (Function: shu-new-lisp-while)

\begin{doc-string}
Insert at point a skeleton lisp while loop.  Prompt is issued for the
variable name.  The while loop is of the form:

\small{\begin{verbatim}
     (while x

       (setq x (cdr x))
       )
\end{verbatim}}
point is placed where the the first line of code in the loop belongs.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{number-lines }}
\usebox{\funcname}
\index{number-lines} \hfill [Command]\\%
 (Function: shu-number-lines)

\begin{doc-string}
Insert in front of each line in the buffer its line number.  Starts
at point and continues to the end of the buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{obfuscate-region }}
\usebox{\funcname}\emph{start} \emph{end}
\index{obfuscate-region} \hfill [Command]\\%
 (Function: shu-obfuscate-region)

\begin{doc-string}
Obfuscate a region of text by replacing every alphabetic character in the
region with the next letter of the alphabet, staring with 'a'. For example, of
the region contains

  Now is the time for all good men to come to the aid of the Party 10 times.

Then the obfuscated text would be:

  Abc de fgh ijkl mno pqr stuv wxy za bcde fg hij klm no pqr Stuvw 10 xyzab.

This is useful if you want to capture some text for later testing and
manipulation that might contain confidential or proprietary information.  This
is an encoding that cannot be reversed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{of }}
\usebox{\funcname}
\index{of} \hfill [Command]\\%
 (Function: shu-of)

\begin{doc-string}
While in dired, open the current file (Mac OS X only)
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{os-name }}
\usebox{\funcname}
\index{os-name} \hfill [Command]\\%
 (Function: shu-show-os-name)

\begin{doc-string}
Display the name of the host operating system type.  This is a sanity check
function for the various functions defined in .emacs to determine the type of
the host operating system.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{prepare-for-rename }}
\usebox{\funcname}\emph{old-namespace} \emph{new-namespace}
\index{prepare-for-rename} \hfill [Command]\\%
 (Function: shu-prepare-for-rename)

\begin{doc-string}
This is a function that helps to rename a list of files that share one common
part of a name to a list of files that have a different common part of the name.
For example, given the following set of files:

\small{\begin{verbatim}
      aaaa_mumble.cpp
      aaaa_mumble.h
      aaaa_mumble.t.cpp
\end{verbatim}}

it is not uncommon to want to change those file names to something like

\small{\begin{verbatim}
      abcdef_mumble.cpp
      abcdef_mumble.h
      abcdef_mumble.t.cpp
\end{verbatim}}

This can be done with the following work flow:

\small{\begin{verbatim}
      1. ls ``aaaa*'' >cf.txt

      2. Edit cf.txt to turn it into a script that renames the files from
         ``aaaa\emph{*\} to ``abcdef*''.
\end{verbatim}}

The editing steps are relatively straightforward, but take a small number of
minutes.

This function automates the editing steps.

When invoked interactively, it first prompts for the old common part and then
for the new common part.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{remove-test-names }}
\usebox{\funcname}
\index{remove-test-names} \hfill [Command]\\%
 (Function: shu-remove-test-names)

\begin{doc-string}
Remove from a file all lines that contain file names that end in .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{reverse-comma-names }}
\usebox{\funcname}
\index{reverse-comma-names} \hfill [Command]\\%
 (Function: shu-reverse-comma-names)

\begin{doc-string}
In a list of names, change all occurrences
of Lastname, Firstname to Firstname Lastname.
Position to the start of the file and invoke once.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{scan-grok }}
\usebox{\funcname}
\index{scan-grok} \hfill [Command]\\%
 (Function: shu-extract-name-open-grok)

\begin{doc-string}
The current buffer contains output from an OpenGrok search that has been
copied from the web page and pasted into the buffer.  This function scans the
buffer from the current point and harvests all of the file names that hold the
references for which OpenGrok searched.  It puts the file names (including their
top level directories) into the buffer ``\emph\{**shu-open-grok**\}''.
The number of file names found is returned, mostly for the benefit of unit
tests.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-dos-eol }}
\usebox{\funcname}
\index{set-dos-eol} \hfill [Command]\\%
 (Function: shu-set-dos-eol)

\begin{doc-string}
Set the end of line delimiter to be the DOS standard (CRLF).
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{set-unix-eol }}
\usebox{\funcname}
\index{set-unix-eol} \hfill [Command]\\%
 (Function: shu-set-unix-eol)

\begin{doc-string}
Set the end of line delimiter to be the Unix standard (LF).
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{show-repo }}
\usebox{\funcname}
\index{show-repo} \hfill [Command]\\%
 (Function: shu-show-repo)

\begin{doc-string}
Call \emph{shu-get-repo} to find the path to the repository and show the result in
the minibuffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{show-system-name }}
\usebox{\funcname}
\index{show-system-name} \hfill [Command]\\%
 (Function: shu-show-system-name)

\begin{doc-string}
Place the system name (machine name) in the message area.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{srs }}
\usebox{\funcname}\emph{rstring}
\index{srs} \hfill [Command]\\%
 (Function: shu-srs)

\begin{doc-string}
A sed-like version of REPLACE-STRING.  REPLACE-STRING requires two arguments,
which are read interactively, one at a time.  This works well for normal
interactive use.

But sometimes you actually create the search and replacement strings in another
buffer to be fed to REPLACE-STRING.  To use these two strings you have to do the
following:

\small{\begin{verbatim}
     1. Invoke REPLACE-STRING
     2. Switch to the other buffer
     3. Copy the search string from the other buffer
     4. Switch back to the main buffer
     5. Paste the search string from the kill ring
     6. Hit enter
     7. Switch to the other buffer
     8. Copy the replacement string from the other buffer
     9. Switch back to the main buffer
    10. Paste the replacement string from the kill ring
    11. Hit enter
\end{verbatim}}

This function allows you to enter both strings at one prompt using a sed-like
syntax, such as

\small{\begin{verbatim}
     /abc/defg
\end{verbatim}}

This specifies a search string of ``abc\ and a replacement string of ``defg''.

The work flow now becomes

\small{\begin{verbatim}
     1. Invoke \emph{shu-srs}
     2. Switch to the other buffer
     3. Copy the search and replacement string from the other buffer
     4. Switch back to the main buffer
     5. Paste the search and replacement string from the kill ring
     6. Hit enter
\end{verbatim}}

You only have to go through six steps instead of eleven.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{tighten-lisp }}
\usebox{\funcname}
\index{tighten-lisp} \hfill [Command]\\%
 (Function: shu-tighten-lisp)

\begin{doc-string}
Within the bounds of a lisp function or macro, ``tighten'' some lisp code.
Look for any single right parenthesis that is on its own line and move it up to
the end of the previous line.  This function is the opposite of \emph{shu-loosen-lisp}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{trim-trailing-blanks }}
\usebox{\funcname}
\index{trim-trailing-blanks} \hfill [Command]\\%
 (Function: shu-trim-trailing-blanks)

\begin{doc-string}
Eliminate whitespace at ends of all lines in the current buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{unbrace }}
\usebox{\funcname}
\index{unbrace} \hfill [Command]\\%
 (Function: shu-unbrace)

\begin{doc-string}
When point is on an opening sexp, this function converts, within the scope of
the sexp, all ``\{'' to ``(`` and all ``\}'' to ``).''.
If the number of left braces does not match the number of right braces a warning
message is emitted.

For the benefit of unit tests, the count of left braces converted iff the count
of left braces matches the count of right braces.  If the counts do not match,
nil is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{winpath }}
\usebox{\funcname}\emph{start} \emph{end}
\index{winpath} \hfill [Command]\\%
 (Function: shu-winpath)

\begin{doc-string}
Take marked region, put in kill ring, changing / to \.
This makes it a valid path on windows machines.
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-adapt-frame }}
\usebox{\funcname}\emph{frame-no}
\index{shu-adapt-frame} \hfill [Command]\\%
 (Alias: af)

\begin{doc-string}
Adapt the current frame to the current display by stretching the frame to the
full height of the display and putting the top of the frame at the top of the
display.  This function makes some assumptions about the display geometry based
on the current operating system.  It assumes that Windows loses five lines for
top and bottom tool bars.  Mac OS X loses three lines for the top tool bar.
Unix loses two lines for something.  These numbers should, at some point, be
customizable.

With a numeric prefix argument N, the emacs window is positioned N frames from
the right hand side of the display.  For example, if you open three frames and
type into the first frame C-u 1 M-x \emph{shu-adapt-frame}, into the next frame
C-u 2 M-x \emph{shu-adapt-frame}, and into the third frame C-u 3 M-x \emph{shu-adapt-frame},
then the three frames will be grouped together side by side at the right side of
the display.

If the prefix argument is large enough that the left side of the frame would be
moved past the left side of the display, the window is positioned such that the
left edge of the window is aligned with the left edge of the display.

Prefix arguments greater than 10 assume a two display system.  Prefix arguments
of 11 and 12 put two frames on the right display.  Prefix arguments of 13 and
14 put two frames on the left display.

Implementation note:

If this function is called when the left side of the frame is positioned to the
left of the leftmost edge of the display, the function FRAME-POSITION returns a
negative value for the x coordinate of the frame.  The function
SET-FRAME-POSITION takes the x and y coordinates of the new position of the top
left corner of the frame.

But if x is negative, it specifies the coordinates of the right edge of the
frame relative to the right edge of the display.  This puts a frame that is very
close to the left edge of the display all the way over to the right edge of the
display.

The assumption is that a negative x frame position means that the user has
positioned the frame just a bit past the left edge and that the desired frame
position is actually the leftmost edge of the display.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-alexandria }}
\usebox{\funcname}
\index{shu-add-alexandria} \hfill [Command]\\%
 (Alias: add-alexandria)

\begin{doc-string}
Add Alexandria coverage to a git repository.
This function first checks to ensure that a README.md file exists that does not
contain an Alexandria badge and that a Doxyfile does not exist.  If those two
conditions are met, an Alexandria badge is added to the bottom of the README.md
file, a Doxyfile is created, and some of the tags in the Doxyfile are set to
reasonable defaults.  An ALEXANDRIA\_DOC\_DEPENDENCIES tag is added to the end of
the Doxyfile as a comment.
If this function succeeds, it returns true, else nil.  The return value may
be used by batch mode functions that want to call this function and report
whether or not it succeeded.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-alexandria-badge }}
\usebox{\funcname}
\index{shu-add-alexandria-badge} \hfill [Command]\\%
 (Alias: add-alexandria-badge)

\begin{doc-string}
Insert an Alexandria badge for the current project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-alexandria-in-batch-mode }}
\usebox{\funcname}
\index{shu-add-alexandria-in-batch-mode} \hfill [Function]

\begin{doc-string}
Call the function \emph{shu-add-alexandria} in batch mode.  The function
\emph{shu-add-alexandria} normally ends in edit mode in Doxyfile so that the user can
do a final edit and save.  In batch mode, this function does a save of the
Doxyfile since there is no interactive user.

If the function succeeds, it returns true, else nil.  This allows the top level
batch invoking function to terminate emacs with a zero or non-zero return code
to indicate to an external script whether or not the add command worked.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-doxyfile }}
\usebox{\funcname}
\index{shu-add-doxyfile} \hfill [Function]

\begin{doc-string}
Call ``doxygen -g'' to create a Doxyfile.  Return the output from the doxygen command.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-add-prefix }}
\usebox{\funcname}\emph{prefix}
\index{shu-add-prefix} \hfill [Command]\\%
 (Alias: add-prefix)

\begin{doc-string}
Put a prefix and a space in front of each line in the region.  Prompt is issued
for the prefix.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-all-quit }}
\usebox{\funcname}
\index{shu-all-quit} \hfill [Command]\\%
 (Alias: all-quit)

\begin{doc-string}
Kill all dired buffers and all buffers that contain a file and are unmodified.
It is not uncommon to have dozens of buffers open that are unrelated to the current task
and this is a convenience function for closing many buffers that do not need to
be open.
If the function \emph{shu-clear-c-project} is defined, it is called to clear the current
project.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-buffer-number-lines }}
\usebox{\funcname}
\index{shu-buffer-number-lines} \hfill [Command]\\%
 (Alias: buffer-number-lines)

\begin{doc-string}
Create a buffer whose name is derived from the file name of the current
buffer but with the string ``-numbered'' added to the name.  Thus ``foo.cpp''
would become ``foo-numbered.cpp'' Into this new buffer, copy the contents of the
current file with each line prefixed with its line number.  This is designed for
those times when you want to copy snippets of code with the line number in front
of each line because you are commenting on code and want the person receiving
the comments to sea the line number in front of each line.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-case-insensitive }}
\usebox{\funcname}
\index{shu-case-insensitive} \hfill [Command]\\%
 (Alias: case-insensitive)

\begin{doc-string}
Set the variable case-fold-search to t to make searches and matches ignore
case.  I can never remember which way to set case-fold-search, hence this
simple, little function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-case-sensitive }}
\usebox{\funcname}
\index{shu-case-sensitive} \hfill [Command]\\%
 (Alias: case-sensitive)

\begin{doc-string}
Set the variable case-fold-search to nil to make searches and matches respect
case.  I can never remember which way to set case-fold-search, hence this
simple, little function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-change-namespace }}
\usebox{\funcname}\emph{input}
\index{shu-change-namespace} \hfill [Command]\\%
 (Alias: change-namespace)

\begin{doc-string}
This function changes the namespace in a set of C++ source files.

The files to be changed must follow these conventions:

 - The namespace name is all lower case
 - Each file name starts with the lower case namespace name followed by an
   underscore

The following steps are performed:

 1. Locate all of the files to be changed.  These are all files that hold C++
 source code in the current directory or in any directory below the current
 directory.  The set of files may be restricted by specifying a regular
 expression.  The regular expression does not need to include the file type.

 2. The files to be changed are renamed with the new namespace replacing the
 old in the file name.  If any file is part of a git repository, then ``git mv''
 is used for the rename operation.  Otherwise, ``mv'' is used.

 3. The files are then edited to replace all occurrences of the old namespace
 with the new.

The existing namespace, new namespace and file search pattern are specified with
a single string.

The first character of the string is a delimiter character that is used to split
the string.  The existing namespace, new namespace and file search pattern are
separated from each other with the delimiter.

For example, to specify an existing namespace of ``fumblebar'', a new namespace
of ``wunderbar'', and a search pattern of ``\emph\{*exception*\}'', one might specify

\small{\begin{verbatim}
       $fumblebar$wunderbar$\emph{*exception*}
\end{verbatim}}

or

\small{\begin{verbatim}
       @fumblebar@wunderbar@\emph{*exception*}
\end{verbatim}}

The search pattern is optional.  The following string would do the same
namespace replacement for all C++ files.

\small{\begin{verbatim}
       $fumblebar$wunderbar
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-comma-names-to-letter }}
\usebox{\funcname}
\index{shu-comma-names-to-letter} \hfill [Command]\\%
 (Alias: comma-names-to-letter)

\begin{doc-string}
In a list of names, change all occurrences
of Lastname, Firstname to an empty Latex letter.
Position to the start of the file and invoke once.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-conditional-find-file }}
\usebox{\funcname}\emph{file-name}
\index{shu-conditional-find-file} \hfill [Command]

\begin{doc-string}
Make the buffer for \emph{file-name} the current buffer.  If \emph{file-name} is already
loaded into a buffer, then make that the current buffer.  If \emph{file-name} is not
loaded into a buffer, load the file into a buffer and make that the current
buffer.  Return true if this function created the buffer, nil otherwise.

This function is intended to handle the situation in which a function wants
to visit the contents of several files but does not want to leave behind a
lot of file buffers that it created.

If this function returns true, then the calling function should kill the
buffer when it is finished with it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-copy-repo }}
\usebox{\funcname}
\index{shu-copy-repo} \hfill [Command]\\%
 (Alias: copy-repo)

\begin{doc-string}
Call \emph{shu-get-repo} to find the path to the repository and put the result in
the kill ring.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-de-star }}
\usebox{\funcname}
\index{shu-de-star} \hfill [Command]\\%
 (Alias: de-star)

\begin{doc-string}
Remove leading spaces and asterisk from each line in the region.  This is
useful for editing doxygen comments of the form:

   /*!
\small{\begin{verbatim}
    * This is some commentary.
    * This is more commentary, etc.
    \emph{*/}
\end{verbatim}}

You snip out the middle lines and put them into a text file for formatting and
spell-checking.  You want to get rid of all of the asterisks until you are
done.

This function gets rid of all the asterisks.  You can use \emph{shu-add-prefix} to
put them back.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dired-mode-name }}
\usebox{\funcname}
\index{shu-dired-mode-name} \hfill [Constant]

\begin{doc-string}
The name of the mode for a dired buffer
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-disabled-quit }}
\usebox{\funcname}
\index{shu-disabled-quit} \hfill [Command]

\begin{doc-string}
Explain that C-x C-c no longer kills emacs.  Must M-x quit instead.
Far too often, I hit C-x C-c by mistake and emacs vanishes.  So I map
C-x C-c to this function and use an explicit M-x quit to exit emacs.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dump-list }}
\usebox{\funcname}\emph{items} \emph{log-buffer}
\index{shu-dump-list} \hfill [Function]

\begin{doc-string}
\emph{items} is a list of strings, which is printed into \emph{log-buffer}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dump-rename-list }}
\usebox{\funcname}\emph{files} \emph{log-buffer}
\index{shu-dump-rename-list} \hfill [Function]

\begin{doc-string}
\emph{files} is a list of cons cells.  The CAR of each cons cell is the name of an
existing file.  The CDR of each cons cell is the name that the file will have
after the rename operation.  This function prints into the \emph{log-buffer} the old
and new file names to show the name changes that will take place as the rename
happens.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-dup }}
\usebox{\funcname}
\index{shu-dup} \hfill [Command]\\%
 (Alias: dup)

\begin{doc-string}
Insert a duplicate of the current line, following it.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-edit-namespace-cmake-buffer }}
\usebox{\funcname}\emph{newfiles}
\index{shu-edit-namespace-cmake-buffer} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
The current buffer is a CMake file (instances of CMakeLists.txt).  \emph{newfiles}
is a list of cons cells.  The CAR of each cons cell is the old file name.  The
CDR of each cons cell is the new file name.

This function edits the buffer replacing all instances of the old file name with
the new file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-edit-namespace-cmake-files }}
\usebox{\funcname}\emph{root} \emph{cmake-files}
\index{shu-edit-namespace-cmake-files} \hfill [Function]
\hspace*{\wd\funcname}\emph{log-buffer}

\begin{doc-string}
\emph{cmake-files} is a list of CMake files (instances of CMakeLists.txt).  \emph{newfiles}
is a list of cons cells.  The CAR of each cons cell is the old file name.  The
CDR of each cons cell is the new file name.

This function edits each CMake file replacing all instances of the old file name
with the new file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-edit-new-namespace-files }}
\usebox{\funcname}\emph{root} \emph{newfiles}
\index{shu-edit-new-namespace-files} \hfill [Function]
\hspace*{\wd\funcname}\emph{new-namespace}
\hspace*{\wd\funcname}

\begin{doc-string}
\emph{newfiles} is a list of cons cells.  The CAR of each cons cell is the old file
name.  The CDR of each cons cell is the new file name.  This function uses
\emph{shu-replace-namespace-in-buffer} to replace the \emph{old-namespace} name with the
\emph{new-namespace} name.

The editing progress is logged in the \emph{log-buffer}.

This functions quits as soon as the first edit fails, leaving the reason for the
failure in the \emph{log-buffer}.

Returns t if all of the edits succeeded, nil otherwise.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-eob }}
\usebox{\funcname}
\index{shu-eob} \hfill [Command]

\begin{doc-string}
Go to end of buffer without setting mark.  Like end-of-buffer
but does not set mark - just goes there.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-erase-region }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-erase-region} \hfill [Function]

\begin{doc-string}
Replace everything in the region between \emph{start} and \emph{end} with blanks.  This is
exactly like delete-region except that the deleted text is replaced with spaces.
As with delete-region, the end point is not included in the delete.  It erases
everything up to but not including the end point.  The order of \emph{start} and \emph{end}
does not matter.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-expand-header-line }}
\usebox{\funcname}\emph{expand-count}
\index{shu-expand-header-line} \hfill [Function]

\begin{doc-string}
If the first line of the buffer contains the sentinel ``-\emph\{*-C++-*-\}'', add
\emph{expand-count} spaces in front of it.

If the first line of the buffer does not contain the sentinel ``-\emph\{*-C++-*-\}'',
do nothing.

Return the number of spaces actually added.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-extract-name-open-grok }}
\usebox{\funcname}
\index{shu-extract-name-open-grok} \hfill [Command]\\%
 (Alias: scan-grok)

\begin{doc-string}
The current buffer contains output from an OpenGrok search that has been
copied from the web page and pasted into the buffer.  This function scans the
buffer from the current point and harvests all of the file names that hold the
references for which OpenGrok searched.  It puts the file names (including their
top level directories) into the buffer ``\emph\{**shu-open-grok**\}''.
The number of file names found is returned, mostly for the benefit of unit
tests.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-extract-replacement-strings }}
\usebox{\funcname}\emph{rstring}
\index{shu-extract-replacement-strings} \hfill [Function]

\begin{doc-string}
Parse a sed-like search and replacement string such as ``/abc/defg''.

This function parses such a string.  The first character in the string is the
delimiter.  The delimiter character is used to break the string into two
strings, in this case ``abc'' and ``defg''.  If this can be done successfully,
the two strings are returned in a cons cell.  If the string cannot be parsed,
nil is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-extract-replacement-triple }}
\usebox{\funcname}\emph{rstring}
\index{shu-extract-replacement-triple} \hfill [Function]

\begin{doc-string}
Parse a sed-like search and replacement string that specifies three parts
such as ``/abc/defg/xyz''.

This function parses such a string.  The first character in the string is the
delimiter.  The delimiter character is used to break the string into two or
three strings, in this case ``abc'', ``defg'', and ``xyz''.  If this can be done
successfully, the three strings are returned in a list.  If the string cannot be
parsed, nil is returned.

There my be two or three occurrences of the delimiter character.  For example

\small{\begin{verbatim}
      ``$abc$def$ghi''
\end{verbatim}}

returns the list

\small{\begin{verbatim}
      1. ``abc''
      2. ``def''
      3. ``ghi''

      ``$abc$def$''
\end{verbatim}}

returns the list

\small{\begin{verbatim}
      1. ``abc''
      2. ``def''
      3. ``''  (Empty string)
\end{verbatim}}

as does ``$abc$def'' with no trailing delimiter character.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-fix-header-line }}
\usebox{\funcname}
\index{shu-fix-header-line} \hfill [Command]\\%
 (Alias: fix-header)

\begin{doc-string}
If the first line of the buffer contains the sentinel ``-\emph\{*-C++-*-\}'', adjust
the line length to be \emph{shu-cpp-comment-end} in length, adding or removing
internal space as necessary.

If the first line of the buffer does not contain the sentinel ``-\emph\{*-C++-*-\}'',
do nothing.

Return the number of spaces actually adjusted.  0 means no adjustment made.
A positive number represents the number of spaces added.  A negative number
represents the number of spaces removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-fix-markdown-section }}
\usebox{\funcname}\emph{max-depth}
\index{shu-fix-markdown-section} \hfill [Function]

\begin{doc-string}
On entry, point is positioned after one or more pound signs that define the
beginning of a markdown section heading.  If the number of pound signs is
greater than \emph{max-depth}, ignore the line and return nil.  If the number of
pound signs is less than or equal to \emph{max-depth}, fix the line as described
below and return it.

If the line ends with an expression that looks like

\small{\begin{verbatim}
      ``<a name=currentliveupdate></a>``,
\end{verbatim}}

remove it.

If the line ends with trailing pound signs, remove them as well.

Then return the repaired line.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-fix-times }}
\usebox{\funcname}
\index{shu-fix-times} \hfill [Command]

\begin{doc-string}
Go through a buffer that contains timestamps of the form
\small{\begin{verbatim}
     YYYY-MM-DDTHHMMSS.DDD
\end{verbatim}}
converting them to the form
\small{\begin{verbatim}
     YYYY-MM-DD HH:MM:SS.DDD
\end{verbatim}}
The latter is a format that Microsoft Excel can import.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-fixup-doxyfile }}
\usebox{\funcname}
\index{shu-fixup-doxyfile} \hfill [Command]\\%
 (Alias: fixup-doxyfile)

\begin{doc-string}
The current directory is assumed to have the same name as the project for
which the Doxyfile was created.  This function sets various default values in
the Doxyfile.  The current buffer is the Doxyfile.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-fixup-project-doxyfile }}
\usebox{\funcname}\emph{project-name}
\index{shu-fixup-project-doxyfile} \hfill [Command]

\begin{doc-string}
\emph{project-name} is the name of the project for which the Doxyfile has been created.
This function sets standard default values.
If this function succeeds, it return true, else nil.  The return value may be used
in batch mode to determine if the fixup was successful.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-forward-line }}
\usebox{\funcname}
\index{shu-forward-line} \hfill [Function]

\begin{doc-string}
Move forward by one line.  If there is a next line, point it moved into
it.  If there are no more lines, a new one is created.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-frame-width }}
\usebox{\funcname}
\index{shu-frame-width} \hfill [Function]

\begin{doc-string}
Return the width of an emacs frame.  Different operating systems appear to
have slightly different windowing systems, which means that the
FRAME-INNER-WIDTH function does not quite report the exact width.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gd }}
\usebox{\funcname}
\index{shu-gd} \hfill [Command]\\%
 (Alias: gd)

\begin{doc-string}
While in dired, put the full path to the current directory in the kill ring
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-containing-function }}
\usebox{\funcname}
\index{shu-get-containing-function} \hfill [Function]

\begin{doc-string}
Search backwards from the current point to find the beginning of the enclosing
function, macro, etc.  If such a beginning is found, return a cons cell whose car
is the point that defines the point at the beginning of the function and whose cdr
defines the point at the end of the function.  If not inside a function, macro, etc.,
return nil
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-current-line }}
\usebox{\funcname}
\index{shu-get-current-line} \hfill [Function]

\begin{doc-string}
Return the current line in the buffer as a string
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-debian-dependencies }}
\usebox{\funcname}
\index{shu-get-debian-dependencies} \hfill [Function]

\begin{doc-string}
This function tries to find a Debian library dependency file in the current
directory tree.  If such a file is found, this function returns a sorted list of
the dependencies listed in the Debian dependency file.  If no such file exists,
nil is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-debian-dependency-file }}
\usebox{\funcname}
\index{shu-get-debian-dependency-file} \hfill [Function]

\begin{doc-string}
Use the name of the current directory as the name of a debian library.
Construct a dependency file name which is the name of the current directory with
a file type of ``.dep''.  Search through the directory tree for such a file.  If
the file is found return its fully qualified name, i.e., the full path to the
file so that it may be opened.  If no such file exists, return nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-debian-dependency-line }}
\usebox{\funcname}
\index{shu-get-debian-dependency-line} \hfill [Function]

\begin{doc-string}
This function tries to find a Debian library dependency file in the current
directory tree.  If such a file is found, this function returns a single line of
text that holds the space separated names of all of the dependencies.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-git-name }}
\usebox{\funcname}\emph{path}
\index{shu-get-git-name} \hfill [Function]

\begin{doc-string}
\emph{path} is the url of a git repository from the [remote ``origin''] section of a
.git/config file.  For example, the entry for this repository is

\small{\begin{verbatim}
      https://github.com/codesinger/shu.git
\end{verbatim}}

This function extracts two pieces of information from the URL.  One is the name
of the repository, which in this case is ``shu''.  The other is the path to the
repository, which includes the owning group, which in this case is
``codesinger/shu''.

Those two items are returned in a cons cell with the car of the cons cell
holding the path (with owning group) and the cdr of the cons cell holding the
repository name.

The assumptions made by this function are as follows: The beginning of the
owning group and repository name are preceded by a domain name followed by
either a colon or a slash.  In the case of this repository, the owning group and
repository name are preceded by ``github.com/''.  The repository name may or may
not have a trailing ``.git'', which this function removes.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-git-repo-name }}
\usebox{\funcname}
\index{shu-get-git-repo-name} \hfill [Function]

\begin{doc-string}
This function tries to get the name of the current git repository
from the .git/config file.  Returns nil if it cannot open .git/config.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-git-repo-path }}
\usebox{\funcname}
\index{shu-get-git-repo-path} \hfill [Function]

\begin{doc-string}
This function tries to get the host local path to the current git repository
from the .git/config file if possible.  If it cannot find the .git/config file,
the it uses the shu custom variable \emph{shu-internal-group-name} as the group owner
and uses the name of the current directory as the repository name and constructs
a host local path that is the owning group name, a slash, and the putative
repository name (the name of the current directory.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-markdown-heading }}
\usebox{\funcname}\emph{section-heading}
\index{shu-get-markdown-heading} \hfill [Function]

\begin{doc-string}
Returns the heading text from a markdown section heading, \emph{section-heading}.
There must be at least one pound sign at the beginning of the string.  If a
section heading is

   ``\#\#\# This is a section heading''

then the string ``This is a section heading'' is returned.  If the first
character in the section heading is not a pound sign, nil is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-markdown-level }}
\usebox{\funcname}\emph{section-heading}
\index{shu-get-markdown-level} \hfill [Function]

\begin{doc-string}
Return the level of a markdown section heading.  The level is defined as
the number of leading pound signs that start at the beginning of the string.
A level 1 heading begins with ``\#''.  A level 2 heading begins with ``\#\#''.
If there are no leading pound signs at the beginning of the string, a level of
zero is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-markdown-prefix }}
\usebox{\funcname}\emph{section-heading}
\index{shu-get-markdown-prefix} \hfill [Function]

\begin{doc-string}
Returns the pound sign prefix from a markdown section heading,
\emph{section-heading}.  The string of pound signs must begin at the beginning of the
string.  If a section heading is

   ``\#\#\# This is a section heading''

then the string ``\#\#\#'' is returned.  If the first character in the section
heading is not a pound sign, nil is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-md-boundaries }}
\usebox{\funcname}
\index{shu-get-md-boundaries} \hfill [Function]

\begin{doc-string}
Find all pairs of markdown literal text.  In markdown, the sequence ``` is
used to bound literal text.  When creating a markdown table of contents, we do
not want to look at pound signs contained in literal text.  This function finds
the location of each pair of ``` sentinels.  It returns a list of cons sells,
each of which has the start and end position of a ``` sequence.  If there is a
start ``` with no companion ``` close, it is not included in the list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-name-and-version }}
\usebox{\funcname}
\index{shu-get-name-and-version} \hfill [Function]

\begin{doc-string}
When positioned anywhere on a line that looks like

\small{\begin{verbatim}
        Published version 1.2.9 of library
\end{verbatim}}

return a string of the form ``library=1.2.9''.  If the current line does not
match the required pattern, return nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-repo }}
\usebox{\funcname}
\index{shu-get-repo} \hfill [Function]\\%
 (Alias: get-repo)

\begin{doc-string}
When positioned anywhere in a git repository, return the git path to the
repository.  This is found in .git/config as the url of [remote ``origin''].
Return nil if the path cannot be found.

The search is made from the current directory and upwards for the first
directory called ``.git''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-url-repo }}
\usebox{\funcname}
\index{shu-get-url-repo} \hfill [Function]

\begin{doc-string}
Return the web URL for the current git repository.  If the URL cannot be
found, nil is returned.

The url for the git repository in .git/config is of the form

\small{\begin{verbatim}
       git@web-address:repository-name.git
\end{verbatim}}

This function removes the trailing ``.git'', replaces the leading ``git@'' with
``https://'' and replaces the ``:'' between the web-address and repository-name
with ``/''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-getnv }}
\usebox{\funcname}
\index{shu-getnv} \hfill [Command]\\%
 (Alias: getnv)

\begin{doc-string}
When positioned anywhere on a line that looks like

\small{\begin{verbatim}
        Published version 1.2.9 of library
\end{verbatim}}

put into the kill ring  a string of the form ``library=1.2.9''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gf }}
\usebox{\funcname}
\index{shu-gf} \hfill [Command]\\%
 (Alias: gf)

\begin{doc-string}
While in dired, put the full path to the current file in the kill ring
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gfc }}
\usebox{\funcname}
\index{shu-gfc} \hfill [Command]\\%
 (Alias: gfc)

\begin{doc-string}
While in a file buffer, put both the current line number and
column number and the name of the current file into the kill ring
in the form of ``foo.cpp:123:2''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gfl }}
\usebox{\funcname}
\index{shu-gfl} \hfill [Command]\\%
 (Alias: gfl)

\begin{doc-string}
While in a file buffer, put both the current line number and the name of the current
file into the kill ring in the form of ``line 1234 of foo.cpp''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gfn }}
\usebox{\funcname}
\index{shu-gfn} \hfill [Command]\\%
 (Alias: gfn)

\begin{doc-string}
While in a file buffer, put the name of the current file into the kill ring.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-gquote }}
\usebox{\funcname}
\index{shu-gquote} \hfill [Command]\\%
 (Alias: gquote)

\begin{doc-string}
Insert a LaTeX quote environment and position the cursor for typing the quote.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-insert-markdown-toc }}
\usebox{\funcname}\emph{entries}
\index{shu-insert-markdown-toc} \hfill [Function]

\begin{doc-string}
\emph{entries} is a list of cons cells.  The car of each item on the list is the
markdown heading line, which looks something like ``\#\# This is a heading''.
The cdr of each item on the list is the link name.  This function inserts a
markdown table of contents in which each line in the table of contents
consists of the heading text in brackets followed by the line name in
parenthesis and preceded by a pound sign.  Each line that represents a heading
level greater than one is also indented to indicate its heading level.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-get-repo }}
\usebox{\funcname}
\index{shu-internal-get-repo} \hfill [Function]

\begin{doc-string}
The current buffer holds an instance of the ``.git/config'' file for the
repository.  This function returns the git path to the repository, which is the
url given after [remote ``origin''].  nil is returned if the path cannot be
found.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-new-lisp }}
\usebox{\funcname}\emph{func-type} \emph{func-name}
\index{shu-internal-new-lisp} \hfill [Command]
\hspace*{\wd\funcname}\emph{doc-string} \emph{interactive}

\begin{doc-string}
Insert at point a skeleton lisp function of type \emph{func-type} whose name is
\emph{func-name}.  \emph{func-type} is not examined in any way but is only useful if its
value is ``defun'', ``defmacro'', ``ert-deftest'', etc.  If \emph{interactive} is
true, the function is interactive.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-internal-process-new-namespace }}
\usebox{\funcname}\emph{root}
\index{shu-internal-process-new-namespace} \hfill [Function]
\hspace*{\wd\funcname}\emph{new-namespace}
\hspace*{\wd\funcname}

\begin{doc-string}
Starting in directory \emph{root}, look for files as follows.  If \emph{pattern} is nil, look
for all files that hold C++ code.  If \emph{pattern} is non-nil, use that to search for
files that hold C+++ code.

Of the set of files found, change the namespace from \emph{old-namespace} to
\emph{new-namespace}.

It is assumed that files follow the standard convention of using the namespace as
the first part of the file followed by an underscore.  If the current namespace is
``mumblebar'', then all file names start with ``mumblebar\_''.  If the new namespace
is ``fubmblenew'', then all files whose names start with ``mumblebar\_'' will be
renamed to start with ``fubmblenew\_''.  Within the new files, all instances of
``mumblebar'' will be changed to instances of ``fubmblenew''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-is-common-prefix }}
\usebox{\funcname}\emph{prefix} \emph{strings}
\index{shu-is-common-prefix} \hfill [Function]

\begin{doc-string}
If \emph{prefix} is a common prefix in the list of \emph{strings}, return \emph{prefix},
else, return nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-is-common-substring }}
\usebox{\funcname}\emph{substring} \emph{strings}
\index{shu-is-common-substring} \hfill [Function]

\begin{doc-string}
If \emph{substring} is a common substring in the list of \emph{strings}, return \emph{substring},
else, return nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-kill-current-buffer }}
\usebox{\funcname}
\index{shu-kill-current-buffer} \hfill [Command]

\begin{doc-string}
Kills the current buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-kill-repo }}
\usebox{\funcname}
\index{shu-kill-repo} \hfill [Command]

\begin{doc-string}
When positioned in the top level directory of a git repository, place into
the kill ring the git path to the repository.  This is found in .git/config as
the url of [remote ``origin'']

This should probably be extended to do a search for the .git directory anywhere
above the current position, which would remove the requirement to be in the root
of the repository.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-kill-system-name }}
\usebox{\funcname}
\index{shu-kill-system-name} \hfill [Command]\\%
 (Alias: kill-system-name)

\begin{doc-string}
Place the system name` (machine name) in the message area.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-local-replace }}
\usebox{\funcname}\emph{from-string} \emph{to-string}
\index{shu-local-replace} \hfill [Function]

\begin{doc-string}
Replaces \emph{from-string} with \emph{to-string} anywhere found in the buffer.
This is like replace-string except that it is intended to be called
by lisp programs.  Note that this function does not alter the value of
case-fold-search.  The user should set it before calling this function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-longest-common-prefix }}
\usebox{\funcname}\emph{strings}
\index{shu-longest-common-prefix} \hfill [Command]

\begin{doc-string}
Return the longest common prefix of the list of \emph{strings}.  Return nil if there
is no common prefix.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-longest-common-substring }}
\usebox{\funcname}\emph{strings}
\index{shu-longest-common-substring} \hfill [Command]

\begin{doc-string}
Return the longest common substring of the list of \emph{strings}.  Return nil if
there is no common substring.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-loosen-lisp }}
\usebox{\funcname}
\index{shu-loosen-lisp} \hfill [Command]\\%
 (Alias: loosen-lisp)

\begin{doc-string}
Within the bounds of a lisp function, unwind the parentheses that terminate
conditional and containing functions such that it is convenient to insert code
inside of them without having to worry about which line contains the closing
parenthesis.  All closing parentheses are now on separate lines.  Once the
changes to the function are complete, you can run \emph{shu-tighten-lisp} to put the
parentheses back where they belong.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-header-line }}
\usebox{\funcname}
\index{shu-make-header-line} \hfill [Command]\\%
 (Alias: make-header)

\begin{doc-string}
At the top of the current buffer, insert a string that holds the standard
first line comment in a C++ file, which is of the form:

\small{\begin{verbatim}
      ``// file_name                                      -\emph{*-C++-*-}''
\end{verbatim}}

The inserted line is of length \emph{shu-cpp-comment-end}.

Does nothing if the current buffer does not have an associated file name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-md-index-name }}
\usebox{\funcname}\emph{name}
\index{shu-make-md-index-name} \hfill [Function]

\begin{doc-string}
The input is a string that is assumed to be a markdown section heading from
a markdown table of contents.
The return value is an all lower case string with any whitespace characters
removed.
For example, if the input string is

\small{\begin{verbatim}
     This is an Overview
\end{verbatim}}

The returned string would be

\small{\begin{verbatim}
     thisisanoverview
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-md-name-entry }}
\usebox{\funcname}
\index{shu-make-md-name-entry} \hfill [Command]\\%
 (Alias: md-name)

\begin{doc-string}
The latest item in the kill ring is assumed to be the text of a markdown
section name.  This function creates from that section name, a markdown table of
contents name that will identify the section in the table of contents.

For example, if the kill ring contains ``\#\# This is the Overview'', the table
of contents name created and inserted at point will be:

\small{\begin{verbatim}
        <a name=thisistheoverview></a>
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-md-section-name }}
\usebox{\funcname}\emph{section-name}
\index{shu-make-md-section-name} \hfill [Function]

\begin{doc-string}
The input is a string that is assumed to be a markdown section heading.  The
return value is a string with any leading and trailing ``\#'' characters removed.
For example, if the input string is

\small{\begin{verbatim}
     ## This is an Overview ##
\end{verbatim}}

The returned string would be

\small{\begin{verbatim}
     This is an Overview
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-md-toc-entry }}
\usebox{\funcname}
\index{shu-make-md-toc-entry} \hfill [Command]\\%
 (Alias: md-toc)

\begin{doc-string}
The latest item in the kill ring is assumed to be the text of a markdown
section name.  This function creates from that section name, a markdown table of
contents entry and inserts that entry at point.

For example, if the kill ring contains ``\#\# This is the Overview \#\#'', the table
of contents entry created and inserted at point will be

\small{\begin{verbatim}
       * [This is the overview](#thisistheoverview)
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-md-in-literal }}
\usebox{\funcname}\emph{literals} \emph{pt}
\index{shu-md-in-literal} \hfill [Function]

\begin{doc-string}
\emph{literals} is a list of markdown literal boundaries produced by
\emph{shu-get-md-boundaries}.  This function returns t if the point \emph{pt} lies within a
markdown literal boundary.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-get-chunk }}
\usebox{\funcname}\emph{line-limit} \textbf{\&optional} \emph{escape}
\index{shu-misc-get-chunk} \hfill [Function]

\begin{doc-string}
Return a string that consists of the first \emph{line-limit} characters in the
current buffer.  If \emph{line-limit} is larger than the buffer size, return a
string that is the entire contents of the buffer.  Before returning, delete
from the buffer the returned string.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-get-phrase }}
\usebox{\funcname}\emph{line-limit} \textbf{\&optional} \emph{escape}
\index{shu-misc-get-phrase} \hfill [Function]

\begin{doc-string}
Remove from the front of the current buffer and return the longest possible
string of whitespace separated things whose length does not exceed line-limit.
If there is at least one whitespace character before \emph{line-limit}, the string will
end with one or more whitespace characters.  i.e., the string will end on a word
boundary if that is possible.

Words will not be split unless there is no whitespace character before
\emph{line-limit} characters have been scanned, in which case a string of exactly
\emph{line-limit} length will be removed and returned.

This function is used to split a string of words into a set of smaller strings
such that words are not split.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-internal-split-buffer }}
\usebox{\funcname}\emph{line-limit}
\index{shu-misc-internal-split-buffer} \hfill [Function]
\hspace*{\wd\funcname}\textbf{\&optional} \emph{escape}

\begin{doc-string}
Split an entire buffer into multiple strings and return a list of the
strings.  \emph{get-function} is the function to call to fetch each new string.
\emph{get-function} is set to either \emph{shu-misc-get-chunk} or \emph{shu-misc-get-phrase}.

\emph{shu-misc-get-chunk} returns each string as a fixed length string of \emph{line-limit}
characters, except for the last one, which may be shorter.

\emph{shu-misc-get-phrase} returns the longest possible string that ends on a word
boundary and whose length is less than or equal to \emph{line-limit}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-make-unique-string }}
\usebox{\funcname}\emph{string} \emph{suffix-length}
\index{shu-misc-make-unique-string} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Input is a hash table, \emph{ht}, as well as a \emph{string}.  If the string does not
already exist in \emph{ht}, add the string to the hash table and return the string.
If the string already exists in \emph{ht}, add a suffix to the string that is a
random string of length \emph{suffix-length}.  If the combination of the original
\emph{string} plus the random string added as a suffix, does not exist in the hash
table, add the new string to the hash table and return it.  This provides the
generation of a set of unique string names.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-random-internal-string }}
\usebox{\funcname}\emph{letters} \emph{length}
\index{shu-misc-random-internal-string} \hfill [Function]

\begin{doc-string}
Return a string composed of random \emph{letters} of length \emph{length}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-random-lad-string }}
\usebox{\funcname}\emph{length}
\index{shu-misc-random-lad-string} \hfill [Function]

\begin{doc-string}
Return a string composed of random lower case letters and digits of length
 \emph{length}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-random-ua-string }}
\usebox{\funcname}\emph{length}
\index{shu-misc-random-ua-string} \hfill [Function]

\begin{doc-string}
Return a string composed of random upper case letters of length \emph{length}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-rx-conditionals }}
\usebox{\funcname}
\index{shu-misc-rx-conditionals} \hfill [Constant]

\begin{doc-string}
Regular expression to find the beginning of a function or macro that encloses
a body.  Such functions usually require a future closing parenthesis that is
likely not on the current line.  This is used by the functions \emph{shu-tighten-lisp}
and \emph{shu-loosen-lisp}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-rx-functions }}
\usebox{\funcname}
\index{shu-misc-rx-functions} \hfill [Constant]

\begin{doc-string}
Regular expression to find the beginning of a function, macro, etc.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-rx-lets }}
\usebox{\funcname}
\index{shu-misc-rx-lets} \hfill [Constant]

\begin{doc-string}
Regular expression to find the beginning of a let special form.
This searches for ``let'' or ``let*'' followed by ``(``.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-set-alias }}
\usebox{\funcname}
\index{shu-misc-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-misc.
These are generally the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-split-buffer }}
\usebox{\funcname}\emph{line-limit} \textbf{\&optional}
\index{shu-misc-split-buffer} \hfill [Function]
\hspace*{\wd\funcname}\emph{escape}

\begin{doc-string}
Split an entire buffer into multiple strings and return a list of the
strings.  If \emph{fixed-width} is true, then each returned string is \emph{line-limit}
characters in length, except for the last, which may be shorter.  If \emph{fixed-width}
is absent or nil, then each returned string is split on a word boundary and no
string exceeds \emph{line-limit} characters in length.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-split-chunk-buffer }}
\usebox{\funcname}\emph{line-limit} \textbf{\&optional}
\index{shu-misc-split-chunk-buffer} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Split an entire buffer into multiple strings and return a list of the
strings.  Each returned string is \emph{line-limit} characters in length, except for
the last one, which may be shorter.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-split-phrase-buffer }}
\usebox{\funcname}\emph{line-limit}
\index{shu-misc-split-phrase-buffer} \hfill [Function]

\begin{doc-string}
Split an entire buffer into multiple strings and return a list of the
strings.  Each returned string is split on a word boundary and no string exceeds
\emph{line-limit} characters in length.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-misc-split-string }}
\usebox{\funcname}\emph{input} \emph{line-limit} \textbf{\&optional}
\index{shu-misc-split-string} \hfill [Function]
\hspace*{\wd\funcname}\emph{escape}

\begin{doc-string}
Split a string into multiple strings and return a list of the strings.  If
\emph{fixed-width} is true, then each returned string is \emph{line-limit} characters in
length, except for the last, which may be shorter.  If \emph{fixed-width} is absent or
nil, then each returned string is split on a word boundary and no string exceeds
\emph{line-limit} characters in length.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-modified-buffers }}
\usebox{\funcname}
\index{shu-modified-buffers} \hfill [Command]\\%
 (Alias: modified-buffers)

\begin{doc-string}
Show a list of all buffers associated with files whose status is modified.
It is not uncommon to have many emacs windows open and to realize that one
window has a file open and another window is also trying to edit it.  emacs
warns the second window of the conflict, but it is sometimes difficult to tell
which window holds the modified buffer.  The buffer list shows you all of the
buffers with an asterisk next to each modified buffer, but if the buffer list
is large, it can be difficult to find the one you seek.  This command lists
only modified buffers that hold the contents of a file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-move-down }}
\usebox{\funcname}\emph{arg}
\index{shu-move-down} \hfill [Command]

\begin{doc-string}
Move point vertically down.  Whitespace in any direction is made if
necessary.  New lines will be added at the end of a file and lines that are
too short will be expanded as necessary.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-move-file }}
\usebox{\funcname}\emph{old-file} \emph{new-file}
\index{shu-move-file} \hfill [Function]

\begin{doc-string}
Issue ``mv old-file new-file''.

Return a cons cell whose CAR is t if the move succeeded and whose CDR is the
output of the move command.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-move-string }}
\usebox{\funcname}\emph{old-file} \emph{new-file}
\index{shu-move-string} \hfill [Function]

\begin{doc-string}
Return the ``mv'' command to rename \emph{old-file} to \emph{new-file}.  The result is
not intended to be executed.  It is intended for use in messages that explain
what operation is being done.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-namespace-filter-cmake-file }}
\usebox{\funcname}\emph{cmake-file}
\index{shu-namespace-filter-cmake-file} \hfill [Function]
\hspace*{\wd\funcname}\emph{log-buffer}

\begin{doc-string}
\emph{cmake-file} is a CMake file (CMakeLists.txt).  \emph{newfiles} is a list of cons
cells.  The CAR of each cons cell is the name of an existing code file with the
existing namespace.

This function returns true if any of the existing file names are found within
the \emph{cmake-file}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-namespace-find-cmake-files }}
\usebox{\funcname}\emph{newfiles} \emph{log-buffer}
\index{shu-namespace-find-cmake-files} \hfill [Function]

\begin{doc-string}
\emph{newfiles} is a list of cons cells.  The CAR of each cons cell is the name of
an existing code file with the existing namespace.

This function finds all CMake files (instances of CMakeLists.txt) and returns a
list of CMake file names, each of which holds at least one instance of an
existing file name.

These are the CMake files that will need editing after all of the file names
have been changed to the new namespace names.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-ert }}
\usebox{\funcname}\emph{func-name}
\index{shu-new-ert} \hfill [Command]\\%
 (Alias: new-ert)

\begin{doc-string}
Insert at point a skeleton lisp ert unit test.  Prompt is issued for the
function name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-latex }}
\usebox{\funcname}
\index{shu-new-latex} \hfill [Command]\\%
 (Alias: new-latex)

\begin{doc-string}
Build a skeleton, empty LaTeX file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-lisp }}
\usebox{\funcname}\emph{func-name}
\index{shu-new-lisp} \hfill [Command]\\%
 (Alias: new-lisp)

\begin{doc-string}
Insert at point a skeleton lisp function.  Prompt is issued for the function
name.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-new-lisp-while }}
\usebox{\funcname}\emph{var-name}
\index{shu-new-lisp-while} \hfill [Command]\\%
 (Alias: new-lisp-while)

\begin{doc-string}
Insert at point a skeleton lisp while loop.  Prompt is issued for the
variable name.  The while loop is of the form:

\small{\begin{verbatim}
     (while x

       (setq x (cdr x))
       )
\end{verbatim}}
point is placed where the the first line of code in the loop belongs.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-next-char-in-seq }}
\usebox{\funcname}\emph{current-char}
\index{shu-next-char-in-seq} \hfill [Function]

\begin{doc-string}
\emph{current-char} is a character in the range a-z (or A-Z).  This function returns
the next character, where next is the next character in the alphabet unless
\emph{current-char} is 'z', in which case the next character returned is 'a'.  If
\emph{current-char} is 'Z', then the next character returned is 'A'.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-number-lines }}
\usebox{\funcname}
\index{shu-number-lines} \hfill [Command]\\%
 (Alias: number-lines)

\begin{doc-string}
Insert in front of each line in the buffer its line number.  Starts
at point and continues to the end of the buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-obfuscate-region }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-obfuscate-region} \hfill [Command]\\%
 (Alias: obfuscate-region)

\begin{doc-string}
Obfuscate a region of text by replacing every alphabetic character in the
region with the next letter of the alphabet, staring with 'a'. For example, of
the region contains

  Now is the time for all good men to come to the aid of the Party 10 times.

Then the obfuscated text would be:

  Abc de fgh ijkl mno pqr stuv wxy za bcde fg hij klm no pqr Stuvw 10 xyzab.

This is useful if you want to capture some text for later testing and
manipulation that might contain confidential or proprietary information.  This
is an encoding that cannot be reversed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-of }}
\usebox{\funcname}
\index{shu-of} \hfill [Command]\\%
 (Alias: of)

\begin{doc-string}
While in dired, open the current file (Mac OS X only)
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-os-name }}
\usebox{\funcname}
\index{shu-os-name} \hfill [Function]

\begin{doc-string}
Return a string with the name of the type of the host operating system.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-prepare-for-rename }}
\usebox{\funcname}\emph{old-namespace} \emph{new-namespace}
\index{shu-prepare-for-rename} \hfill [Command]\\%
 (Alias: prepare-for-rename)

\begin{doc-string}
This is a function that helps to rename a list of files that share one common
part of a name to a list of files that have a different common part of the name.
For example, given the following set of files:

\small{\begin{verbatim}
      aaaa_mumble.cpp
      aaaa_mumble.h
      aaaa_mumble.t.cpp
\end{verbatim}}

it is not uncommon to want to change those file names to something like

\small{\begin{verbatim}
      abcdef_mumble.cpp
      abcdef_mumble.h
      abcdef_mumble.t.cpp
\end{verbatim}}

This can be done with the following work flow:

\small{\begin{verbatim}
      1. ls ``aaaa*'' >cf.txt

      2. Edit cf.txt to turn it into a script that renames the files from
         ``aaaa\emph{*\} to ``abcdef*''.
\end{verbatim}}

The editing steps are relatively straightforward, but take a small number of
minutes.

This function automates the editing steps.

When invoked interactively, it first prompts for the old common part and then
for the new common part.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-put-line-near-top }}
\usebox{\funcname}
\index{shu-put-line-near-top} \hfill [Command]

\begin{doc-string}
Take the line containing point and position it approximately five lines
from the top of the current window.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-quit }}
\usebox{\funcname}
\index{shu-quit} \hfill [Command]

\begin{doc-string}
Invoke save-buffers-kill-emacs.  This is the function normally
invoked by C-x C-c
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-remove-test-names }}
\usebox{\funcname}
\index{shu-remove-test-names} \hfill [Command]\\%
 (Alias: remove-test-names)

\begin{doc-string}
Remove from a file all lines that contain file names that end in .t.cpp
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-rename-namespace-files }}
\usebox{\funcname}\emph{newfiles} \emph{log-buffer}
\index{shu-rename-namespace-files} \hfill [Function]

\begin{doc-string}
\emph{newfiles} is a list of cons cells.  The CAR of each cons cell is the old file
name.  The CDR of each cons cell is the new file name.  This function renames
each file from old to new.

If the file is under git control, then ``git mv'' is used for the rename.  If
the file is not under git control, then ``mv'' is used for the rename.

Each rename command is placed in the \emph{log-buffer}.  This function quits as soon as
any rename fails, leaving the reason for the failure in the \emph{log-buffer}.

The return value is t if all of the renames worked, nil otherwise.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-replace-namespace-in-buffer }}
\usebox{\funcname}\emph{old-namespace}
\index{shu-replace-namespace-in-buffer} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Within the current buffer, do a case sensitive replace of \emph{old-namespace} with
\emph{new-namespace}.  Then do a case sensitive replace of the upper case version of
\emph{old-namespace} with the upper case version of \emph{new-namespace}.

At the end of all replacements, invoke \emph{shu-fix-header-line} to fix up the first
line of the file in case the length of the namespace has changed.

Return the count of items changed in the buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-replace-namespace-in-file-name }}
\usebox{\funcname}\emph{file-name}
\index{shu-replace-namespace-in-file-name} \hfill [Function]
\hspace*{\wd\funcname}\emph{new-namespace}

\begin{doc-string}
\emph{file-name} is the name of a file with a standard namespace prefix.

It is assumed that the file name uses the convention of the first part of the
name being the C++ namespace, followed by an underscore, followed by the class
name in all lower case.

\emph{old-namespace} is the current namespace.  \emph{new-namespace} is the new namespace that
is to replace the old.

Return a new file name that is the same as the original file name but with the
namespace part of the name replaced with the new namespace.

If the namespace appears in the file path it is not modified.  For example, if
the old namespace is ``mumble'' and the new namespace is ``bumble'', then the
following file name

\small{\begin{verbatim}
      mumble_bar/mumble_bar/mumble_observer.h
\end{verbatim}}

will be returned as

\small{\begin{verbatim}
      mumble_bar/mumble_bar/bumble_observer.h
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-reverse-comma-names }}
\usebox{\funcname}
\index{shu-reverse-comma-names} \hfill [Command]\\%
 (Alias: reverse-comma-names)

\begin{doc-string}
In a list of names, change all occurrences
of Lastname, Firstname to Firstname Lastname.
Position to the start of the file and invoke once.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-reverse2 }}
\usebox{\funcname}
\index{shu-reverse2} \hfill [Command]

\begin{doc-string}
When positioned in front of a pair of parenthesis that contains a pair of
expressions separated by a comma, reverse the positions of the two expressions.
The first becomes the second and the second becomes the first.
i.e.,
\small{\begin{verbatim}
      foo(mumble, bar);
\end{verbatim}}
becomes
\small{\begin{verbatim}
      foo(bar, mumble);
\end{verbatim}}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-save-and-load }}
\usebox{\funcname}
\index{shu-save-and-load} \hfill [Command]\\%
 (Alias: eld)

\begin{doc-string}
Save and load the current file as a .el file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-buffer-eol-type }}
\usebox{\funcname}\emph{eol-type}
\index{shu-set-buffer-eol-type} \hfill [Function]

\begin{doc-string}
Define what the end of line delimiter is in a text file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-dos-eol }}
\usebox{\funcname}
\index{shu-set-dos-eol} \hfill [Command]\\%
 (Alias: set-dos-eol)

\begin{doc-string}
Set the end of line delimiter to be the DOS standard (CRLF).
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-mac-eol }}
\usebox{\funcname}
\index{shu-set-mac-eol} \hfill [Command]

\begin{doc-string}
Set the end of line delimiter to be the Mac standard (CR).
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-set-unix-eol }}
\usebox{\funcname}
\index{shu-set-unix-eol} \hfill [Command]\\%
 (Alias: set-unix-eol)

\begin{doc-string}
Set the end of line delimiter to be the Unix standard (LF).
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-shift-line }}
\usebox{\funcname}\emph{count}
\index{shu-shift-line} \hfill [Command]

\begin{doc-string}
Shift a line of text left or right by \emph{count} positions.  Shift right
if \emph{count} is positive, left if \emph{count} is negative.  Shifting left only
eliminates whitespace.  If there is a non-whitespace character in column
5, then shift by -10 will only shift left 4.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-shift-region-of-text }}
\usebox{\funcname}\emph{count} \emph{start} \emph{end}
\index{shu-shift-region-of-text} \hfill [Command]

\begin{doc-string}
Shift a region of text left or right.  The test to be shifted is defined
by the bounds of lines containing point and mark.  The shift count is
read from the minibuffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-shift-single-line }}
\usebox{\funcname}\emph{count}
\index{shu-shift-single-line} \hfill [Function]

\begin{doc-string}
Shift a line of text left or right by \emph{count} positions.  Shift right
if \emph{count} is positive, left if \emph{count} is negative.  Shifting left only
eliminates whitespace.  If there is a non-whitespace character in column
5, then shift by -10 will only shift left 4.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-show-os-name }}
\usebox{\funcname}
\index{shu-show-os-name} \hfill [Command]\\%
 (Alias: os-name)

\begin{doc-string}
Display the name of the host operating system type.  This is a sanity check
function for the various functions defined in .emacs to determine the type of
the host operating system.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-show-repo }}
\usebox{\funcname}
\index{shu-show-repo} \hfill [Command]\\%
 (Alias: show-repo)

\begin{doc-string}
Call \emph{shu-get-repo} to find the path to the repository and show the result in
the minibuffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-show-system-name }}
\usebox{\funcname}
\index{shu-show-system-name} \hfill [Command]\\%
 (Alias: show-system-name)

\begin{doc-string}
Place the system name (machine name) in the message area.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-sitting-end }}
\usebox{\funcname}\emph{regex} \emph{dir}
\index{shu-sitting-end} \hfill [Function]

\begin{doc-string}
If the text at (point) is a character that matches \emph{regex}, scan until either
whitespace or the beginning / end of the line is reached.  If all characters
scanned match \emph{regex}, return the point of the last matching character, otherwise
return nil.  \emph{dir} indicates the direction of the scan.  Negative does a backward
scan.  Non-negative does a forward scan.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-sitting-on }}
\usebox{\funcname}\emph{regex}
\index{shu-sitting-on} \hfill [Function]

\begin{doc-string}
If the contiguous string of characters at (point) all match \emph{regex} bounded by
either whitespace or the begin / end of the line, return the matched string.  If
any characters are found that do not match \emph{regex}, return nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-split-range-string }}
\usebox{\funcname}\emph{range-string}
\index{shu-split-range-string} \hfill [Function]

\begin{doc-string}
\emph{range-string} is a string that contains either one or two numbers, possibly
separated by plus, minus, or period.  If one number then it is the starting number
and there is no ending number.  If two numbers then the first number is the start.
The operator in the middle determines the end.  If plus, then the end is the
second number added to the first.  If minus, then the end is the second number
subtracted from the first.  If period, then the end is the second number.

Return the two numbers as a cons cell (start . end).  If there is no end then the
cdr of the cons cell is nil.  If range string is not numeric, then both the car
and the cdr of the cons cell are nil.

For example, ``99+2'' has start 99 and end 101.  ``99-2'' has start 99 and end 97.
``99.103'' has start 99, end 103.  ``98'' has start 98 and end is nil.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-srs }}
\usebox{\funcname}\emph{rstring}
\index{shu-srs} \hfill [Command]\\%
 (Alias: srs)

\begin{doc-string}
A sed-like version of REPLACE-STRING.  REPLACE-STRING requires two arguments,
which are read interactively, one at a time.  This works well for normal
interactive use.

But sometimes you actually create the search and replacement strings in another
buffer to be fed to REPLACE-STRING.  To use these two strings you have to do the
following:

\small{\begin{verbatim}
     1. Invoke REPLACE-STRING
     2. Switch to the other buffer
     3. Copy the search string from the other buffer
     4. Switch back to the main buffer
     5. Paste the search string from the kill ring
     6. Hit enter
     7. Switch to the other buffer
     8. Copy the replacement string from the other buffer
     9. Switch back to the main buffer
    10. Paste the replacement string from the kill ring
    11. Hit enter
\end{verbatim}}

This function allows you to enter both strings at one prompt using a sed-like
syntax, such as

\small{\begin{verbatim}
     /abc/defg
\end{verbatim}}

This specifies a search string of ``abc\ and a replacement string of ``defg''.

The work flow now becomes

\small{\begin{verbatim}
     1. Invoke \emph{shu-srs}
     2. Switch to the other buffer
     3. Copy the search and replacement string from the other buffer
     4. Switch back to the main buffer
     5. Paste the search and replacement string from the kill ring
     6. Hit enter
\end{verbatim}}

You only have to go through six steps instead of eleven.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-srs-create-prompt }}
\usebox{\funcname}
\index{shu-srs-create-prompt} \hfill [Function]

\begin{doc-string}
This function creates the prompt for the shu-srs replacement function.
\emph{shu-srs-last-replace} is nil, this function prints the default prompt and returns
whatever the user types in.  If \emph{shu-srs-last-replace} is non-nil, the prompt
offers to replicate the last change made by \emph{shu-srs}.  If the user types nothing,
the last replacement string is returned.  If the user types something, that is
returned instead.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-srs-last-replace }}
\usebox{\funcname}
\index{shu-srs-last-replace} \hfill [Variable]

\begin{doc-string}
This holds the last string that was passed to shu-srs.  It is remembered here and used as the
prompt for subsequent invocations of shu-srs
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-system-name }}
\usebox{\funcname}
\index{shu-system-name} \hfill [Function]

\begin{doc-string}
Return the machine name.  Prior to emacs 25.1, this was held in the variable
system-name.  As of emacs 25.1, system-name is now a function.  Return nil if
system-name is neither a function nor a variable.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-system-name-string }}
\usebox{\funcname}
\index{shu-system-name-string} \hfill [Function]

\begin{doc-string}
Return the machine name.  Prior to emacs 25.1, this was held in the variable
system-name.  As of emacs 25.1, system-name is now a function.  Unlike
\emph{shu-system-name}, this function always returns a string, even if the machine
name is not available for some reason.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-tighten-hanging-paren }}
\usebox{\funcname}\emph{eof}
\index{shu-tighten-hanging-paren} \hfill [Command]

\begin{doc-string}
Call this function while point is on a left parenthesis.  This function will
find the matching right parenthesis.  If the matching right parenthesis is on a line
by itself and a previous line ends in another right parenthesis, the line and
dangling right parenthesis will be moved up to the end of the line that also ends
in a right parenthesis.  This is an internal part of the function \emph{shu-tighten-lisp}.
\emph{eof} is the point at which the current function on which we are operating ends.
This function removes some text from the current function.  It adjusts \emph{eof} appropriately
and returns the new value to the caller.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-tighten-lisp }}
\usebox{\funcname}
\index{shu-tighten-lisp} \hfill [Command]\\%
 (Alias: tighten-lisp)

\begin{doc-string}
Within the bounds of a lisp function or macro, ``tighten'' some lisp code.
Look for any single right parenthesis that is on its own line and move it up to
the end of the previous line.  This function is the opposite of \emph{shu-loosen-lisp}
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-tocify-markdown-file }}
\usebox{\funcname}
\index{shu-tocify-markdown-file} \hfill [Command]\\%
 (Alias: make-md-toc)

\begin{doc-string}
Search the file starting at the current position for any markdown headings of
the form ``\#\# This is a heading''.  Add a tag to each heading and then insert a
complete markdown table of contents at the current position.

Pound signs that lie inside of markdown literal areas designated by `````'' are
ignored.  This prevents something such as an example of an \#include directive
from being treated as a level 1 heading.

If a heading already has a tag, it is removed.  If a heading has trailing pound
signs, they are also removed.

The default maximum heading level is two, which means that heading levels
greater than two are not included in the table of contents.  But a numeric
prefix argument can change the maximum heading level.  The maximum heading level
cannot be set to a value less than one.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-tocify-markdown-headings }}
\usebox{\funcname}\emph{entries}
\index{shu-tocify-markdown-headings} \hfill [Function]

\begin{doc-string}
\emph{entries} is a list of cons cells.  The car of each item on the list is the
markdown heading line, which looks something like ``\#\# This is a heading''.
The cdr of each item on the list is the link name.  This function searches for
each markdown heading in the file and appends to the heading a tag of the form

\small{\begin{verbatim}
     <a name=link name></a>
\end{verbatim}}

so that it may be referenced from the table of contents.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-trim-git-end }}
\usebox{\funcname}\emph{path}
\index{shu-trim-git-end} \hfill [Command]

\begin{doc-string}
First trim leading and trailing spaces from \emph{path}.  If \emph{path} ends in ``.git'',
trim the last four characters from the path.  If \emph{path} does not end in ``.git'',
do not trim the last four characters.

Return the \emph{path}, leading and trailing spaces trimmed, with perhaps ``.git''
removed from the end.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-trim-header-line }}
\usebox{\funcname}\emph{trim-count}
\index{shu-trim-header-line} \hfill [Function]

\begin{doc-string}
If the first line of the buffer contains the sentinel ``-\emph\{*-C++-*-\}'', remove
\emph{trim-count} number of spaces from in front of the sentinel.

If the first line of the buffer does not contain the sentinel ``-\emph\{*-C++-*-\}'',
do nothing.

If there do not exist enough spaces to remove \emph{trim-count} of them, remove
as many as possible.

Return the number of spaces actually removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-trim-trailing-blanks }}
\usebox{\funcname}
\index{shu-trim-trailing-blanks} \hfill [Command]\\%
 (Alias: trim-trailing-blanks)

\begin{doc-string}
Eliminate whitespace at ends of all lines in the current buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-unbrace }}
\usebox{\funcname}
\index{shu-unbrace} \hfill [Command]\\%
 (Alias: unbrace)

\begin{doc-string}
When point is on an opening sexp, this function converts, within the scope of
the sexp, all ``\{'' to ``(`` and all ``\}'' to ``).''.
If the number of left braces does not match the number of right braces a warning
message is emitted.

For the benefit of unit tests, the count of left braces converted iff the count
of left braces matches the count of right braces.  If the counts do not match,
nil is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-winpath }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-winpath} \hfill [Command]\\%
 (Alias: winpath)

\begin{doc-string}
Take marked region, put in kill ring, changing / to \.
This makes it a valid path on windows machines.
\end{doc-string}

\eject
\section{shu-nvplist}


elisp code for maintaining directories of name / value pairs.


\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-item-nvplist }}
\usebox{\funcname}\emph{item}
\index{shu-get-item-nvplist} \hfill [Function]

\begin{doc-string}
Return the name value pair list from an item.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nvplist-get-item-number }}
\usebox{\funcname}\emph{item}
\index{shu-nvplist-get-item-number} \hfill [Function]

\begin{doc-string}
Return the item number for an item.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nvplist-get-item-value }}
\usebox{\funcname}\emph{name} \emph{item}
\index{shu-nvplist-get-item-value} \hfill [Function]

\begin{doc-string}
Extract a named list of values from an item.  \emph{name} is the name of the values to
find.  \emph{item} is the item from which to extract the values.  A list is returned that contain
all of the values whose name matches \emph{name}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nvplist-make-item }}
\usebox{\funcname}\emph{item-number} \emph{nvplist}
\index{shu-nvplist-make-item} \hfill [Function]

\begin{doc-string}
Create an item entry from an item number and a name value pair list.
The item entry is just a cons cell with the item number in the CAR and the
name-value pair list in the CDR.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nvplist-make-nvpair-list }}
\usebox{\funcname}\emph{tlist}
\index{shu-nvplist-make-nvpair-list} \hfill [Function]

\begin{doc-string}
Turn a list of tokens from an entry in the file into a list of name value pairs.  The
CAR of each entry in the list is the name.  The CDR of each entry in the list is the value.  If
errors are found in the token list, then an empty list is returned.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nvplist-make-token-list }}
\usebox{\funcname}\emph{tlist}
\index{shu-nvplist-make-token-list} \hfill [Function]

\begin{doc-string}
Turn an entry in a name / value file into a list of tokens.  The CAR of each entry is the point
at which the token starts.  the CDR of each entry in the list is the token itself.  On entry
to this function, point is immediately after the start delimiter (``$<$``).  On return, point
is positioned immediately after the end delimiter (``/$>$``).
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nvplist-parse-buffer }}
\usebox{\funcname}\emph{item-list}
\index{shu-nvplist-parse-buffer} \hfill [Function]

\begin{doc-string}
Parse an nvplist buffer, putting all of the items in the \emph{item-list}.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nvplist-parse-file }}
\usebox{\funcname}\emph{file-name} \emph{file-type}
\index{shu-nvplist-parse-file} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Parse a file full of name value pair lists.  The name of the file is \emph{file-name}.
The type of the file (only for error messages) is \emph{file-type}.  \emph{item-list} is the head
of the returned item list.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nvplist-show-item }}
\usebox{\funcname}\emph{item}
\index{shu-nvplist-show-item} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-nvplist-show-item-list }}
\usebox{\funcname}\emph{item-list}
\index{shu-nvplist-show-item-list} \hfill [Function]

\begin{doc-string}
Undocumented
\end{doc-string}

\eject
\section{shu-org-extensions}


The major function of this file is the function \emph{shu-org-archive-done-tasks},
which can be used as an after-save-hook for org files.  It finds each
TODO item that was marked DONE more than SHU-ORG-ARCHIVE-EXPIRY days
ago and moves it to an archive file by invoking org-archive-subtree
on it.


\subsection{List of functions by alias name}

A list of aliases and associated function names.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{gorg }}
\usebox{\funcname}
\index{gorg} \hfill [Command]\\%
 (Function: shu-goto-home-org-file)

\begin{doc-string}
Visit the org home file.
\end{doc-string}

\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-goto-home-org-file }}
\usebox{\funcname}
\index{shu-goto-home-org-file} \hfill [Command]\\%
 (Alias: gorg)

\begin{doc-string}
Visit the org home file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-org-archive-done-tasks }}
\usebox{\funcname}
\index{shu-org-archive-done-tasks} \hfill [Command]

\begin{doc-string}
Go through an org file and archive any completed TODO item that was completed more
than shu-org-archive-expiry-days days ago.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-org-archive-expiry-days }}
\usebox{\funcname}
\index{shu-org-archive-expiry-days} \hfill [Variable]

\begin{doc-string}
Number of elapsed days before a closed TODO item is automatically archived.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-org-date-match-regexp }}
\usebox{\funcname}
\index{shu-org-date-match-regexp} \hfill [Function]

\begin{doc-string}
Return a regexp string that matches an org date of the form 2014-04-01 Tue 13:18.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-org-done-keywords }}
\usebox{\funcname}
\index{shu-org-done-keywords} \hfill [Variable]

\begin{doc-string}
Key words that represent the DONE state.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-org-done-projects-string }}
\usebox{\funcname}
\index{shu-org-done-projects-string} \hfill [Function]

\begin{doc-string}
Return a string that is a search for a TODO tag that does not contain any of the
words that represent a DONE item.  These are the words defined in org-done-keywords-for-agenda.
If the two keywords that mean finished item are DONE and CANCELLED, then this function will
return the string: TODO=\{.+\}/-CANCELLED-DONE.  This is intended to be used in the definition
of the variable ``org-stuck-projects''.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-org-extensions-set-alias }}
\usebox{\funcname}
\index{shu-org-extensions-set-alias} \hfill [Function]

\begin{doc-string}
Set the common alias names for the functions in shu-misc.
These are generally the same as the function names with the leading
shu- prefix removed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-org-home }}
\usebox{\funcname}
\index{shu-org-home} \hfill [Variable]

\begin{doc-string}
Home directory of the org data files.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-org-state-regexp }}
\usebox{\funcname}\emph{done-word}
\index{shu-org-state-regexp} \hfill [Function]

\begin{doc-string}
Return a regular expression that will match a particular TODO state record of the form
   - State ``DONE''       from ``CANCELLED''  [2012-04-01 Tue 13:18]
  \emph{done-word} is the desired state of the record.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-org-todo-keywords }}
\usebox{\funcname}
\index{shu-org-todo-keywords} \hfill [Variable]

\begin{doc-string}
Key words that represent the not DONE state.
\end{doc-string}

\eject
\section{shu-xref}



A set of functions that scan a set of elisp files and create a cross reference
of all of the definitions (functions, macros, constants, variables, etc.).
See the doc string for \emph{shu-make-xref} for further details.


\subsection{List of functions and variables}

List of functions and variable definitions in this package.



\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-get-all-definitions }}
\usebox{\funcname}\emph{fun-defs}
\index{shu-get-all-definitions} \hfill [Function]

\begin{doc-string}
Find all of the emacs lisp function definitions in the current buffer.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-make-xref }}
\usebox{\funcname}\emph{start} \emph{end}
\index{shu-make-xref} \hfill [Command]

\begin{doc-string}
Mark a region in a file that contains one name per line of an emacs lisp file
Then invoke shu-make-xref.  It will do a cross reference of all of those files.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-buffer }}
\usebox{\funcname}
\index{shu-xref-buffer} \hfill [Constant]

\begin{doc-string}
The name of the buffer into which the cross reference is placed.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-dump }}
\usebox{\funcname}\emph{fun-defs} \emph{max-var-name-length}
\index{shu-xref-dump} \hfill [Function]
\hspace*{\wd\funcname}

\begin{doc-string}
Undocumented
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-file-compare }}
\usebox{\funcname}\emph{t1} \emph{t2}
\index{shu-xref-file-compare} \hfill [Function]

\begin{doc-string}
Compare the file names from two variable names.  Return t if the file
name in \emph{t1} comes before the type name in \emph{t2}.  If the file names are the same,
then compare the variable names so that variables are in alphabetical order
within file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-get-defs }}
\usebox{\funcname}\emph{file-list} \emph{fun-defs}
\index{shu-xref-get-defs} \hfill [Function]

\begin{doc-string}
Extract the variable definitions from each file.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-get-file-list }}
\usebox{\funcname}\emph{start} \emph{end} \emph{file-list}
\index{shu-xref-get-file-list} \hfill [Command]

\begin{doc-string}
Return a list of file names from a region of a buffer.  \emph{start} and \emph{end}
define the region.  Each line in the region is assumed to be a file name.
\emph{file-list} is the list that is also the return value of this function.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-get-longest-name }}
\usebox{\funcname}\emph{fun-defs}
\index{shu-xref-get-longest-name} \hfill [Function]

\begin{doc-string}
 Return the length of the longest variable name in the list and the longest type
name in the list.  These are returned as a cons cell with the length of the longest
type name in the CAR and the longest variable name in the CDR.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-get-next-definition }}
\usebox{\funcname}\emph{retval}
\index{shu-xref-get-next-definition} \hfill [Function]

\begin{doc-string}
Find and return the next definition of an emacs lisp function of variable.
   \emph{retval} is returned
as nil if there are no more function definitions after point.  If a definition
is found, \emph{retval} is returned as a cons cell with the name of the function
in the CAR and the information about the function in the CDR.  The information in the
CDR is a cons cell with the numeric variable type in the CAR and the line number in
which the definition started in the CDR.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-get-next-funcall }}
\usebox{\funcname}\emph{name} \emph{retval}
\index{shu-xref-get-next-funcall} \hfill [Function]

\begin{doc-string}
Find and return the next call to the emacs lisp function \emph{name}.  \emph{retval} is returned
as nil if there are no more function invocations after point.  If a function
invocation is found, \emph{retval} is returned as a cons cell with the name of the function
in the CAR and the line number in which the function definition starts in the CDR.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-lisp-name }}
\usebox{\funcname}
\index{shu-xref-lisp-name} \hfill [Constant]

\begin{doc-string}
A regular expression to match a variable name in emacs lisp.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-type-compare }}
\usebox{\funcname}\emph{t1} \emph{t2}
\index{shu-xref-type-compare} \hfill [Function]

\begin{doc-string}
Compare the type names from two variable names.  Return t if the type
name in \emph{t1} comes before the type name in \emph{t2}.  If the type names are the same,
then compare the variable names so that variables are in alphabetical order
within type.
\end{doc-string}

\vspace{1em}
\noindent
\savebox{\funcname}{\noindent\texttt{shu-xref-var-types }}
\usebox{\funcname}
\index{shu-xref-var-types} \hfill [Constant]

\begin{doc-string}
Associate a number with each type of variable
\end{doc-string}
